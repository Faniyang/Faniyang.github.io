<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Layer2 —— OP Stack 介绍</title>
      <link href="/2025/10/05/op-stack-intro-part5/"/>
      <url>/2025/10/05/op-stack-intro-part5/</url>
      
        <content type="html"><![CDATA[<p>OP Stack 是由 Optimism 团队开发的模块化区块链技术栈，让开发者能够像”搭积木”一样构建自己的 Layer2 网络。可以将 OP Stack 想象成一个”区块链建设套件”，里面包含了构建高性能区块链所需的所有核心组件。</p><h2 id="1-核心要点"><a href="#1-核心要点" class="headerlink" title="1. 核心要点"></a>1. 核心要点</h2><ul><li><strong>Optimistic Rollup 技术</strong>：采用”乐观验证”机制——默认信任交易是正确的，只在出现争议时才进行验证</li><li><strong>完全 EVM 兼容</strong>：现有的以太坊智能合约可以无需修改直接部署</li><li><strong>安全性继承</strong>：通过将数据发布到以太坊主网，继承了以太坊 L1 的安全性</li><li><strong>模块化设计</strong>：各个组件职责明确，可以独立升级和替换</li><li><strong>六大核心组件</strong>：op-geth（执行引擎）、op-node（共识层）、op-batcher（批处理器）、op-proposer（状态提议器）、op-challenger（争议挑战器）和 L1 合约系统</li></ul><p><strong>性能提升对比：</strong></p><table><thead><tr><th>指标</th><th>以太坊 L1</th><th>OP Stack L2</th><th>提升倍数</th></tr></thead><tbody><tr><td>TPS</td><td>15-30</td><td>150-2000</td><td>10-100x</td></tr><tr><td>出块时间</td><td>12 秒</td><td>2 秒</td><td>6x 加速</td></tr><tr><td>交易费用</td><td>5-50 USD</td><td>0.01-0.5 USD</td><td>降低 90%+</td></tr></tbody></table><h2 id="2-为什么需要-OP-Stack？"><a href="#2-为什么需要-OP-Stack？" class="headerlink" title="2. 为什么需要 OP Stack？"></a>2. 为什么需要 OP Stack？</h2><h3 id="2-1-Rollup-解决方案"><a href="#2-1-Rollup-解决方案" class="headerlink" title="2.1 Rollup 解决方案"></a>2.1 Rollup 解决方案</h3><p>OP Stack 采用 <strong>Rollup</strong> 技术——将计算和状态存储移到链下（Layer2），只把交易数据和最终状态发布到链上（Layer1）。</p><p><strong>工作原理类比：</strong> 想象你在玩一个复杂的棋局：</p><ul><li><strong>传统方式</strong>：每走一步都要裁判（以太坊主网）记录并验证</li><li><strong>Rollup 方式</strong>：你们自己下完整局（L2 执行），最后只把完整棋谱交给裁判存档（L1 数据发布）</li></ul><p>这样做的好处：减轻主网计算负担、降低交易成本、保持安全性。</p><h3 id="2-2-Optimistic-的”乐观”哲学"><a href="#2-2-Optimistic-的”乐观”哲学" class="headerlink" title="2.2 Optimistic 的”乐观”哲学"></a>2.2 Optimistic 的”乐观”哲学</h3><p>OP Stack 采用 <strong>Optimistic Rollup</strong>，核心理念是”乐观假设”：</p><ul><li><strong>默认信任</strong>：假设所有提交的状态都是正确的</li><li><strong>挑战期机制</strong>：给予 7 天时间让任何人挑战错误状态</li><li><strong>欺诈证明</strong>：只有在出现争议时才进行链上验证</li></ul><p>这就像是”先上车后补票”——大部分情况下大家都诚实，只有少数情况需要核查。</p><h2 id="3-OP-Stack-整体架构"><a href="#3-OP-Stack-整体架构" class="headerlink" title="3. OP Stack 整体架构"></a>3. OP Stack 整体架构</h2><p>OP Stack 采用分层架构，每一层都有明确的职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                 L1 (以太坊主网)                      │</span><br><span class="line">│  ┌──────────────┐    ┌──────────────────────┐       │</span><br><span class="line">│  │ L1 桥接合约   │    │ 争议解决合约          │       │</span><br><span class="line">│  └──────────────┘    └──────────────────────┘       │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br><span class="line">                         ↕</span><br><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                 L2 执行与共识层                      │</span><br><span class="line">│  ┌──────────┐  ┌──────────┐  ┌──────────────┐       │</span><br><span class="line">│  │ op-geth  │◄─│ op-node  │◄─│ op-batcher   │       │</span><br><span class="line">│  └──────────┘  └──────────┘  └──────────────┘       │</span><br><span class="line">│       ↓             ↓                               │</span><br><span class="line">│  ┌──────────────┐  ┌─────────────────┐              │</span><br><span class="line">│  │ op-proposer  │  │  op-challenger  │              │</span><br><span class="line">│  └──────────────┘  └─────────────────┘              │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>关键设计原则：</strong></p><ul><li><strong>数据可用性</strong>：所有交易数据都发布到 L1，确保任何人都能重建 L2 状态</li><li><strong>模块化解耦</strong>：每个组件可以独立升级</li><li><strong>最小信任假设</strong>：只需假设”至少有一个诚实的验证者存在”</li></ul><h2 id="4-核心组件详解"><a href="#4-核心组件详解" class="headerlink" title="4. 核心组件详解"></a>4. 核心组件详解</h2><h3 id="4-1-op-geth：执行引擎"><a href="#4-1-op-geth：执行引擎" class="headerlink" title="4.1 op-geth：执行引擎"></a>4.1 op-geth：执行引擎</h3><p><strong>角色定位：</strong> L2 的”大脑”，负责执行交易和维护状态</p><p>op-geth 是基于以太坊官方 go-ethereum 客户端的定制版本，保持了 100% 的 EVM 兼容性。</p><p><strong>核心功能：</strong></p><ol><li><strong>交易执行</strong>：接收用户交易，在 EVM 中执行智能合约代码，计算新状态</li><li><strong>状态管理</strong>：维护完整的账户和合约状态树，使用 Archive 模式保存所有历史状态</li><li><strong>与 op-node 协作</strong>：通过 Engine API 接收区块生产指令，执行交易并返回结果</li></ol><p><strong>关键特性：</strong></p><p><strong>Gas 计费改进</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总费用 = L2 执行费 + L1 数据费</span><br></pre></td></tr></table></figure><ul><li><strong>L2 执行费</strong>：合约计算消耗（类似以太坊）</li><li><strong>L1 数据费</strong>：将交易数据发布到 L1 的成本（主要开销）</li></ul><p><strong>区块生产方式</strong></p><ul><li>不同于以太坊的 PoW&#x2F;PoS，op-geth 由 Sequencer 主导区块生产</li><li>支持固定的出块时间（如每 2 秒一个区块）</li></ul><h3 id="4-2-op-node：Rollup-共识协调者"><a href="#4-2-op-node：Rollup-共识协调者" class="headerlink" title="4.2 op-node：Rollup 共识协调者"></a>4.2 op-node：Rollup 共识协调者</h3><p><strong>角色定位：</strong> L2 的”协调员”，连接 L1 和 L2，负责共识逻辑</p><p>如果说 op-geth 是执行者，那么 op-node 就是指挥官。</p><p><strong>核心职责：</strong></p><p><strong>1. 区块派生（Block Derivation）</strong></p><p>这是 op-node 最核心的功能。它从 L1 上读取 Batcher 提交的交易批次，然后”派生”出 L2 区块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1 区块 → 扫描 Batcher 交易 → 提取批次数据 → 解压缩</span><br><span class="line">  → 解析交易列表 → 构建 L2 区块 → 发送给 op-geth 执行</span><br></pre></td></tr></table></figure><p><strong>为什么需要派生？</strong> 因为 L2 区块的权威来源是 L1 上的数据，而不是 Sequencer 的声明。即使 Sequencer 作恶或下线，任何人都可以通过 L1 数据重建完整的 L2 链。</p><p><strong>2. Sequencer 模式 vs Verifier 模式</strong></p><ul><li><strong>Sequencer 模式</strong>：作为主节点运行，接收交易、排序、生产区块</li><li><strong>Verifier 模式</strong>：作为从节点运行，完全依赖 L1 数据进行区块派生和验证</li></ul><p><strong>3. 三种区块状态</strong></p><p>op-node 维护着区块的三种不同状态：</p><table><thead><tr><th>状态</th><th>含义</th><th>确认时间</th><th>安全保障</th></tr></thead><tbody><tr><td><strong>Unsafe</strong></td><td>刚由 Sequencer 生产</td><td>2 秒</td><td>可能被重组</td></tr><tr><td><strong>Safe</strong></td><td>已提交到 L1 并确认</td><td>1-2 分钟</td><td>数据可用性保证</td></tr><tr><td><strong>Finalized</strong></td><td>状态根已确认且过挑战期</td><td>7 天</td><td>可用于 L1 提款</td></tr></tbody></table><h3 id="4-3-op-batcher：批量打包器"><a href="#4-3-op-batcher：批量打包器" class="headerlink" title="4.3 op-batcher：批量打包器"></a>4.3 op-batcher：批量打包器</h3><p><strong>角色定位：</strong> L2 到 L1 的”快递员”，负责将交易数据运送到主网</p><p>Batcher 是整个系统中持续运营成本最高的组件——它需要不断向 L1 发送交易。</p><p><strong>工作机制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L2 交易 → op-geth 执行 → op-node 区块 → op-batcher 收集</span><br><span class="line">  → 压缩打包 → 提交到 L1 → 验证者读取 → 重建 L2 状态</span><br></pre></td></tr></table></figure><p><strong>核心功能：</strong></p><p><strong>1. 交易收集与压缩</strong></p><ul><li>定期（如每 1 秒）从 op-node 拉取最新的 Unsafe 区块</li><li>使用 zlib&#x2F;brotli 压缩数据（压缩率 5-10x）</li><li>按照 Channel（通道）的概念组织数据</li></ul><p><strong>2. 批次提交方式</strong></p><p>有两种提交方式：</p><table><thead><tr><th>方式</th><th>特点</th><th>成本</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Calldata</strong></td><td>永久存储</td><td>高（每字节 16 gas）</td><td>需要长期数据可用性</td></tr><tr><td><strong>Blob (EIP-4844)</strong></td><td>保留 30 天</td><td>低（降低 90%）</td><td>标准运营（推荐）</td></tr></tbody></table><p><strong>3. 费用优化</strong></p><ul><li>监控 L1 Gas 价格波动，在低价时段批量提交</li><li>支持交易失败后自动重发</li><li>避免 nonce 冲突导致的交易卡顿</li></ul><h3 id="4-4-op-proposer：状态提议器"><a href="#4-4-op-proposer：状态提议器" class="headerlink" title="4.4 op-proposer：状态提议器"></a>4.4 op-proposer：状态提议器</h3><p><strong>角色定位：</strong> L2 到 L1 的”公证员”，定期提交状态根声明</p><p>Proposer 向以太坊主网”宣告”L2 的当前状态，这些声明在经过挑战期后成为最终确定的状态。</p><p><strong>核心功能：</strong></p><p><strong>1. 状态根提交</strong></p><p>什么是状态根？</p><ul><li>状态根是整个 L2 状态的”指纹”（Merkle Root）</li><li>它唯一确定了某个区块高度时所有账户和合约的状态</li></ul><p><strong>工作流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 从 op-node 获取 Safe 区块的状态根</span><br><span class="line">2. 调用 L1 的 DisputeGameFactory 合约创建提议</span><br><span class="line">3. 质押 Bond（如 0.08 ETH）作为诚实保证金</span><br><span class="line">4. 提议进入 7 天挑战期</span><br><span class="line">5. 无人挑战 → 提议被接受 → 取回 Bond</span><br><span class="line">6. 挑战成功 → 提议被拒绝 → Bond 被罚没</span><br></pre></td></tr></table></figure><p><strong>2. 提议间隔控制</strong></p><p>Proposer 不会每个区块都提交状态根（成本太高），而是每隔固定时间提交一次（如 15 分钟），平衡安全性和成本。</p><p><strong>3. 最终性推进</strong></p><p>只有经过挑战期的状态根才能用于：</p><ul><li>用户从 L2 提款到 L1</li><li>跨链消息的最终确认</li><li>资产桥的安全释放</li></ul><p><strong>经济模型：</strong></p><ul><li><strong>Bond 质押</strong>：每次提议需质押 0.08 ETH（可配置）</li><li><strong>L1 Gas 费</strong>：提交提议的交易费用</li><li><strong>诚实提议</strong>：7 天后取回 Bond（零成本）</li><li><strong>错误提议</strong>：失去全部 Bond（被 Challenger 夺取）</li></ul><h3 id="4-5-op-challenger：争议挑战器"><a href="#4-5-op-challenger：争议挑战器" class="headerlink" title="4.5 op-challenger：争议挑战器"></a>4.5 op-challenger：争议挑战器</h3><p><strong>角色定位：</strong> 系统的”安全卫士”，监督并挑战错误的状态提议</p><p>Challenger 是 OP Stack 安全模型的核心——它实现了”只需一个诚实节点”的信任假设。</p><p><strong>核心职责：</strong></p><p><strong>1. 持续监控</strong></p><ul><li>7x24 小时监听 L1 上所有新创建的争议游戏</li><li>从 op-node 获取本地计算的正确状态根</li><li>对比链上提议与本地状态，检测差异</li></ul><p><strong>2. 发起挑战</strong></p><p>当检测到错误提议时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 质押 Bond 创建挑战</span><br><span class="line">2. 参与多轮交互式欺诈证明游戏</span><br><span class="line">3. 最终提交单步证明证明 Proposer 错误</span><br><span class="line">4. 胜利后夺取 Proposer 的 Bond</span><br></pre></td></tr></table></figure><p><strong>3. Fault Proof Game（欺诈证明游戏）</strong></p><p>这是 OP Stack V2 的核心创新机制：</p><p><strong>游戏流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第 1 轮：二分查找开始</span><br><span class="line">  Challenger 质疑：区块 1000-1100 中某处有错误</span><br><span class="line">  → 要求 Proposer 证明区块 1050 的状态</span><br><span class="line"></span><br><span class="line">第 2-N 轮：持续二分</span><br><span class="line">  → 缩小范围：100 个区块 → 50 → 25 → ... → 1 个区块</span><br><span class="line">  → 继续缩小：1 个区块 → 单个交易 → 单个 EVM 指令</span><br><span class="line"></span><br><span class="line">最后一轮：单步证明</span><br><span class="line">  → 定位到单个 MIPS 指令</span><br><span class="line">  → Challenger 在 L1 上实际执行这条指令</span><br><span class="line">  → 证明 Proposer 声称的输出错误</span><br><span class="line">  → Challenger 胜利，夺取 Bond</span><br></pre></td></tr></table></figure><p><strong>CANNON 证明系统：</strong></p><ul><li>将 op-geth 和 op-node 编译为 MIPS 指令集</li><li>创建 MIPS 虚拟机的链上实现</li><li>在争议时，在 L1 上执行单个 MIPS 指令进行验证</li></ul><p><strong>为什么这套机制有效？</strong></p><p><strong>经济激励：</strong></p><ul><li>挑战成功 → 获得 Proposer 的 Bond</li><li>挑战失败 → 失去自己的 Bond</li><li>诚实参与是最优策略</li></ul><p><strong>1-of-N 诚实假设：</strong></p><ul><li>只需一个诚实 Challenger 存在即可保证安全</li><li>任何人都可以无需许可地运行 Challenger</li></ul><p><strong>谁应该运行 Challenger？</strong></p><ul><li>桥接服务提供商：保护管理的资金</li><li>大户投资者：保护大额 L2 资产</li><li>生态贡献者：为公共利益提供监督</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li><strong>OP Stack 是一个完整的 L2 建设工具包</strong>：包含执行、共识、数据发布、争议解决等所有模块</li><li><strong>采用 Optimistic Rollup 技术</strong>：通过”乐观假设”实现高性能，7 天挑战期保证安全</li><li><strong>1-of-N 安全假设</strong>：只需一个诚实 Challenger 即可保护全网</li><li><strong>性能提升显著</strong>：相比以太坊 L1，TPS 提升 10-100 倍，成本降低 90%+</li><li><strong>完全 EVM 兼容</strong>：现有 DApp 可无缝迁移</li></ul><p><strong>Hooray！OP Stack 深度解析完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> OPStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— SPL TOKEN 简单合约</title>
      <link href="/2025/10/04/solana-spl-token/"/>
      <url>/2025/10/04/solana-spl-token/</url>
      
        <content type="html"><![CDATA[<p>本节实现了一个 Solana SPL Token 程序，包括链上智能合约和客户端调用代码。主要功能包括：</p><ul><li>创建新的 SPL Token</li><li>铸造代币到用户账户</li></ul><h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><h3 id="1-1-什么是-SPL-Token"><a href="#1-1-什么是-SPL-Token" class="headerlink" title="1.1 什么是 SPL Token"></a>1.1 什么是 SPL Token</h3><p>SPL Token 是 Solana 上的标准代币协议，类似于以太坊的 ERC-20。它定义了在 Solana 区块链上创建和管理可替代代币的规范。</p><h3 id="1-2-关键账户类型"><a href="#1-2-关键账户类型" class="headerlink" title="1.2 关键账户类型"></a>1.2 关键账户类型</h3><table><thead><tr><th>账户类型</th><th>所有者</th><th>用途</th><th>大小</th></tr></thead><tbody><tr><td>Mint Account</td><td>SPL Token Program</td><td>存储代币元数据（总供应量、小数位数、铸币权限等）</td><td>82 字节</td></tr><tr><td>Token Account</td><td>SPL Token Program</td><td>存储用户持有的特定代币余额</td><td>165 字节</td></tr><tr><td>Associated Token Account (ATA)</td><td>SPL Token Program</td><td>与用户钱包关联的标准代币账户</td><td>165 字节</td></tr></tbody></table><h3 id="1-3-核心程序"><a href="#1-3-核心程序" class="headerlink" title="1.3 核心程序"></a>1.3 核心程序</h3><ul><li><strong>SPL Token Program</strong>：管理代币铸造、转账等操作的核心程序</li><li><strong>Associated Token Account Program</strong>：管理 ATA 的创建和查询</li><li><strong>System Program</strong>：Solana 系统程序，用于创建账户和转账 SOL</li></ul><h2 id="2-链上程序实现"><a href="#2-链上程序实现" class="headerlink" title="2. 链上程序实现"></a>2. 链上程序实现</h2><h3 id="2-1-程序入口"><a href="#2-1-程序入口" class="headerlink" title="2.1 程序入口"></a>2.1 程序入口</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process</span>(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    accounts: &amp;[AccountInfo],</span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction</span> = TokenInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line">    <span class="keyword">match</span> instruction &#123;</span><br><span class="line">        TokenInstruction::CreateToken &#123; decimals &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">create_token</span>(accounts, decimals),</span><br><span class="line">        TokenInstruction::Mint &#123; amount &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">mint</span>(accounts, amount),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>try_from_slice</code>：使用 Borsh 反序列化指令数据</li><li><code>match</code>：根据指令类型路由到不同的处理函数</li><li>支持两种指令：创建代币和铸造代币</li></ul><h3 id="2-2-创建代币流程"><a href="#2-2-创建代币流程" class="headerlink" title="2.2 创建代币流程"></a>2.2 创建代币流程</h3><h4 id="步骤一：账户准备"><a href="#步骤一：账户准备" class="headerlink" title="步骤一：账户准备"></a>步骤一：账户准备</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;        <span class="comment">// Mint 账户</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_authority</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;      <span class="comment">// 铸币权限</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;               <span class="comment">// 支付者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;         <span class="comment">// 租金系统变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;      <span class="comment">// 系统程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;       <span class="comment">// SPL Token 程序</span></span><br></pre></td></tr></table></figure><p>关键点：</p><ul><li><code>next_account_info</code>：按顺序获取账户信息</li><li>账户顺序必须与客户端传入的顺序一致</li><li>每个账户都有特定的用途和权限要求</li></ul><h4 id="步骤二：创建-Mint-账户"><a href="#步骤二：创建-Mint-账户" class="headerlink" title="步骤二：创建 Mint 账户"></a>步骤二：创建 Mint 账户</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        payer.key,                                      <span class="comment">// 支付者</span></span><br><span class="line">        mint_account.key,                               <span class="comment">// 新账户地址</span></span><br><span class="line">        (Rent::<span class="title function_ invoke__">get</span>()?).<span class="title function_ invoke__">minimum_balance</span>(Mint::LEN),      <span class="comment">// 租金</span></span><br><span class="line">        Mint::LEN <span class="keyword">as</span> <span class="type">u64</span>,                               <span class="comment">// 账户大小</span></span><br><span class="line">        token_program.key,                              <span class="comment">// 所有者程序</span></span><br><span class="line">    ),</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>invoke</code>：跨程序调用（CPI），调用系统程序创建账户</li><li><code>minimum_balance(Mint::LEN)</code>：计算存储 Mint 数据所需的最低租金</li><li><code>Mint::LEN</code>：Mint 账户固定大小为 82 字节</li><li><code>token_program.key</code>：将账户所有权转给 SPL Token 程序</li></ul><p><strong>租金机制：</strong></p><p>Solana 要求账户保持最低余额以避免被垃圾回收。82 字节 Mint 账户约需 0.00144 SOL（具体金额取决于网络）。这个余额类似于押金，关闭账户时可以完全收回。</p><h4 id="步骤三：初始化-Mint"><a href="#步骤三：初始化-Mint" class="headerlink" title="步骤三：初始化 Mint"></a>步骤三：初始化 Mint</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ix</span> = <span class="title function_ invoke__">initialize_mint</span>(</span><br><span class="line">    &amp;spl_token::<span class="title function_ invoke__">id</span>(),           <span class="comment">// SPL Token 程序 ID</span></span><br><span class="line">    &amp;mint_account.key,          <span class="comment">// Mint 账户地址</span></span><br><span class="line">    &amp;mint_authority.key,        <span class="comment">// 铸币权限所有者</span></span><br><span class="line">    <span class="literal">None</span>,                       <span class="comment">// 冻结权限（可选）</span></span><br><span class="line">    decimals,                   <span class="comment">// 小数位数</span></span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">    &amp;ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        mint_authority.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">    &amp;[],  <span class="comment">// 签名种子（此处为空）</span></span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>initialize_mint</code>：构造初始化 Mint 的指令</li><li><code>decimals</code>：代币小数位数（如 USDC 使用 6，表示 1 USDC &#x3D; 1,000,000 基础单位）</li><li><code>None</code>：不设置冻结权限（设置后可冻结用户账户）</li><li><code>invoke_signed</code>：使用签名调用（这里虽然传空数组，但保持接口一致性）</li></ul><p><strong>为什么分两步？</strong></p><ol><li>系统程序只负责创建账户并分配空间</li><li>SPL Token 程序负责初始化 Mint 的具体数据结构</li></ol><p>这种设计符合 Solana 的所有权模型：只有账户的所有者程序才能修改其数据。</p><h3 id="2-3-铸造代币流程"><a href="#2-3-铸造代币流程" class="headerlink" title="2.3 铸造代币流程"></a>2.3 铸造代币流程</h3><h4 id="步骤一：账户准备-1"><a href="#步骤一：账户准备-1" class="headerlink" title="步骤一：账户准备"></a>步骤一：账户准备</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;              <span class="comment">// Mint 账户</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;  <span class="comment">// ATA</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;               <span class="comment">// 租金</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;                     <span class="comment">// 支付者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;            <span class="comment">// 系统程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;             <span class="comment">// Token 程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;  <span class="comment">// ATA 程序</span></span><br></pre></td></tr></table></figure><h4 id="步骤二：检查并创建-ATA"><a href="#步骤二：检查并创建-ATA" class="headerlink" title="步骤二：检查并创建 ATA"></a>步骤二：检查并创建 ATA</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> associated_token_account.<span class="title function_ invoke__">lamports</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;Creating associated token account...&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">        &amp;spl_associated_token_account::instruction::<span class="title function_ invoke__">create_associated_token_account</span>(</span><br><span class="line">            payer.key,           <span class="comment">// 支付者</span></span><br><span class="line">            payer.key,           <span class="comment">// ATA 所有者</span></span><br><span class="line">            mint_account.key,    <span class="comment">// 代币类型</span></span><br><span class="line">            token_program.key,   <span class="comment">// Token 程序</span></span><br><span class="line">        ),</span><br><span class="line">        &amp;[</span><br><span class="line">            payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ],</span><br><span class="line">    )?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>lamports() == 0</code>：检查账户是否存在（未创建的账户余额为 0）</li><li>ATA 地址通过确定性算法生成：<code>derive([owner, token_program, mint])</code></li><li>首次铸造时自动创建，后续无需重复创建</li></ul><p><strong>ATA 的优势：</strong></p><ul><li>每个用户对每种代币只有一个标准地址</li><li>地址可预测，无需提前告知</li><li>简化钱包管理</li></ul><h4 id="步骤三：执行铸币"><a href="#步骤三：执行铸币" class="headerlink" title="步骤三：执行铸币"></a>步骤三：执行铸币</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    &amp;<span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">        token_program.key,                 <span class="comment">// Token 程序</span></span><br><span class="line">        mint_account.key,                  <span class="comment">// Mint 账户</span></span><br><span class="line">        associated_token_account.key,      <span class="comment">// 接收账户</span></span><br><span class="line">        payer.key,                         <span class="comment">// 铸币权限所有者</span></span><br><span class="line">        &amp;[payer.key],                      <span class="comment">// 签名者列表</span></span><br><span class="line">        amount,                            <span class="comment">// 铸造数量</span></span><br><span class="line">    )?,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>mint_to</code>：SPL Token 程序的铸币指令</li><li><code>payer.key</code>：必须是 Mint 的 mint_authority</li><li><code>amount</code>：最小单位数量（需要考虑 decimals）</li></ul><p><strong>权限验证：</strong></p><p>SPL Token 程序会验证 <code>payer</code> 是否为 <code>mint_authority</code>。只有拥有铸币权限的账户才能铸造新代币。</p><h2 id="3-客户端实现"><a href="#3-客户端实现" class="headerlink" title="3. 客户端实现"></a>3. 客户端实现</h2><h3 id="3-1-指令定义"><a href="#3-1-指令定义" class="headerlink" title="3.1 指令定义"></a>3.1 指令定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(BorshSerialize, BorshDeserialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken &#123; decimals: <span class="type">u8</span> &#125;,</span><br><span class="line">    Mint &#123; amount: <span class="type">u64</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li>枚举类型定义两种指令</li><li><code>BorshSerialize/BorshDeserialize</code>：实现 Borsh 序列化</li><li>必须与链上程序的定义完全一致</li></ul><h3 id="3-2-创建代币"><a href="#3-2-创建代币" class="headerlink" title="3.2 创建代币"></a>3.2 创建代币</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rpc_client</span> = RpcClient::<span class="title function_ invoke__">new</span>(<span class="string">&quot;http://127.0.0.1:8899&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/home/sol/.config/solana/wallet.json&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">program_id</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;4KKcAuZrm8y7wxoVa4PpR8YQqx96bSSuD6bdVsYmvNWE&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = Keypair::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>RpcClient</code>：连接到本地测试网（也可连接 devnet、mainnet）</li><li><code>read_keypair_file</code>：从文件加载钱包私钥</li><li><code>Keypair::new()</code>：生成新的 Mint 账户密钥对</li></ul><h4 id="构建指令数据"><a href="#构建指令数据" class="headerlink" title="构建指令数据"></a>构建指令数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::CreateToken &#123; decimals &#125;)?;</span><br></pre></td></tr></table></figure><p><strong>序列化过程：</strong></p><ol><li>创建 <code>CreateToken</code> 指令实例</li><li>Borsh 序列化为字节数组</li><li>字节数组会被传递给链上程序</li></ol><h4 id="配置账户元数据"><a href="#配置账户元数据" class="headerlink" title="配置账户元数据"></a>配置账户元数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),          <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(*mint_authority, <span class="literal">false</span>),      <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">false</span>),       <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),   <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>), <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),      <span class="comment">// 只读</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>AccountMeta 详解：</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>用途</th></tr></thead><tbody><tr><td><code>new(pubkey, is_signer)</code></td><td>可写账户</td><td>需要修改数据或余额的账户</td></tr><tr><td><code>new_readonly(pubkey, is_signer)</code></td><td>只读账户</td><td>只读取数据的账户</td></tr></tbody></table><p>**重要提示：**账户顺序必须与链上程序 <code>next_account_info</code> 的顺序完全一致！</p><h4 id="构建和发送交易"><a href="#构建和发送交易" class="headerlink" title="构建和发送交易"></a>构建和发送交易</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction &#123;</span><br><span class="line">    program_id: *program_id,</span><br><span class="line">    accounts,</span><br><span class="line">    data: instruction_data,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],                  <span class="comment">// 指令列表</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),                 <span class="comment">// 手续费支付者</span></span><br><span class="line">    &amp;[payer, mint_account],                <span class="comment">// 签名者列表</span></span><br><span class="line">    latest_blockhash,                      <span class="comment">// 最新区块哈希</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">signature</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>get_latest_blockhash()</code>：获取最新区块哈希防止重放攻击</li><li>双重签名：<code>payer</code> 支付手续费，<code>mint_account</code> 授权创建</li><li><code>send_and_confirm_transaction</code>：发送并等待确认</li></ul><h3 id="3-3-铸造代币"><a href="#3-3-铸造代币" class="headerlink" title="3.3 铸造代币"></a>3.3 铸造代币</h3><h4 id="计算-ATA-地址"><a href="#计算-ATA-地址" class="headerlink" title="计算 ATA 地址"></a>计算 ATA 地址</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ata</span> = <span class="title function_ invoke__">get_associated_token_address</span>(</span><br><span class="line">    &amp;payer.<span class="title function_ invoke__">pubkey</span>(),</span><br><span class="line">    &amp;mint_account.<span class="title function_ invoke__">pubkey</span>(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>确定性推导：</strong></p><ul><li>基于 owner 和 mint 确定性计算</li><li>无需提前创建，地址可预测</li><li>公式：<code>findProgramAddress([owner, TOKEN_PROGRAM_ID, mint], ASSOCIATED_TOKEN_PROGRAM_ID)</code></li></ul><h4 id="配置账户元数据-1"><a href="#配置账户元数据-1" class="headerlink" title="配置账户元数据"></a>配置账户元数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),              <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(ata, <span class="literal">false</span>),                               <span class="comment">// 可写</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),       <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),                     <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),     <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),          <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_associated_token_account::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>), <span class="comment">// 只读</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>权限说明：</strong></p><ul><li>Mint 账户可写：需要更新 supply 字段</li><li>ATA 可写：需要更新代币余额</li><li>Payer 可写：需要支付 ATA 创建费用（如果尚未创建）</li></ul><h4 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">    &amp;[payer, mint_account],  <span class="comment">// Mint 需要签名验证铸币权限</span></span><br><span class="line">    latest_blockhash,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">signature</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br></pre></td></tr></table></figure><h2 id="4-完整工作流程"><a href="#4-完整工作流程" class="headerlink" title="4. 完整工作流程"></a>4. 完整工作流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">客户端                              Solana 网络                          链上程序</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |-------- CreateToken 交易 -----------&gt;|                                    |</span><br><span class="line">  |                                      |---------- 调用 process() ---------&gt;|</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |                                      |           create_token()           |</span><br><span class="line">  |                                      |        1. 创建 Mint 账户            |</span><br><span class="line">  |                                      |        2. 初始化 Mint 数据          |</span><br><span class="line">  |                                      |&lt;---------- 返回成功 ----------------|</span><br><span class="line">  |&lt;--------- 交易确认 ------------------|                                     |</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |---------- Mint 交易 ----------------&gt;|                                    |</span><br><span class="line">  |                                      |---------- 调用 process() ---------&gt;|</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |                                      |             mint()                 |</span><br><span class="line">  |                                      |        1. 检查/创建 ATA            |</span><br><span class="line">  |                                      |        2. 铸造代币到 ATA           |</span><br><span class="line">  |                                      |&lt;---------- 返回成功 ---------------|</span><br><span class="line">  |&lt;--------- 交易确认 ------------------|                                    |</span><br></pre></td></tr></table></figure><h2 id="5-核心知识点"><a href="#5-核心知识点" class="headerlink" title="5. 核心知识点"></a>5. 核心知识点</h2><h3 id="5-1-CPI（跨程序调用）"><a href="#5-1-CPI（跨程序调用）" class="headerlink" title="5.1 CPI（跨程序调用）"></a>5.1 CPI（跨程序调用）</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(&amp;instruction, &amp;accounts)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 PDA 签名调用</span></span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(&amp;instruction, &amp;accounts, &amp;[&amp;seeds])?;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><table><thead><tr><th>调用方式</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td><code>invoke</code></td><td>调用其他程序的公开功能</td><td>调用 System Program 创建账户</td></tr><tr><td><code>invoke_signed</code></td><td>程序代表 PDA 签名</td><td>PDA 作为铸币权限</td></tr></tbody></table><h3 id="5-2-账户所有权模型"><a href="#5-2-账户所有权模型" class="headerlink" title="5.2 账户所有权模型"></a>5.2 账户所有权模型</h3><table><thead><tr><th>账户类型</th><th>所有者</th><th>可修改数据</th></tr></thead><tbody><tr><td>Mint Account</td><td>SPL Token Program</td><td>SPL Token Program</td></tr><tr><td>Token Account</td><td>SPL Token Program</td><td>SPL Token Program</td></tr><tr><td>Wallet</td><td>System Program</td><td>System Program</td></tr><tr><td>PDA</td><td>自定义程序</td><td>自定义程序</td></tr></tbody></table><p><strong>核心原则：</strong> 只有账户的所有者程序才能修改账户数据</p><h3 id="5-3-交易签名规则"><a href="#5-3-交易签名规则" class="headerlink" title="5.3 交易签名规则"></a>5.3 交易签名规则</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;[payer, mint_account]</span><br></pre></td></tr></table></figure><p><strong>签名者列表规则：</strong></p><ul><li>所有标记为 <code>is_signer: true</code> 的账户都需要签名</li><li>手续费支付者（payer）必须签名</li><li>新创建的账户必须签名授权</li></ul><h3 id="5-4-Decimals-设计原则"><a href="#5-4-Decimals-设计原则" class="headerlink" title="5.4 Decimals 设计原则"></a>5.4 Decimals 设计原则</h3><table><thead><tr><th>代币类型</th><th>decimals</th><th>示例</th><th>1 代币 &#x3D; ? 基础单位</th></tr></thead><tbody><tr><td>稳定币</td><td>6</td><td>USDC, USDT</td><td>1,000,000</td></tr><tr><td>治理代币</td><td>9</td><td>SOL</td><td>1,000,000,000</td></tr><tr><td>NFT</td><td>0</td><td>不可分割</td><td>1</td></tr></tbody></table><h2 id="6-实战技巧"><a href="#6-实战技巧" class="headerlink" title="6. 实战技巧"></a>6. 实战技巧</h2><h3 id="6-1-调试日志"><a href="#6-1-调试日志" class="headerlink" title="6.1 调试日志"></a>6.1 调试日志</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;Creating mint account...&quot;</span>);</span><br><span class="line">msg!(<span class="string">&quot;Mint: &#123;&#125;&quot;</span>, mint_account.key);</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana logs</span><br></pre></td></tr></table></figure><h3 id="6-2-账户大小计算"><a href="#6-2-账户大小计算" class="headerlink" title="6.2 账户大小计算"></a>6.2 账户大小计算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mint 账户：82 字节</span></span><br><span class="line"><span class="comment">// Token 账户：165 字节</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent</span> = Rent::<span class="title function_ invoke__">get</span>()?.<span class="title function_ invoke__">minimum_balance</span>(size);</span><br></pre></td></tr></table></figure><h3 id="6-3-权限管理最佳实践"><a href="#6-3-权限管理最佳实践" class="headerlink" title="6.3 权限管理最佳实践"></a>6.3 权限管理最佳实践</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时设置 mint_authority</span></span><br><span class="line"><span class="title function_ invoke__">initialize_mint</span>(..., &amp;mint_authority.key, <span class="literal">None</span>, decimals)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 铸造完成后可撤销权限（不可逆）</span></span><br><span class="line"><span class="title function_ invoke__">set_authority</span>(..., <span class="literal">None</span>, AuthorityType::MintTokens)?;</span><br></pre></td></tr></table></figure><h3 id="6-4-错误处理"><a href="#6-4-错误处理" class="headerlink" title="6.4 错误处理"></a>6.4 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">invoke</span>(...)?;  <span class="comment">// ? 操作符传播错误</span></span><br></pre></td></tr></table></figure><p><strong>常见错误：</strong></p><table><thead><tr><th>错误类型</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td><code>AccountNotFound</code></td><td>账户不存在</td><td>检查账户地址是否正确</td></tr><tr><td><code>InsufficientFunds</code></td><td>余额不足</td><td>确保账户有足够的 SOL</td></tr><tr><td><code>InvalidAccountData</code></td><td>数据格式错误</td><td>检查序列化&#x2F;反序列化逻辑</td></tr><tr><td><code>MissingRequiredSignature</code></td><td>缺少必要签名</td><td>检查签名者列表</td></tr></tbody></table><h2 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7. 常见问题"></a>7. 常见问题</h2><p><strong>Q1: 为什么需要租金？</strong></p><p>A: Solana 通过租金机制防止状态膨胀，账户需要保持最低余额。但这更像是押金，关闭账户时可以完全收回。</p><p><strong>Q2: ATA 地址会冲突吗？</strong></p><p>A: 不会冲突，ATA 通过 <code>[owner, mint]</code> 确定性生成，每个组合唯一。</p><p><strong>Q3: 可以修改 decimals 吗？</strong></p><p>A: 不可以，Mint 初始化后 decimals 不可更改。</p><p><strong>Q4: 如何转移铸币权限？</strong></p><p>A: 使用 <code>set_authority</code> 指令修改 mint_authority。</p><p><strong>Q5: 代币可以销毁吗？</strong></p><p>A: 可以，使用 <code>burn</code> 指令销毁持有的代币。</p><p><strong>Q6: 为什么要分两步创建账户？</strong></p><p>A: 遵循 Solana 的所有权模型。System Program 创建账户并分配空间，然后将所有权转给 Token Program，最后由 Token Program 初始化具体数据。</p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><ul><li><strong>账户是核心</strong>：Mint Account 和 Token Account 是 SPL Token 的基础</li><li><strong>所有权很重要</strong>：只有所有者程序可以修改账户数据</li><li><strong>CPI 是关键</strong>：通过跨程序调用实现功能组合</li><li><strong>ATA 简化管理</strong>：确定性地址生成简化代币账户管理</li><li><strong>租金是押金</strong>：不是真正的费用，关闭账户时可以收回</li><li><strong>程序和数据分离</strong>：遵循 Solana 的账户模型设计</li></ul><p><strong>Hooray！SPL Token 开发学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— Token 基础</title>
      <link href="/2025/10/03/solana-token-basic/"/>
      <url>/2025/10/03/solana-token-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Token？"><a href="#什么是-Token？" class="headerlink" title="什么是 Token？"></a>什么是 Token？</h2><p>在 Solana 区块链上，<strong>Token</strong> 是一种数字资产，用于表示价值或所有权。这些 Token 可以代表各种类型的资产，如货币、股权、积分、NFT（非同质化代币）等。</p><h3 id="Token-的分类"><a href="#Token-的分类" class="headerlink" title="Token 的分类"></a>Token 的分类</h3><ul><li><strong>同质化代币（Fungible Tokens）</strong>：代表同类型和同价值的可互换和可分割资产（例如 USDC）</li><li><strong>非同质化代币（Non-Fungible Tokens, NFTs）</strong>：代表不可分割资产的所有权（例如艺术品）</li></ul><h2 id="SPL-Solana-Program-Library"><a href="#SPL-Solana-Program-Library" class="headerlink" title="SPL (Solana Program Library)"></a>SPL (Solana Program Library)</h2><p><strong>SPL</strong> 是一组用于在 Solana 区块链上构建去中心化应用程序的智能合约库。SPL 提供了多种标准和工具，使开发者能够更容易地创建和管理代币。</p><p>SPL 的核心组件包括：</p><ul><li><strong>Token Program（代币程序）</strong>：包含与网络上的代币交互的所有指令逻辑</li><li><strong>Mint Account（铸币账户）</strong>：代表一种特定类型的代币，并存储关于代币的全局元数据，如总供应量和铸造权限</li><li><strong>Token Account（代币账户）</strong>：跟踪特定地址拥有的特定类型代币的单位数量</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-Token-Program（代币程序）"><a href="#1-Token-Program（代币程序）" class="headerlink" title="1. Token Program（代币程序）"></a>1. Token Program（代币程序）</h3><p>Token Program 是 SPL 中最核心的部分，包含与网络上代币交互的所有指令逻辑。</p><p><strong>主要功能：</strong></p><ul><li>创建代币及初始化代币账户</li><li>在不同账户之间转移代币</li><li>授权和撤销授权</li><li>查询代币余额</li></ul><h3 id="2-Mint-Account（铸币账户）"><a href="#2-Mint-Account（铸币账户）" class="headerlink" title="2. Mint Account（铸币账户）"></a>2. Mint Account（铸币账户）</h3><p>Mint Account 是每个 SPL Token 的核心账户，负责代币的定义和管理。它包含了代币的全局属性，比如总供应量和小数位数。每个代币都由一个独立的 Mint Account 来表示。</p><p><strong>主要属性：</strong></p><ul><li><strong>Decimals（小数位数）</strong>：定义代币的最小单位，常见取值是 6 或 9</li><li><strong>Supply（供应量）</strong>：代币的当前总供应量</li><li><strong>Mint Authority（铸币权限）</strong>：有权创建新代币单位的账户地址</li><li><strong>Freeze Authority（冻结权限）</strong>：可以冻结或解冻代币账户的权限</li></ul><p><strong>主要功能：</strong></p><ul><li><strong>铸造代币</strong>：增加总供应量并分配给指定的 Token Account</li><li><strong>销毁代币</strong>：减少总供应量</li></ul><h4 id="创建-Mint-Account"><a href="#创建-Mint-Account" class="headerlink" title="创建 Mint Account"></a>创建 Mint Account</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-token</span><br><span class="line">Creating token 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F under program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line"></span><br><span class="line">Address:  75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">Decimals:  9</span><br><span class="line"></span><br><span class="line">Signature: 3R71oyLWt2MKi3EUHttpJg7XnWxyYHheBF7vShkc2n6aQhLn1GWCEzqjqvqARFKVCQqucm3sGxoXum4k1BWf413a</span><br></pre></td></tr></table></figure><h4 id="查看-Mint-Account-信息"><a href="#查看-Mint-Account-信息" class="headerlink" title="查看 Mint Account 信息"></a>查看 Mint Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line"></span><br><span class="line">SPL Token Mint</span><br><span class="line">  Address: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Supply: 0</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint authority: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  Freeze authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="3-Token-Account（代币账户）"><a href="#3-Token-Account（代币账户）" class="headerlink" title="3. Token Account（代币账户）"></a>3. Token Account（代币账户）</h3><p>Token Account 用于持有特定 SPL Token 的账户。每个用户或合约如果想要持有某种 SPL Token，必须有一个与该 Token 对应的 Token Account。每个 Token Account 只能对应一个特定的 Mint（代币类型），所以如果用户要持有多种代币，就需要为每种代币分别创建一个 Token Account</p><p><strong>主要属性：</strong></p><ul><li><strong>Balance（余额）</strong>：账户中持有的代币数量</li><li><strong>Owner（账户拥有者）</strong>：控制该账户的用户或合约地址</li><li><strong>Mint（关联铸币账户）</strong>：该账户与哪个 Mint Account 相关联</li><li><strong>Delegation（代理账户）</strong>：被授权可以代表账户所有者转移代币的地址</li><li><strong>State（状态）</strong>：账户是否处于冻结状态</li></ul><p><strong>主要功能：</strong></p><ul><li>接收和发送代币</li><li>代理权限管理：可以设置 Delegation 来授权第三方管理该账户的代币</li></ul><h4 id="创建-Token-Account"><a href="#创建-Token-Account" class="headerlink" title="创建 Token Account"></a>创建 Token Account</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-account 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F /home/sol/.config/solana/wallet2.json</span><br><span class="line">Creating account 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">Signature: 3p6FztvPYgfzR2eBsKEFunTszbvsQgycXgwn8wNe1rBDdzDtP3jp4Z7XWgL91FbXTPGssy9bNdEiVPCqmkdHZX82</span><br></pre></td></tr></table></figure><h4 id="查看-Token-Account-信息"><a href="#查看-Token-Account-信息" class="headerlink" title="查看 Token Account 信息"></a>查看 Token Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">SPL Token Account</span><br><span class="line">  Address: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz  (Aux*)</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Balance: 100</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Owner: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  State: Initialized</span><br><span class="line">  Delegation: (not <span class="built_in">set</span>)</span><br><span class="line">  Close authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Associated-Token-Account（关联代币账户，ATA）"><a href="#4-Associated-Token-Account（关联代币账户，ATA）" class="headerlink" title="4. Associated Token Account（关联代币账户，ATA）"></a>4. Associated Token Account（关联代币账户，ATA）</h3><p>ATA 是一种由钱包地址和 Mint 通过特定规则派生出的标准化 Token Account 地址，每个钱包和某个代币的 Mint 至多对应一个 ATA。</p><p><strong>特点：</strong></p><ul><li><strong>唯一性</strong>：每个钱包地址只能有一个和某个 Mint 关联的 ATA</li><li><strong>自动生成</strong>：Solana 提供了工具来自动生成 ATA，开发者不需要手动管理账户</li><li><strong>简化管理</strong>：自动处理钱包地址与代币账户之间的关联</li></ul><h4 id="创建-ATA"><a href="#创建-ATA" class="headerlink" title="创建 ATA"></a>创建 ATA</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-account 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">Creating account DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">Signature: 388vYjLh9HVNYNeWcsa44zvdWgALHVTXC3dqHJbntpJN5P41Poj6G9zGHPPz2q1fysFAxRqPWKww2NUZKVwasoE6</span><br></pre></td></tr></table></figure><h4 id="查看-Associated-Token-Account-信息"><a href="#查看-Associated-Token-Account-信息" class="headerlink" title="查看 Associated Token Account 信息"></a>查看 Associated Token Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">SPL Token Account</span><br><span class="line">  Address: DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Balance: 100</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Owner: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  State: Initialized</span><br><span class="line">  Delegation: (not <span class="built_in">set</span>)</span><br><span class="line">  Close authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h2 id="铸造代币操作"><a href="#铸造代币操作" class="headerlink" title="铸造代币操作"></a>铸造代币操作</h2><h3 id="铸造到-ATA-账户"><a href="#铸造到-ATA-账户" class="headerlink" title="铸造到 ATA 账户"></a>铸造到 ATA 账户</h3><p>Mint Account 会自动关联到当前钱包的 ATA 账户，无需指定接收账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token mint 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F 100</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Recipient: DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">Signature: 32wtkcw2Xjv1Y1rADNuzCDPE6XtJhRTk3oxusPXMFRqKX6WhaU6PNZE3i3Uj6hDcYkfLvarFbki1HoQFHyqP6Wfk</span><br></pre></td></tr></table></figure><h3 id="铸造到指定-Token-Account"><a href="#铸造到指定-Token-Account" class="headerlink" title="铸造到指定 Token Account"></a>铸造到指定 Token Account</h3><p>给普通 Token Account 铸造时，需要通过 <code>--</code> 指定目标账户地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token mint 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F 100  -- 65bUqQKj4Axew8Z7KpXGodFowdXb</span><br><span class="line">WBE4ne8ocUZMoKmz</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Recipient: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">Signature: 5BWCTCSo2BxqkKWQwsgY7KRr3d1an2KGw4taa2Nao45jnE1sDfsA9EpgwYmTxoLBUp2x5pStJxp7JhKGZas3hbLM</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Solana 的 Token 系统通过 SPL Token Program 提供了完整的代币管理功能。理解以下三个核心概念是使用 Solana 代币的基础：</p><ol><li><strong>Mint Account（铸币账户）</strong>：定义代币类型和全局属性，如供应量、小数位数、铸币权限等</li><li><strong>Token Account（代币账户）</strong>：持有特定代币的账户，记录余额和所有权</li><li><strong>Associated Token Account（关联代币账户）</strong>：标准化的代币账户，自动与钱包地址绑定，每个钱包和某个 Mint 仅对应一个 ATA</li></ol><p>这套系统支持创建各种类型的数字资产，从可替代代币（如 USDC）到不可替代代币（NFT），为 Solana 生态系统提供了强大而灵活的基础设施。</p><p><strong>Hooray！Solana Token 基础完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— 账户模型与简单交互</title>
      <link href="/2025/10/02/solana-account-model/"/>
      <url>/2025/10/02/solana-account-model/</url>
      
        <content type="html"><![CDATA[<p>在 Solana 中，所有数据都存储在称为”账户”（Accounts）的结构中。可以将 Solana 上的数据视为一个公共数据库，其中有一个名为”Accounts”的表，表中的每一条记录就是一个”账户”。</p><h2 id="1-核心要点"><a href="#1-核心要点" class="headerlink" title="1. 核心要点"></a>1. 核心要点</h2><ul><li><strong>存储容量</strong>：账户最多可以存储 10MiB 的数据，可以是可执行的程序代码或程序状态</li><li><strong>租金押金</strong>：账户需要按比例缴纳租金押金（以 lamports 计，即 SOL 的最小单位），押金金额与存储的数据量成正比，<strong>关闭账户时可以完全收回</strong></li><li><strong>所有权机制</strong>：每个账户都有一个程序所有者。只有拥有该账户的程序才能修改其数据或扣除其 lamport 余额，但任何人都可以增加余额</li><li>特殊账户类型<ul><li>Sysvar 账户：存储网络集群状态的特殊账户</li><li>Program 账户：存储智能合约的可执行代码</li><li>Data 账户：由程序创建用于存储和管理程序状态</li></ul></li></ul><h2 id="2-账户结构"><a href="#2-账户结构" class="headerlink" title="2. 账户结构"></a>2. 账户结构</h2><h3 id="2-1-账户地址"><a href="#2-1-账户地址" class="headerlink" title="2.1 账户地址"></a>2.1 账户地址</h3><p>每个 Solana 账户都有一个唯一的 <strong>32 字节地址</strong>，通常显示为 base58 编码的字符串（例如：<code>14grJpemFaf88c8tiVb77W7TYg2W3ir6pfkKz3YjhhZ5</code>）。</p><p>账户与其地址之间的关系类似于键值对，其中地址是用于定位账户链上数据的键。账户地址充当”Accounts”表中每个条目的”唯一标识符”。</p><p><strong>地址生成方式：</strong></p><ol><li><strong>Ed25519 公钥地址</strong>（最常见）<ul><li>大多数 Solana 账户使用 Ed25519 公钥作为其地址</li></ul></li><li><strong>程序派生地址（PDA）</strong><ul><li>可以从程序 ID 和可选输入（种子）确定性地派生的特殊地址</li><li>PDA 是一种特殊的地址类型，不需要私钥就可以使用</li></ul></li></ol><h3 id="2-2-账户类型定义"><a href="#2-2-账户类型定义" class="headerlink" title="2.2 账户类型定义"></a>2.2 账户类型定义</h3><p>所有 Solana 账户都具有相同的基础结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> lamports: <span class="type">u64</span>,<span class="comment">// 账户中的 lamports 余额</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,<span class="comment">// 账户中存储的数据</span></span><br><span class="line">    <span class="keyword">pub</span> owner: Pubkey,<span class="comment">// 拥有此账户的程序。如果可执行，则为加载此账户的程序</span></span><br><span class="line">    <span class="keyword">pub</span> executable: <span class="type">bool</span>,<span class="comment">// 此账户的数据是否包含已加载的程序（现在为只读）</span></span><br><span class="line">    <span class="keyword">pub</span> rent_epoch: Epoch,<span class="comment">// 此账户下次需要支付租金的 epoch（已弃用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-字段详解"><a href="#2-3-字段详解" class="headerlink" title="2.3 字段详解"></a>2.3 字段详解</h3><h4 id="Lamports-字段"><a href="#Lamports-字段" class="headerlink" title="Lamports 字段"></a>Lamports 字段</h4><p>账户的余额（以 lamports 为单位，<strong>1 SOL &#x3D; 10 亿 lamports</strong>）。</p><p><strong>重要特性：</strong></p><ul><li>账户必须保持最低 lamport 余额，该余额与存储的数据量成正比（称为”租金”）</li><li>关闭账户时可以完全收回存储在账户中的 lamport 余额</li></ul><h4 id="Data-字段"><a href="#Data-字段" class="headerlink" title="Data 字段"></a>Data 字段</h4><p>存储账户任意数据的字节数组，也称为”账户数据”。</p><p><strong>不同账户类型的 data 内容：</strong></p><ul><li>对于程序账户：包含可执行程序代码本身或存储可执行代码的另一个账户的地址</li><li>对于非可执行账户：通常存储要读取的状态数据</li></ul><p><strong>读取账户数据的步骤：</strong></p><ol><li>使用地址（公钥）获取账户</li><li>将账户的 data 字段从原始字节反序列化为适当的数据结构（由拥有该账户的程序定义）</li></ol><h4 id="Owner-字段"><a href="#Owner-字段" class="headerlink" title="Owner 字段"></a>Owner 字段</h4><p>拥有此账户的程序 ID（公钥）。</p><p><strong>所有权规则：</strong></p><ul><li>只有所有者程序才能更改账户的数据或扣除其 lamports 余额</li><li>程序中定义的指令决定了账户的数据和 lamports 余额如何被更改</li></ul><h4 id="Executable-字段"><a href="#Executable-字段" class="headerlink" title="Executable 字段"></a>Executable 字段</h4><p>指示账户是否为可执行程序：</p><ul><li><code>true</code>：账户是可执行的 Solana 程序</li><li><code>false</code>：账户是存储状态的数据账户</li></ul><p>对于可执行账户，<code>owner</code> 字段包含加载器程序的程序 ID。加载器程序是负责加载和管理可执行程序账户的内置程序。</p><h4 id="Rent-Epoch-字段"><a href="#Rent-Epoch-字段" class="headerlink" title="Rent Epoch 字段"></a>Rent Epoch 字段</h4><p>**注意：**这是一个已弃用的遗留字段，不再使用。最初用于跟踪账户何时需要支付租金以维护其网络数据，此租金收取机制已被废弃。</p><h2 id="3-租金机制"><a href="#3-租金机制" class="headerlink" title="3. 租金机制"></a>3. 租金机制</h2><p>要在链上存储数据，账户必须保持与存储数据量（字节）成正比的 lamport（SOL）余额。这个余额称为”租金”，但它更像是<strong>押金</strong>，因为关闭账户时可以收回全部金额。</p><p><strong>注意：</strong> “租金”一词来自已弃用的机制，该机制会定期从低于租金阈值的账户中扣除 lamports。此机制已不再活跃。</p><h2 id="4-程序所有权"><a href="#4-程序所有权" class="headerlink" title="4. 程序所有权"></a>4. 程序所有权</h2><p>在 Solana 上，”智能合约”被称为”程序”。程序所有权是 Solana 账户模型的关键部分。</p><h3 id="4-1-所有者权限"><a href="#4-1-所有者权限" class="headerlink" title="4.1 所有者权限"></a>4.1 所有者权限</h3><p>只有所有者程序可以：</p><ul><li>更改账户的 <code>data</code> 字段</li><li>从账户余额中扣除 lamports</li></ul><p>每个程序定义存储在账户 <code>data</code> 字段中的数据结构。程序的指令决定了如何更改这些数据和账户的 <code>lamports</code> 余额。</p><h3 id="4-2-System-Program（系统程序）"><a href="#4-2-System-Program（系统程序）" class="headerlink" title="4.2 System Program（系统程序）"></a>4.2 System Program（系统程序）</h3><p>默认情况下，<strong>所有新账户都归 System Program 所有</strong>。</p><p><strong>System Program 的关键功能：</strong></p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>空间分配</td><td>为新账户分配存储空间</td></tr><tr><td>分配程序所有权</td><td>将账户所有权转移给其他程序</td></tr><tr><td>转账 SOL</td><td>在账户之间转移 lamports</td></tr></tbody></table><p><strong>System Account（系统账户）：</strong></p><ul><li>Solana 上的所有”钱包”账户都是由 System Program 拥有的”系统账户”</li><li>这些账户中的 lamport 余额显示钱包拥有的 SOL 数量</li><li><strong>只有系统账户可以支付交易费用</strong></li><li>当首次向新地址发送 SOL 时，会在该地址自动创建一个由 System Program 拥有的账户</li><li>新创建的系统账户的 owner 字段显示为 System Program 地址：<code>11111111111111111111111111111111</code></li></ul><h2 id="5-特殊账户类型"><a href="#5-特殊账户类型" class="headerlink" title="5. 特殊账户类型"></a>5. 特殊账户类型</h2><h3 id="5-1-Sysvar-Accounts（系统变量账户）"><a href="#5-1-Sysvar-Accounts（系统变量账户）" class="headerlink" title="5.1 Sysvar Accounts（系统变量账户）"></a>5.1 Sysvar Accounts（系统变量账户）</h3><p>Sysvar 账户是位于预定义地址的特殊账户，提供对集群状态数据的访问。这些账户会动态更新网络集群的相关数据。</p><p>例如，可以通过 Sysvar Clock 账户获取当前的集群时间信息，这些账户的数据可以被获取并反序列化为相应的数据结构。</p><h3 id="5-2-Program-Account（程序账户）"><a href="#5-2-Program-Account（程序账户）" class="headerlink" title="5.2 Program Account（程序账户）"></a>5.2 Program Account（程序账户）</h3><p>部署 Solana 程序会创建一个可执行的程序账户，用于存储程序的可执行代码。程序账户由加载器程序（Loader Program）拥有。</p><p><strong>关键特点：</strong></p><ul><li>程序账户可以简单地视为程序本身</li><li>调用程序的指令时，需要指定程序账户的地址（通常称为”Program ID”）</li><li>程序账户的 <code>executable</code> 字段设置为 <code>true</code></li></ul><p><strong>程序部署方式：</strong></p><ol><li><strong>Loader-v3 之前的版本</strong>：<ul><li>可执行代码直接存储在程序账户中</li></ul></li><li><strong>Loader-v3</strong>（当前默认）：<ul><li>可执行代码存储在单独的”程序数据账户”（Program Data Account）中</li><li>程序账户只是指向该数据账户</li><li>Solana CLI 默认使用最新的加载器版本</li></ul></li></ol><h3 id="5-3-Buffer-Account（缓冲区账户）"><a href="#5-3-Buffer-Account（缓冲区账户）" class="headerlink" title="5.3 Buffer Account（缓冲区账户）"></a>5.3 Buffer Account（缓冲区账户）</h3><p>Loader-v3 有一种特殊的账户类型，用于在部署或升级期间临时暂存程序的上传。在 Loader-v4 中，仍然有缓冲区，但它们只是普通的程序账户。</p><h3 id="5-4-Program-Data-Account（程序数据账户）"><a href="#5-4-Program-Data-Account（程序数据账户）" class="headerlink" title="5.4 Program Data Account（程序数据账户）"></a>5.4 Program Data Account（程序数据账户）</h3><p>Loader-v3 工作方式与其他 BPF 加载器程序不同：</p><ul><li>程序账户只包含程序数据账户的地址</li><li>程序数据账户存储实际的可执行代码</li></ul><p><strong>注意：</strong> 不要将程序数据账户与程序的数据账户（Data Account）混淆。</p><h3 id="5-5-Data-Account（数据账户）"><a href="#5-5-Data-Account（数据账户）" class="headerlink" title="5.5 Data Account（数据账户）"></a>5.5 Data Account（数据账户）</h3><p>在 Solana 上，程序的可执行代码与程序的状态存储在<strong>不同的账户</strong>中。这类似于操作系统通常为程序及其数据使用单独文件的方式。</p><p>为了维护状态，程序定义指令来创建它们拥有的独立账户。每个账户都有自己唯一的地址，可以存储程序定义的任意数据。</p><p><strong>重要提示：</strong> 只有 System Program 可以创建新账户。System Program 创建账户后，可以将新账户的所有权分配给另一个程序。</p><p><strong>创建数据账户的两步过程：</strong></p><ol><li><strong>调用 System Program</strong>：创建账户，然后将所有权转移给自定义程序</li><li><strong>调用自定义程序</strong>：初始化账户数据（按程序指令定义）</li></ol><p><strong>示例：创建 Token Mint 账户</strong></p><ul><li>首先调用 System Program 创建账户并分配空间</li><li>然后调用 Token Program 初始化 mint 账户的数据</li><li>需要计算租金豁免所需的最低余额</li><li>完成后账户由 Token Program 拥有并存储 mint 的相关数据</li></ul><h2 id="6-账户交互实战"><a href="#6-账户交互实战" class="headerlink" title="6. 账户交互实战"></a>6. 账户交互实战</h2><h3 id="6-1-环境准备"><a href="#6-1-环境准备" class="headerlink" title="6.1 环境准备"></a>6.1 环境准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动本地验证器</span></span><br><span class="line">solana-test-validator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到本地网络</span></span><br><span class="line">solana config <span class="built_in">set</span> -ul</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地钱包账户</span></span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet1.json</span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet2.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认钱包</span></span><br><span class="line">solana config <span class="built_in">set</span> --keypair ~/.config/solana/wallet1.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求空投</span></span><br><span class="line">solana airdrop 10</span><br></pre></td></tr></table></figure><h3 id="6-2-项目设置"><a href="#6-2-项目设置" class="headerlink" title="6.2 项目设置"></a>6.2 项目设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">cargo new account-interaction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加依赖库</span></span><br><span class="line">cargo add solana_client</span><br><span class="line">cargo add solana_sdk</span><br><span class="line">cargo add solana_program</span><br></pre></td></tr></table></figure><h3 id="6-3-请求空投与查询余额"><a href="#6-3-请求空投与查询余额" class="headerlink" title="6.3 请求空投与查询余额"></a>6.3 请求空投与查询余额</h3><p>通过这个示例，你可以学习如何：</p><ul><li>连接到 Solana 网络</li><li>请求空投到指定账户</li><li>查询账户余额</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wallet1: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span></span><br><span class="line"><span class="comment">// Wallet2: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建 Solana 客户端连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_url</span> = <span class="string">&quot;http://127.0.0.1:8899&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = RpcClient::<span class="title function_ invoke__">new</span>(rpc_url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户公钥</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_pubkey</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid public key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 SOL = 10 亿 lamports</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amount</span> = <span class="number">1_000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求空投</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">request_airdrop</span>(&amp;account_pubkey, amount) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(signature) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;空投成功! 签名: &#123;&#125;&quot;</span>, signature),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;空投失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询账户余额</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;account_pubkey) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;账户余额: &#123;&#125; lamports&quot;</span>, balance);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;账户余额: &#123;&#125; SOL&quot;</span>, balance <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1_000_000_000.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;获取余额失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-转账交易"><a href="#6-4-转账交易" class="headerlink" title="6.4 转账交易"></a>6.4 转账交易</h3><p>这个示例演示了 Solana 账户之间的转账流程：</p><ul><li>加载发送方密钥对</li><li>创建转账指令</li><li>构建、签名并发送交易</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::&#123;</span><br><span class="line">    pubkey::Pubkey,</span><br><span class="line">    signature::&#123;Signer, read_keypair_file&#125;,</span><br><span class="line">    system_instruction,</span><br><span class="line">    transaction::Transaction,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wallet1: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span></span><br><span class="line"><span class="comment">// Wallet2: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建 Solana 客户端连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_url</span> = <span class="string">&quot;http://127.0.0.1:8899&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = RpcClient::<span class="title function_ invoke__">new</span>(rpc_url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载发送方密钥对</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> =</span><br><span class="line">        <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/home/sol/.config/solana/wallet1.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取密钥文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收方公钥</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver_pubkey</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid public key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账金额：1 SOL</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amount</span> = <span class="number">1_000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建转账指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transfer_instruction</span> =</span><br><span class="line">        system_instruction::<span class="title function_ invoke__">transfer</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>(), &amp;receiver_pubkey, amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最新区块哈希</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">recent_blockhash</span> = client.<span class="title function_ invoke__">get_latest_blockhash</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法获取最新区块哈希&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并签名交易</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transaction</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[transfer_instruction],</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">        &amp;[&amp;sender],</span><br><span class="line">        recent_blockhash,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送并确认交易</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;transaction) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(signature) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;转账成功! 签名: &#123;&#125;&quot;</span>, signature),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;转账失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询接收方余额</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;receiver_pubkey) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;接收方账户余额: &#123;&#125; lamports&quot;</span>, balance);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;接收方账户余额: &#123;&#125; SOL&quot;</span>, balance <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1_000_000_000.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;获取余额失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ol><li><strong>账户是 Solana 的基础存储单元</strong>：所有数据都存储在账户中</li><li><strong>账户具有统一的结构</strong>：所有账户共享相同的基础字段</li><li><strong>所有权是关键</strong>：只有所有者程序可以修改账户数据</li><li><strong>租金是可恢复的押金</strong>：不是真正的费用，关闭账户时可以收回</li><li><strong>程序和数据分离</strong>：可执行代码和状态数据存储在不同的账户中</li><li><strong>System Program 是账户的创建者</strong>：所有新账户都由 System Program 创建</li></ol><p><strong>Hooray！Solana 账户模型学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— 环境搭建与基础命令</title>
      <link href="/2025/10/01/solana-install-and-cli/"/>
      <url>/2025/10/01/solana-install-and-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    pkg-config \</span><br><span class="line">    libudev-dev llvm libclang-dev \</span><br><span class="line">    protobuf-compiler libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Solana 开发组件</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSfL https://solana-install.solana.workers.dev | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">rustc --version &amp;&amp; solana --version &amp;&amp; anchor --version &amp;&amp; node --version &amp;&amp; yarn --version</span><br></pre></td></tr></table></figure><h2 id="2-Solana-CLI-基础"><a href="#2-Solana-CLI-基础" class="headerlink" title="2. Solana CLI 基础"></a>2. Solana CLI 基础</h2><h3 id="2-1-网络配置"><a href="#2-1-网络配置" class="headerlink" title="2.1 网络配置"></a>2.1 网络配置</h3><h4 id="查看当前配置"><a href="#查看当前配置" class="headerlink" title="查看当前配置"></a>查看当前配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br></pre></td></tr></table></figure><h4 id="切换网络"><a href="#切换网络" class="headerlink" title="切换网络"></a>切换网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana config <span class="built_in">set</span> --url mainnet-beta    <span class="comment"># 主网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url devnet          <span class="comment"># 开发网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url testnet         <span class="comment"># 测试网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url localhost       <span class="comment"># 本地网络</span></span><br></pre></td></tr></table></figure><h3 id="2-2-钱包管理"><a href="#2-2-钱包管理" class="headerlink" title="2.2 钱包管理"></a>2.2 钱包管理</h3><h4 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成新钱包（保存到默认路径）</span></span><br><span class="line">solana-keygen new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成新钱包到指定路径</span></span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从助记词恢复钱包</span></span><br><span class="line">solana-keygen recover --outfile ~/.config/solana/wallet.json --force</span><br></pre></td></tr></table></figure><h4 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置默认钱包</span></span><br><span class="line">solana config <span class="built_in">set</span> --keypair ~/.config/solana/wallet.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前钱包地址</span></span><br><span class="line">solana address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看钱包公钥</span></span><br><span class="line">solana-keygen pubkey ~/.config/solana/wallet.json</span><br></pre></td></tr></table></figure><h3 id="2-3-账户操作"><a href="#2-3-账户操作" class="headerlink" title="2.3 账户操作"></a>2.3 账户操作</h3><h4 id="余额和转账"><a href="#余额和转账" class="headerlink" title="余额和转账"></a>余额和转账</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看余额</span></span><br><span class="line">solana balance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定地址余额</span></span><br><span class="line">solana balance &lt;ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求测试币（仅限 devnet/testnet）</span></span><br><span class="line">solana airdrop 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转账 SOL</span></span><br><span class="line">solana transfer &lt;RECIPIENT_ADDRESS&gt; &lt;AMOUNT&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带备注转账</span></span><br><span class="line">solana transfer &lt;RECIPIENT_ADDRESS&gt; &lt;AMOUNT&gt; --with-memo <span class="string">&quot;转账备注&quot;</span></span><br></pre></td></tr></table></figure><h4 id="账户信息查询"><a href="#账户信息查询" class="headerlink" title="账户信息查询"></a>账户信息查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看账户详细信息</span></span><br><span class="line">solana account &lt;ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账户数据（以 JSON 格式）</span></span><br><span class="line">solana account &lt;ADDRESS&gt; --output json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账户租金状态</span></span><br><span class="line">solana rent 16<span class="comment"># Output: Rent-exempt minimum: 0.00100224 SOL</span></span><br><span class="line">                        <span class="comment"># 表示一个 16 字节大小的账户需要至少 0.00100224 SOL 的余额才能成为租金豁免账户</span></span><br></pre></td></tr></table></figure><h3 id="2-4-交易和日志"><a href="#2-4-交易和日志" class="headerlink" title="2.4 交易和日志"></a>2.4 交易和日志</h3><h4 id="交易操作"><a href="#交易操作" class="headerlink" title="交易操作"></a>交易操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看交易详情</span></span><br><span class="line">solana transaction &lt;SIGNATURE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认交易状态</span></span><br><span class="line">solana confirm &lt;SIGNATURE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最近交易</span></span><br><span class="line">solana transaction-history &lt;ADDRESS&gt; --<span class="built_in">limit</span> 10</span><br></pre></td></tr></table></figure><h4 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时查看程序日志</span></span><br><span class="line">solana logs &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有交易日志</span></span><br><span class="line">solana logs --all</span><br></pre></td></tr></table></figure><h3 id="2-5-网络和验证节点"><a href="#2-5-网络和验证节点" class="headerlink" title="2.5 网络和验证节点"></a>2.5 网络和验证节点</h3><h4 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群版本</span></span><br><span class="line">solana cluster-version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络状态</span></span><br><span class="line">solana cluster-date</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看区块产出情况</span></span><br><span class="line">solana block-production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看区块高度</span></span><br><span class="line">solana block-height</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看验证节点列表</span></span><br><span class="line">solana validators</span><br></pre></td></tr></table></figure><h3 id="2-6-本地测试链"><a href="#2-6-本地测试链" class="headerlink" title="2.6 本地测试链"></a>2.6 本地测试链</h3><h4 id="启动和管理"><a href="#启动和管理" class="headerlink" title="启动和管理"></a>启动和管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动本地验证节点</span></span><br><span class="line">solana-test-validator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">solana-test-validator --detach</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置本地链数据</span></span><br><span class="line">solana-test-validator --reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口</span></span><br><span class="line">solana-test-validator --rpc-port 8899 --ws-port 8900</span><br></pre></td></tr></table></figure><h4 id="预加载程序和账户"><a href="#预加载程序和账户" class="headerlink" title="预加载程序和账户"></a>预加载程序和账户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆主网账户到本地</span></span><br><span class="line">solana-test-validator --<span class="built_in">clone</span> &lt;ACCOUNT_ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载程序</span></span><br><span class="line">solana-test-validator --bpf-program &lt;PROGRAM_ID&gt; &lt;PROGRAM_PATH&gt;</span><br></pre></td></tr></table></figure><h3 id="2-7-智能合约操作"><a href="#2-7-智能合约操作" class="headerlink" title="2.7 智能合约操作"></a>2.7 智能合约操作</h3><h4 id="程序部署"><a href="#程序部署" class="headerlink" title="程序部署"></a>程序部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署程序</span></span><br><span class="line">solana program deploy &lt;PROGRAM_FILE.so&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到指定程序 ID</span></span><br><span class="line">solana program deploy &lt;PROGRAM_FILE.so&gt; --program-id &lt;PROGRAM_KEYPAIR&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级程序</span></span><br><span class="line">solana program deploy &lt;NEW_PROGRAM_FILE.so&gt; --program-id &lt;EXISTING_PROGRAM_ID&gt;</span><br></pre></td></tr></table></figure><h4 id="程序管理"><a href="#程序管理" class="headerlink" title="程序管理"></a>程序管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看程序信息</span></span><br><span class="line">solana program show &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出程序</span></span><br><span class="line">solana program dump &lt;PROGRAM_ID&gt; &lt;OUTPUT_FILE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭程序（回收租金）</span></span><br><span class="line">solana program close &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置程序升级权限</span></span><br><span class="line">solana program set-upgrade-authority &lt;PROGRAM_ID&gt; --new-upgrade-authority &lt;NEW_AUTHORITY&gt;</span><br></pre></td></tr></table></figure><h2 id="3-Anchor-基础"><a href="#3-Anchor-基础" class="headerlink" title="3. Anchor 基础"></a>3. Anchor 基础</h2><h3 id="3-1-项目管理"><a href="#3-1-项目管理" class="headerlink" title="3.1 项目管理"></a>3.1 项目管理</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">anchor init &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模板创建: 创建一个包含多个程序的 Anchor 项目结构</span></span><br><span class="line">anchor init &lt;project-name&gt; --template multiple</span><br></pre></td></tr></table></figure><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project-name/</span><br><span class="line">├── Anchor.toml        # Anchor 项目配置文件，包含程序 ID、网络配置、项目名称等</span><br><span class="line">├── Cargo.toml         # Rust 项目依赖配置文件，用于智能合约编译</span><br><span class="line">├── app                # 前端应用目录，存放与 Solana 交互的前端代码</span><br><span class="line">├── migrations         # 部署脚本目录</span><br><span class="line">│   └── deploy.ts      # 部署合约到指定网络的 TypeScript 脚本</span><br><span class="line">├── package.json       # JavaScript/TypeScript 项目依赖和脚本配置</span><br><span class="line">├── programs           # 智能合约代码目录</span><br><span class="line">│   └── firewords      # 具体智能合约子目录</span><br><span class="line">├── target             # Rust 编译输出目录</span><br><span class="line">│   └── deploy         # 编译后的程序文件，用于部署</span><br><span class="line">├── tests              # 测试文件目录</span><br><span class="line">│   └── firewords.ts   # 针对 firewords 合约的测试脚本</span><br><span class="line">├── tsconfig.json      # TypeScript 编译配置</span><br><span class="line">└── yarn.lock          # 锁定 JavaScript/TypeScript 依赖版本，确保一致性</span><br></pre></td></tr></table></figure><h3 id="3-2-开发流程"><a href="#3-2-开发流程" class="headerlink" title="3.2 开发流程"></a>3.2 开发流程</h3><h4 id="编译、部署和测试"><a href="#编译、部署和测试" class="headerlink" title="编译、部署和测试"></a>编译、部署和测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译项目</span></span><br><span class="line">anchor build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到当前网络</span></span><br><span class="line">anchor deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">anchor <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试（跳过构建）</span></span><br><span class="line">anchor <span class="built_in">test</span> --skip-build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行特定测试</span></span><br><span class="line">anchor <span class="built_in">test</span> --grep <span class="string">&quot;test_name&quot;</span></span><br></pre></td></tr></table></figure><h4 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成程序密钥对</span></span><br><span class="line">anchor keys list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步程序 ID</span></span><br><span class="line">anchor keys <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p><strong>Hooray！Solana 开发环境准备就绪！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 生命周期</title>
      <link href="/2025/09/30/rust-lifetimes/"/>
      <url>/2025/09/30/rust-lifetimes/</url>
      
        <content type="html"><![CDATA[<p>生命周期（Lifetime）是 Rust 中确保引用有效性的机制。每个引用都有生命周期，即引用保持有效的作用域。大多数情况下生命周期是隐式推断的，但在某些情况下需要显式标注。</p><h2 id="1-生命周期的作用"><a href="#1-生命周期的作用" class="headerlink" title="1. 生命周期的作用"></a>1. 生命周期的作用</h2><h3 id="1-1-防止悬垂引用"><a href="#1-1-防止悬垂引用" class="headerlink" title="1.1 防止悬垂引用"></a>1.1 防止悬垂引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;  <span class="comment">// ❌ 错误：x 的生命周期太短</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会阻止这段代码，因为 <code>x</code> 在使用 <code>r</code> 之前就被销毁了。</p><h3 id="1-2-借用检查器"><a href="#1-2-借用检查器" class="headerlink" title="1.2 借用检查器"></a>1.2 借用检查器</h3><p>Rust 的借用检查器比较引用的生命周期，确保所有引用都是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// --------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//         |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;b|</span></span><br><span class="line">                          <span class="comment">//   |     |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |     |</span></span><br><span class="line">                          <span class="comment">// --+     |</span></span><br><span class="line">&#125;                         <span class="comment">// --------+</span></span><br></pre></td></tr></table></figure><h2 id="2-函数中的生命周期标注"><a href="#2-函数中的生命周期标注" class="headerlink" title="2. 函数中的生命周期标注"></a>2. 函数中的生命周期标注</h2><h3 id="2-1-为什么需要标注"><a href="#2-1-为什么需要标注" class="headerlink" title="2.1 为什么需要标注"></a>2.1 为什么需要标注</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;  <span class="comment">// ❌ 缺少生命周期标注</span></span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器无法确定返回的引用是 <code>x</code> 还是 <code>y</code>，因此无法判断返回引用的生命周期。</p><h3 id="2-2-生命周期标注语法"><a href="#2-2-生命周期标注语法" class="headerlink" title="2.2 生命周期标注语法"></a>2.2 生命周期标注语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>生命周期参数名称：</p><ul><li>以 <code>&#39;</code> 开头</li><li>通常使用小写字母</li><li><code>&#39;a</code> 是最常用的名称</li></ul><h3 id="2-3-函数签名中的生命周期"><a href="#2-3-函数签名中的生命周期" class="headerlink" title="2.3 函数签名中的生命周期"></a>2.3 函数签名中的生命周期</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含义：</strong> 返回值的生命周期与参数中较短的生命周期相同。</p><h3 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);  <span class="comment">// ✅ 有效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);  <span class="comment">// ❌ 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结构体中的生命周期"><a href="#3-结构体中的生命周期" class="headerlink" title="3. 结构体中的生命周期"></a>3. 结构体中的生命周期</h2><h3 id="3-1-定义包含引用的结构体"><a href="#3-1-定义包含引用的结构体" class="headerlink" title="3.1 定义包含引用的结构体"></a>3.1 定义包含引用的结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含义：</strong> <code>ImportantExcerpt</code> 实例的生命周期不能超过 <code>part</code> 字段引用的数据。</p><h2 id="4-生命周期省略规则"><a href="#4-生命周期省略规则" class="headerlink" title="4. 生命周期省略规则"></a>4. 生命周期省略规则</h2><p>编译器使用三条规则自动推断生命周期：</p><ol><li><p><strong>每个引用参数都有自己的生命周期</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果只有一个输入生命周期，赋予所有输出生命周期</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果是方法且有多个输入生命周期，其中之一是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期赋予所有输出生命周期</strong></p></li></ol><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要标注</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要标注</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-方法中的生命周期"><a href="#5-方法中的生命周期" class="headerlink" title="5. 方法中的生命周期"></a>5. 方法中的生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-静态生命周期"><a href="#6-静态生命周期" class="headerlink" title="6. 静态生命周期"></a>6. 静态生命周期</h2><p><code>&#39;static</code> 表示引用在整个程序期间都有效：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong> 字符串字面量、全局变量。</p><p><strong>警告：</strong> 不要滥用 <code>&#39;static</code>，大多数情况下问题在于尝试创建悬垂引用。</p><h2 id="7-泛型、Trait-和生命周期结合"><a href="#7-泛型、Trait-和生命周期结合" class="headerlink" title="7. 泛型、Trait 和生命周期结合"></a>7. 泛型、Trait 和生命周期结合</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>生命周期标注</strong>：描述引用之间的关系，不改变实际生命周期</li><li><strong>借用检查器</strong>：确保所有引用在使用时都是有效的</li><li><strong>省略规则</strong>：大多数情况下编译器可以自动推断</li><li><strong>结构体生命周期</strong>：包含引用的结构体需要标注生命周期</li><li><strong>‘static</strong>：整个程序期间有效的引用</li></ul><p>生命周期是 Rust 确保内存安全的重要机制，虽然初学时可能感到困惑，但理解后能帮助我们编写更安全的代码。</p><p><strong>Hooray！生命周期学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 特征</title>
      <link href="/2025/09/29/rust-traits/"/>
      <url>/2025/09/29/rust-traits/</url>
      
        <content type="html"><![CDATA[<p>Trait 定义了类型可以共享的行为。可以使用 trait 以抽象的方式定义共享行为，使用 trait 约束指定泛型类型必须具有特定行为。</p><p><strong>注意：</strong> Trait 类似其他语言中的接口（interface），但有一些区别。</p><h2 id="1-定义-Trait"><a href="#1-定义-Trait" class="headerlink" title="1. 定义 Trait"></a>1. 定义 Trait</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trait 使用 <code>trait</code> 关键字定义，方法签名以分号结尾。</p><h3 id="1-2-多个方法"><a href="#1-2-多个方法" class="headerlink" title="1.2 多个方法"></a>1.2 多个方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-实现-Trait"><a href="#2-实现-Trait" class="headerlink" title="2. 实现 Trait"></a>2. 实现 Trait</h2><h3 id="2-1-为类型实现-trait"><a href="#2-1-为类型实现-trait" class="headerlink" title="2.1 为类型实现 trait"></a>2.1 为类型实现 trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-为另一个类型实现"><a href="#2-2-为另一个类型实现" class="headerlink" title="2.2 为另一个类型实现"></a>2.2 为另一个类型实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用-trait"><a href="#2-3-使用-trait" class="headerlink" title="2.3 使用 trait"></a>2.3 使用 trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-默认实现"><a href="#3-默认实现" class="headerlink" title="3. 默认实现"></a>3. 默认实现</h2><h3 id="3-1-提供默认行为"><a href="#3-1-提供默认行为" class="headerlink" title="3.1 提供默认行为"></a>3.1 提供默认行为</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用默认实现"><a href="#3-2-使用默认实现" class="headerlink" title="3.2 使用默认实现"></a>3.2 使用默认实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;  <span class="comment">// 使用默认实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best...&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New article: &#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>());  <span class="comment">// (Read more...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-默认实现调用其他方法"><a href="#3-3-默认实现调用其他方法" class="headerlink" title="3.3 默认实现调用其他方法"></a>3.3 默认实现调用其他方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Trait-作为参数"><a href="#4-Trait-作为参数" class="headerlink" title="4. Trait 作为参数"></a>4. Trait 作为参数</h2><h3 id="4-1-impl-Trait-语法"><a href="#4-1-impl-Trait-语法" class="headerlink" title="4.1 impl Trait 语法"></a>4.1 impl Trait 语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Trait-Bound-语法"><a href="#4-2-Trait-Bound-语法" class="headerlink" title="4.2 Trait Bound 语法"></a>4.2 Trait Bound 语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-多个-trait-约束"><a href="#4-3-多个-trait-约束" class="headerlink" title="4.3 多个 trait 约束"></a>4.3 多个 trait 约束</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用 trait bound</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-where-子句"><a href="#4-4-where-子句" class="headerlink" title="4.4 where 子句"></a>4.4 where 子句</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-返回实现-Trait-的类型"><a href="#5-返回实现-Trait-的类型" class="headerlink" title="5. 返回实现 Trait 的类型"></a>5. 返回实现 Trait 的类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong> 只能返回单一类型，不能根据条件返回不同类型。</p><h2 id="6-孤儿规则"><a href="#6-孤儿规则" class="headerlink" title="6. 孤儿规则"></a>6. 孤儿规则</h2><p>只有当 trait 或类型至少有一个是在当前 crate 中定义的，才能为该类型实现 trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 可以：Summary 在当前 crate 定义</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不行：Display 和 Vec 都在标准库中</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="7-使用-Trait-Bound-有条件地实现方法"><a href="#7-使用-Trait-Bound-有条件地实现方法" class="headerlink" title="7. 使用 Trait Bound 有条件地实现方法"></a>7. 使用 Trait Bound 有条件地实现方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Blanket-Implementations"><a href="#8-Blanket-Implementations" class="headerlink" title="8. Blanket Implementations"></a>8. Blanket Implementations</h2><p>为所有满足特定 trait bound 的类型实现 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// ToString 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着任何实现了 <code>Display</code> 的类型都自动实现了 <code>ToString</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>定义 trait</strong>：使用 <code>trait</code> 关键字定义共享行为</li><li><strong>实现 trait</strong>：使用 <code>impl Trait for Type</code> 语法</li><li><strong>默认实现</strong>：可以在 trait 中提供默认方法实现</li><li><strong>trait 参数</strong>：使用 <code>impl Trait</code> 或 trait bound 语法</li><li><strong>孤儿规则</strong>：保证 trait 实现的一致性</li></ul><p>Trait 是 Rust 实现多态和代码复用的核心机制，配合泛型可以编写灵活且类型安全的代码。</p><p><strong>Hooray！特征学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 泛型</title>
      <link href="/2025/09/28/rust-generic-types/"/>
      <url>/2025/09/28/rust-generic-types/</url>
      
        <content type="html"><![CDATA[<p>泛型允许我们用抽象的类型参数替代具体类型，从而编写可复用的代码。Rust 在编译时会进行<strong>单态化（Monomorphization）</strong>，将泛型代码转换为具体类型的代码，因此使用泛型不会带来运行时性能损失。</p><h2 id="1-泛型函数"><a href="#1-泛型函数" class="headerlink" title="1. 泛型函数"></a>1. 泛型函数</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码无法编译，因为 <code>T</code> 没有实现比较操作符。需要添加 trait 约束。</p><h3 id="1-2-带-trait-约束的泛型函数"><a href="#1-2-带-trait-约束的泛型函数" class="headerlink" title="1.2 带 trait 约束的泛型函数"></a>1.2 带 trait 约束的泛型函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-多个泛型参数"><a href="#1-3-多个泛型参数" class="headerlink" title="1.3 多个泛型参数"></a>1.3 多个泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_two_things</span>&lt;T, U&gt;(x: T, y: U) &#123;</span><br><span class="line">    <span class="comment">// 使用不同类型的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-泛型结构体"><a href="#2-泛型结构体" class="headerlink" title="2. 泛型结构体"></a>2. 泛型结构体</h2><h3 id="2-1-单一泛型参数"><a href="#2-1-单一泛型参数" class="headerlink" title="2.1 单一泛型参数"></a>2.1 单一泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>x</code> 和 <code>y</code> 必须是相同类型。</p><h3 id="2-2-多个泛型参数"><a href="#2-2-多个泛型参数" class="headerlink" title="2.2 多个泛型参数"></a>2.2 多个泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;  <span class="comment">// x 是 i32, y 是 f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-泛型枚举"><a href="#3-泛型枚举" class="headerlink" title="3. 泛型枚举"></a>3. 泛型枚举</h2><h3 id="3-1-Option-枚举"><a href="#3-1-Option-枚举" class="headerlink" title="3.1 Option 枚举"></a>3.1 Option 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Result-枚举"><a href="#3-2-Result-枚举" class="headerlink" title="3.2 Result 枚举"></a>3.2 Result 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个枚举是 Rust 标准库中最常用的泛型枚举。</p><h2 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h2><h3 id="4-1-为泛型结构体实现方法"><a href="#4-1-为泛型结构体实现方法" class="headerlink" title="4.1 为泛型结构体实现方法"></a>4.1 为泛型结构体实现方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 需要在 <code>impl</code> 后声明 <code>&lt;T&gt;</code>，表示为泛型类型 <code>Point&lt;T&gt;</code> 实现方法。</p><h3 id="4-2-为特定类型实现方法"><a href="#4-2-为特定类型实现方法" class="headerlink" title="4.2 为特定类型实现方法"></a>4.2 为特定类型实现方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只对 <code>Point&lt;f32&gt;</code> 有效。</p><h3 id="4-3-方法中的额外泛型参数"><a href="#4-3-方法中的额外泛型参数" class="headerlink" title="4.3 方法中的额外泛型参数"></a>4.3 方法中的额外泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);  <span class="comment">// 5, c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-泛型的性能"><a href="#5-泛型的性能" class="headerlink" title="5. 泛型的性能"></a>5. 泛型的性能</h2><p>Rust 使用<strong>单态化</strong>在编译时将泛型代码展开为具体类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p>编译后实际生成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong> 运行时零成本抽象，性能等同于手写具体类型。</p><p><strong>缺点：</strong> 会增加编译时间和二进制文件大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>泛型函数</strong>：使用 <code>&lt;T&gt;</code> 定义类型参数，提高代码复用性</li><li><strong>泛型结构体&#x2F;枚举</strong>：可以存储任意类型的数据</li><li><strong>泛型方法</strong>：在 <code>impl&lt;T&gt;</code> 中声明类型参数</li><li><strong>零成本抽象</strong>：编译时单态化，运行时无性能损失</li></ul><p>泛型是 Rust 中实现代码复用和抽象的重要工具，配合 trait 约束可以实现强大的类型安全保证。</p><p><strong>Hooray！泛型学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 错误处理</title>
      <link href="/2025/09/27/rust-error-handling/"/>
      <url>/2025/09/27/rust-error-handling/</url>
      
        <content type="html"><![CDATA[<p>Rust 将错误分为两大类：<strong>可恢复错误</strong>和<strong>不可恢复错误</strong>。可恢复错误用 <code>Result&lt;T, E&gt;</code> 处理，不可恢复错误用 <code>panic!</code> 宏处理。Rust 没有异常机制，强制你在编译时就考虑错误处理。</p><h2 id="1-panic-——-不可恢复错误"><a href="#1-panic-——-不可恢复错误" class="headerlink" title="1. panic! —— 不可恢复错误"></a>1. panic! —— 不可恢复错误</h2><h3 id="1-1-触发-panic"><a href="#1-1-触发-panic" class="headerlink" title="1.1 触发 panic"></a>1.1 触发 panic</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会打印错误信息、清理栈并退出。</p><h3 id="1-2-panic-时的栈展开"><a href="#1-2-panic-时的栈展开" class="headerlink" title="1.2 panic 时的栈展开"></a>1.2 panic 时的栈展开</h3><p>默认情况下，panic 会展开栈并清理数据。可以在 <code>Cargo.toml</code> 中配置直接终止：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-panic-回溯"><a href="#1-3-panic-回溯" class="headerlink" title="1.3 panic 回溯"></a>1.3 panic 回溯</h3><p>设置环境变量查看详细回溯信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure><h2 id="2-Result-——-可恢复错误"><a href="#2-Result-——-可恢复错误" class="headerlink" title="2. Result —— 可恢复错误"></a>2. Result —— 可恢复错误</h2><h3 id="2-1-Result-枚举"><a href="#2-1-Result-枚举" class="headerlink" title="2.1 Result 枚举"></a>2.1 Result 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用-match-处理"><a href="#2-2-使用-match-处理" class="headerlink" title="2.2 使用 match 处理"></a>2.2 使用 match 处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-匹配不同错误类型"><a href="#2-3-匹配不同错误类型" class="headerlink" title="2.3 匹配不同错误类型"></a>2.3 匹配不同错误类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;创建文件失败: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-使用闭包简化"><a href="#2-4-使用闭包简化" class="headerlink" title="2.4 使用闭包简化"></a>2.4 使用闭包简化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;创建文件失败: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-unwrap-和-expect"><a href="#3-unwrap-和-expect" class="headerlink" title="3. unwrap 和 expect"></a>3. unwrap 和 expect</h2><h3 id="3-1-unwrap"><a href="#3-1-unwrap" class="headerlink" title="3.1 unwrap"></a>3.1 unwrap</h3><p><code>unwrap</code> 是 <code>match</code> 的快捷方式，成功返回值，失败则 <code>panic</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-expect"><a href="#3-2-expect" class="headerlink" title="3.2 expect"></a>3.2 expect</h3><p><code>expect</code> 类似 <code>unwrap</code>，但可以自定义错误信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法打开 hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>推荐：</strong> 生产代码中优先使用 <code>expect</code>，提供清晰的上下文信息。</p><h2 id="4-传播错误"><a href="#4-传播错误" class="headerlink" title="4. 传播错误"></a>4. 传播错误</h2><h3 id="4-1-返回-Result"><a href="#4-1-返回-Result" class="headerlink" title="4.1 返回 Result"></a>4.1 返回 Result</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用-运算符"><a href="#4-2-使用-运算符" class="headerlink" title="4.2 使用 ? 运算符"></a>4.2 使用 ? 运算符</h3><p><code>?</code> 运算符是传播错误的简写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简洁版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-运算符用于-Option"><a href="#4-3-运算符用于-Option" class="headerlink" title="4.3 ? 运算符用于 Option"></a>4.3 ? 运算符用于 Option</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>?</code> 只能用在返回 <code>Result</code> 或 <code>Option</code> 的函数中。</p><h3 id="4-4-main-函数返回-Result"><a href="#4-4-main-函数返回-Result" class="headerlink" title="4.4 main 函数返回 Result"></a>4.4 main 函数返回 Result</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-何时使用-panic"><a href="#5-何时使用-panic" class="headerlink" title="5. 何时使用 panic!"></a>5. 何时使用 panic!</h2><h3 id="5-1-适合-panic-的场景"><a href="#5-1-适合-panic-的场景" class="headerlink" title="5.1 适合 panic 的场景"></a>5.1 适合 panic 的场景</h3><ul><li><strong>示例、原型代码</strong>：使用 <code>unwrap</code> 快速编写</li><li><strong>测试代码</strong>：测试失败应该 panic</li><li><strong>逻辑保证不会失败</strong>：编译器无法理解但你确定的情况</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;硬编码的 IP 地址应该有效&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-应该返回-Result-的场景"><a href="#5-2-应该返回-Result-的场景" class="headerlink" title="5.2 应该返回 Result 的场景"></a>5.2 应该返回 Result 的场景</h3><ul><li><strong>预期可能失败</strong>：如解析用户输入、网络请求</li><li><strong>调用者需要决定如何处理</strong>：错误处理策略由调用方决定</li></ul><h3 id="5-3-违反约定时-panic"><a href="#5-3-违反约定时-panic" class="headerlink" title="5.3 违反约定时 panic"></a>5.3 违反约定时 panic</h3><p>当代码接收到无效值时，应该 panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess 值必须在 1 到 100 之间，得到 &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-常用错误处理方法"><a href="#6-常用错误处理方法" class="headerlink" title="6. 常用错误处理方法"></a>6. 常用错误处理方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unwrap_or：提供默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unwrap_or_else：使用闭包计算默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or_else</span>(|_| <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unwrap_or_default：使用类型的默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or_default</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// and_then：链式操作</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">and_then</span>(|<span class="keyword">mut</span> file| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(contents)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>panic!</strong>：用于不可恢复的错误，程序无法继续执行</li><li><strong>Result&lt;T, E&gt;</strong>：用于可恢复的错误，允许调用者决定如何处理</li><li><strong>? 运算符</strong>：简化错误传播，使代码更简洁</li><li><strong>unwrap&#x2F;expect</strong>：快速原型开发，生产代码优先使用 <code>expect</code></li></ul><p>Rust 的错误处理系统强制你在编译时考虑错误情况，虽然初期可能觉得繁琐，但能显著提高代码的健壮性和可靠性。</p><p><strong>Hooray！错误处理学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 常见集合</title>
      <link href="/2025/09/26/rust-common-collections/"/>
      <url>/2025/09/26/rust-common-collections/</url>
      
        <content type="html"><![CDATA[<p>Rust 标准库包含了一些非常实用的数据结构，称为<strong>集合（Collections）</strong>。与普通数据类型不同，集合可以包含多个值，数据存储在<strong>堆</strong>上，大小可以在运行时动态变化。</p><p>本文介绍三种最常用的集合：<strong>Vector</strong>、<strong>String</strong> 和 <strong>HashMap</strong>。</p><h2 id="1-Vector（向量）"><a href="#1-Vector（向量）" class="headerlink" title="1. Vector（向量）"></a>1. Vector（向量）</h2><h3 id="1-1-创建和更新-Vector"><a href="#1-1-创建和更新-Vector" class="headerlink" title="1.1 创建和更新 Vector"></a>1.1 创建和更新 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空 Vector</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="1-2-读取元素"><a href="#1-2-读取元素" class="headerlink" title="1.2 读取元素"></a>1.2 读取元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：索引（越界会 panic）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：get 方法（返回 Option）</span></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有第三个元素&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-遍历-Vector"><a href="#1-3-遍历-Vector" class="headerlink" title="1.3 遍历 Vector"></a>1.3 遍历 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变遍历</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变遍历</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 不能在持有 Vector 元素的不可变引用时修改 Vector。</p><h3 id="1-4-存储多种类型"><a href="#1-4-存储多种类型" class="headerlink" title="1.4 存储多种类型"></a>1.4 存储多种类型</h3><p>使用枚举在 Vector 中存储不同类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="2-String（字符串）"><a href="#2-String（字符串）" class="headerlink" title="2. String（字符串）"></a>2. String（字符串）</h2><h3 id="2-1-创建-String"><a href="#2-1-创建-String" class="headerlink" title="2.1 创建 String"></a>2.1 创建 String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><h3 id="2-2-更新-String"><a href="#2-2-更新-String" class="headerlink" title="2.2 更新 String"></a>2.2 更新 String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);  <span class="comment">// 追加字符串</span></span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);        <span class="comment">// 追加字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-拼接字符串"><a href="#2-3-拼接字符串" class="headerlink" title="2.3 拼接字符串"></a>2.3 拼接字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 + 运算符（会移动 s1）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 format! 宏（推荐）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure><h3 id="2-4-索引字符串"><a href="#2-4-索引字符串" class="headerlink" title="2.4 索引字符串"></a>2.4 索引字符串</h3><p>Rust <strong>不支持</strong>直接索引字符串：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];  <span class="comment">// ❌ 错误！</span></span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 字符串是 UTF-8 编码，一个字符可能占用多个字节。</p><h3 id="2-5-遍历字符串"><a href="#2-5-遍历字符串" class="headerlink" title="2.5 遍历字符串"></a>2.5 遍历字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字节</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-HashMap（哈希映射）"><a href="#3-HashMap（哈希映射）" class="headerlink" title="3. HashMap（哈希映射）"></a>3. HashMap（哈希映射）</h2><h3 id="3-1-创建-HashMap"><a href="#3-1-创建-HashMap" class="headerlink" title="3.1 创建 HashMap"></a>3.1 创建 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>collect</code> 创建：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure><h3 id="3-2-访问值"><a href="#3-2-访问值" class="headerlink" title="3.2 访问值"></a>3.2 访问值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> scores.<span class="title function_ invoke__">get</span>(&amp;team_name) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;分数: &#123;&#125;&quot;</span>, s),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;队伍不存在&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-遍历-HashMap"><a href="#3-3-遍历-HashMap" class="headerlink" title="3.3 遍历 HashMap"></a>3.3 遍历 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> HashMap 是<strong>无序的</strong>。</p><h3 id="3-4-更新-HashMap"><a href="#3-4-更新-HashMap" class="headerlink" title="3.4 更新 HashMap"></a>3.4 更新 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆盖值</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在键不存在时插入</span></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于旧值更新</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-所有权"><a href="#3-5-所有权" class="headerlink" title="3.5 所有权"></a>3.5 所有权</h3><p>对于 <code>String</code> 等类型，插入 HashMap 后所有权会转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// field_name 和 field_value 在此处无效</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Vector</strong>：动态数组，适合存储同类型的列表数据</li><li><strong>String</strong>：UTF-8 编码的字符串，不支持索引但可遍历</li><li><strong>HashMap</strong>：键值对存储，提供快速查找能力</li></ul><p>掌握这三种集合的使用是编写 Rust 程序的基础。记住它们都存储在堆上，理解所有权规则对正确使用集合至关重要。</p><p><strong>Hooray！常见集合学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 枚举和模式匹配</title>
      <link href="/2025/09/25/rust-enums-and-pattern-matching/"/>
      <url>/2025/09/25/rust-enums-and-pattern-matching/</url>
      
        <content type="html"><![CDATA[<p>枚举（Enum）允许我们通过列举所有可能的变体来定义一个类型。与结构体类似，枚举也可以包含数据和方法，但更适合表示”多选一”的情况。</p><h2 id="1-定义和使用枚举"><a href="#1-定义和使用枚举" class="headerlink" title="1. 定义和使用枚举"></a>1. 定义和使用枚举</h2><h3 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a>1.1 基本定义</h3><p>使用 <code>enum</code> 关键字定义枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-枚举携带数据"><a href="#1-2-枚举携带数据" class="headerlink" title="1.2 枚举携带数据"></a>1.2 枚举携带数据</h3><p>枚举的每个变体可以关联不同类型和数量的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-多种数据形式"><a href="#1-3-多种数据形式" class="headerlink" title="1.3 多种数据形式"></a>1.3 多种数据形式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,                       <span class="comment">// 无关联数据</span></span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,   <span class="comment">// 具名字段</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),              <span class="comment">// 单个 String</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>), <span class="comment">// 三个 i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-枚举方法"><a href="#1-4-枚举方法" class="headerlink" title="1.4 枚举方法"></a>1.4 枚举方法</h3><p>可以使用 <code>impl</code> 为枚举定义方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Option-枚举"><a href="#2-Option-枚举" class="headerlink" title="2. Option 枚举"></a>2. Option 枚举</h2><p>Rust 没有空值（null），使用 <code>Option&lt;T&gt;</code> 表示值可能存在或不存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;文本&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 必须将 <code>Option&lt;T&gt;</code> 转换为 <code>T</code> 才能使用，这强制我们处理可能为空的情况。</p><h2 id="3-match-控制流"><a href="#3-match-控制流" class="headerlink" title="3. match 控制流"></a>3. match 控制流</h2><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-绑定值的模式"><a href="#3-2-绑定值的模式" class="headerlink" title="3.2 绑定值的模式"></a>3.2 绑定值的模式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-匹配-Option"><a href="#3-3-匹配-Option" class="headerlink" title="3.3 匹配 Option"></a>3.3 匹配 Option<T></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-穷尽性检查"><a href="#3-4-穷尽性检查" class="headerlink" title="3.4 穷尽性检查"></a>3.4 穷尽性检查</h3><p><strong>重要：</strong> match 必须覆盖所有可能的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译错误！缺少 None 分支</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符 _"></a>3.5 通配符 <code>_</code></h3><p>使用 <code>_</code> 匹配剩余所有情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>不执行任何操作时使用 <code>()</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-if-let-简洁控制流"><a href="#4-if-let-简洁控制流" class="headerlink" title="4. if let 简洁控制流"></a>4. if let 简洁控制流</h2><h3 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h3><p>当只关心一种匹配情况时，使用 <code>if let</code> 更简洁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 match</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;最大值: &#123;&#125;&quot;</span>, max),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 if let（更简洁）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;最大值: &#123;&#125;&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-配合-else-使用"><a href="#4-2-配合-else-使用" class="headerlink" title="4.2 配合 else 使用"></a>4.2 配合 else 使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-实战示例"><a href="#5-实战示例" class="headerlink" title="5. 实战示例"></a>5. 实战示例</h2><h3 id="5-1-消息处理"><a href="#5-1-消息处理" class="headerlink" title="5.1 消息处理"></a>5.1 消息处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello,</span><br><span class="line">    Goodbye,</span><br><span class="line">    <span class="title function_ invoke__">Body</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Wait</span>(<span class="type">String</span>, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_msg</span>(m: Message) &#123;</span><br><span class="line">    <span class="keyword">match</span> m &#123;</span><br><span class="line">        Message::Hello =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hi&quot;</span>),</span><br><span class="line">        Message::Goodbye =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Bye&quot;</span>),</span><br><span class="line">        Message::<span class="title function_ invoke__">Body</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">        Message::<span class="title function_ invoke__">Wait</span>(time, len) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;等待 &#123;&#125; &#123;&#125;&quot;</span>, len, time),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-状态机"><a href="#5-2-状态机" class="headerlink" title="5.2 状态机"></a>5.2 状态机</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    Idle,</span><br><span class="line">    Running,</span><br><span class="line">    Stopped,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">start</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">            State::Idle =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line">                <span class="keyword">self</span>.state = State::Running;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;无法启动&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举与模式匹配是 Rust 中最强大的特性之一。通过合理使用，我们可以：</p><ul><li><strong>类型安全</strong>：编译时确保处理所有可能情况</li><li><strong>表达力强</strong>：不同变体可以携带不同类型数据</li><li><strong>消除空指针</strong>：通过 <code>Option&lt;T&gt;</code> 安全处理空值</li><li><strong>代码清晰</strong>：match 让逻辑分支一目了然</li></ul><p>掌握枚举和模式匹配，为后续学习 Result 错误处理、trait 等高级特性打下基础。</p><p><strong>Hooray！枚举和模式匹配学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 结构体</title>
      <link href="/2025/09/24/rust-structs/"/>
      <url>/2025/09/24/rust-structs/</url>
      
        <content type="html"><![CDATA[<p>结构体（Struct）和元组类似，都可以包含不同类型的数据。但与元组不同的是，结构体中的每个字段都有命名，因此更加清晰、灵活。我们不需要依赖数据的顺序来访问值，而是通过字段名来访问。</p><h2 id="1-定义和实例化结构体"><a href="#1-定义和实例化结构体" class="headerlink" title="1. 定义和实例化结构体"></a>1. 定义和实例化结构体</h2><h3 id="1-1-定义结构体"><a href="#1-1-定义结构体" class="headerlink" title="1.1 定义结构体"></a>1.1 定义结构体</h3><p>使用 <code>struct</code> 关键字定义结构体，在花括号中列出字段名称和类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要让某些结构体或字段在模块外可见，需要加 <code>pub</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,    <span class="comment">// 公有字段，模块外可访问</span></span><br><span class="line">    email: <span class="type">String</span>,           <span class="comment">// 私有字段，只能在当前模块访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建实例"><a href="#1-2-创建实例" class="headerlink" title="1.2 创建实例"></a>1.2 创建实例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 字段初始化时顺序不需要与定义顺序一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),  <span class="comment">// 顺序可以不同</span></span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-可变结构体"><a href="#1-3-可变结构体" class="headerlink" title="1.3 可变结构体"></a>1.3 可变结构体</h3><p>实例默认是不可变的，若要修改字段，需加上 <code>mut</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">    user1.sign_in_count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-简化结构体初始化"><a href="#2-简化结构体初始化" class="headerlink" title="2. 简化结构体初始化"></a>2. 简化结构体初始化</h2><p>在函数中返回结构体时，当变量名与字段名相同，可以省略字段名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,        <span class="comment">// 等价于 username: username</span></span><br><span class="line">        email,           <span class="comment">// 等价于 email: email</span></span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-基于已有实例创建新实例"><a href="#3-基于已有实例创建新实例" class="headerlink" title="3. 基于已有实例创建新实例"></a>3. 基于已有实例创建新实例</h2><h3 id="3-1-普通写法"><a href="#3-1-普通写法" class="headerlink" title="3.1 普通写法"></a>3.1 普通写法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,     <span class="comment">// String 没有实现 Copy，所有权被移动</span></span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-结构体更新语法"><a href="#3-2-结构体更新语法" class="headerlink" title="3.2 结构体更新语法"></a>3.2 结构体更新语法</h3><p>Rust 提供了 <code>..</code> 语法来复用字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意：</strong></p><ul><li><code>..user1</code> 必须写在最后</li><li>由于 <code>username</code> 是 <code>String</code> 类型（没有实现 <code>Copy</code>），所有权被转移到 <code>user2</code></li><li>创建 <code>user2</code> 后，<code>user1</code> 不能再作为整体使用</li><li><code>user1.active</code> 和 <code>user1.sign_in_count</code> 仍可使用，因为它们实现了 <code>Copy</code> trait</li></ul><h3 id="3-3-所有权友好的更新语法示例"><a href="#3-3-所有权友好的更新语法示例" class="headerlink" title="3.3 所有权友好的更新语法示例"></a>3.3 所有权友好的更新语法示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,  <span class="comment">// i32 实现了 Copy</span></span><br><span class="line">    y: <span class="type">i32</span>,  <span class="comment">// i32 实现了 Copy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="number">3</span>, ..p1 &#125;;  <span class="comment">// p1 仍然可用，因为所有字段都实现了 Copy</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);  <span class="comment">// 正常工作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元组结构体（Tuple-Struct）"><a href="#4-元组结构体（Tuple-Struct）" class="headerlink" title="4. 元组结构体（Tuple Struct）"></a>4. 元组结构体（Tuple Struct）</h2><p>如果只关心字段类型而不关心字段名，可以使用<strong>元组结构体</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引访问</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;红色分量: &#123;&#125;&quot;</span>, black.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 坐标: &#123;&#125;&quot;</span>, origin.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 虽然 <code>Color</code> 和 <code>Point</code> 的字段类型相同，但它们是不同的结构体类型，不能互相赋值。</p><h2 id="5-单元结构体（Unit-like-Struct）"><a href="#5-单元结构体（Unit-like-Struct）" class="headerlink" title="5. 单元结构体（Unit-like Struct）"></a>5. 单元结构体（Unit-like Struct）</h2><p>当结构体不需要任何字段，只关心类型行为时，可以使用<strong>单元结构体</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元结构体常用于实现 trait，但不需要存储数据的场景。</p><h2 id="6-嵌套结构体（Structs-内含-Structs）"><a href="#6-嵌套结构体（Structs-内含-Structs）" class="headerlink" title="6. 嵌套结构体（Structs 内含 Structs）"></a>6. 嵌套结构体（Structs 内含 Structs）</h2><p>结构体字段本身可以是另一个结构体类型，这样可以构造更复杂的数据模型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    street: <span class="type">String</span>,</span><br><span class="line">    zip_code: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    address: Address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = User &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john@example.com&quot;</span>),</span><br><span class="line">        address: Address &#123;</span><br><span class="line">            city: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;北京&quot;</span>),</span><br><span class="line">            street: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;长安街1号&quot;</span>),</span><br><span class="line">            zip_code: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;100000&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户城市: &#123;&#125;&quot;</span>, user.address.city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-调试结构体"><a href="#7-调试结构体" class="headerlink" title="7. 调试结构体"></a>7. 调试结构体</h2><p>默认情况下，<code>println!</code> 不能直接打印结构体。可以通过 <code>#[derive(Debug)]</code> 启用调试格式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);        <span class="comment">// 单行输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:#?&#125;&quot;</span>, rect1);       <span class="comment">// 更美观的多行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用 <code>dbg!</code> 宏进行调试，<code>dbg!</code> 会打印源码位置和表达式值，并返回该值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),  <span class="comment">// 会打印计算过程</span></span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);  <span class="comment">// 会打印整个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-访问结构体字段"><a href="#8-访问结构体字段" class="headerlink" title="8. 访问结构体字段"></a>8. 访问结构体字段</h2><p>使用点号语法访问结构体字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字段</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户名: &#123;&#125;&quot;</span>, user1.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;邮箱: &#123;&#125;&quot;</span>, user1.email);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;活跃状态: &#123;&#125;&quot;</span>, user1.active);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改字段（需要 mut）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user2.active = <span class="literal">true</span>;</span><br><span class="line">    user2.sign_in_count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-方法与关联函数"><a href="#9-方法与关联函数" class="headerlink" title="9. 方法与关联函数"></a>9. 方法与关联函数</h2><h3 id="9-1-方法基础"><a href="#9-1-方法基础" class="headerlink" title="9.1 方法基础"></a>9.1 方法基础</h3><p><strong>方法（method）</strong> 与函数类似，但有以下特点：</p><ul><li>定义在 <code>impl</code> 块中</li><li>第一个参数必须是 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code></li><li>通过实例调用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;self: 借用实例，不获取所有权</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;mut self: 可变借用，可以修改实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_width</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, width: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self: 获取所有权，方法调用后实例不可再用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">destroy</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;销毁矩形 &#123;&#125;x&#123;&#125;&quot;</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带其他参数的方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;面积: &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    rect1.<span class="title function_ invoke__">set_width</span>(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 能容纳 rect2: &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-关联函数（Associated-Functions）"><a href="#9-2-关联函数（Associated-Functions）" class="headerlink" title="9.2 关联函数（Associated Functions）"></a>9.2 关联函数（Associated Functions）</h3><p>关联函数不以 <code>self</code> 作为第一个参数，通常用作构造器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数，通常用作构造器</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建正方形的便捷函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">new</span>(<span class="number">10</span>, <span class="number">20</span>);      <span class="comment">// 使用 :: 语法调用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-多个-impl-块"><a href="#9-3-多个-impl-块" class="headerlink" title="9.3 多个 impl 块"></a>9.3 多个 impl 块</h3><p>一个结构体可以有多个 <code>impl</code> 块，这在组织代码或条件编译时很有用。：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">perimeter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="number">2</span> * (<span class="keyword">self</span>.width + <span class="keyword">self</span>.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构体是 Rust 中组织相关数据的强大工具。通过合理使用结构体，我们可以：</p><ol><li><strong>清晰地组织数据</strong>：通过命名字段让代码更易读</li><li><strong>确保类型安全</strong>：不同的结构体是不同的类型</li><li><strong>封装行为</strong>：通过方法将数据和操作结合在一起</li><li><strong>利用所有权系统</strong>：确保内存安全和并发安全</li></ol><p>掌握结构体的使用是学好 Rust 的重要一步，它为后续学习 trait、泛型等高级特性奠定了基础。</p><p><strong>Hooray！结构体学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 所有权</title>
      <link href="/2025/09/23/rust-ownership/"/>
      <url>/2025/09/23/rust-ownership/</url>
      
        <content type="html"><![CDATA[<p>Rust 最独特的特性之一就是 <strong>所有权（Ownership）</strong>，它让 Rust 在没有垃圾回收器（GC）的情况下仍能保证内存安全。理解所有权的工作原理非常重要。</p><h2 id="1-所有权的基本概念"><a href="#1-所有权的基本概念" class="headerlink" title="1. 所有权的基本概念"></a>1. 所有权的基本概念</h2><p>所有权是一组规则，用来控制 Rust 如何管理内存。所有程序都需要管理运行时如何使用内存。常见的几种方式：</p><ul><li><strong>垃圾回收（GC）</strong>：例如 Java、Go，自动跟踪和清理不再使用的内存。</li><li><strong>手动管理</strong>：例如 C++，程序员必须显式分配和释放内存。</li><li><strong>所有权机制</strong>：Rust 使用所有权系统，在编译期检查规则，不影响运行时性能。</li></ul><h3 id="所有权规则（简要）"><a href="#所有权规则（简要）" class="headerlink" title="所有权规则（简要）"></a>所有权规则（简要）</h3><ol><li>每个值都有一个所有者（owner）。</li><li>对于不实现 <code>Copy</code> 的类型（如 <code>String</code>），同一时间只能有一个所有者（即移动语义）。</li><li>当所有者离开作用域时，值会被自动丢弃，内存释放。</li></ol><p><strong>注意</strong>：对于实现了 <code>Copy</code> trait 的简单类型（如整型、浮点、布尔、字符，以及不含堆数据的元组），赋值会复制 <code>Copy</code>，而不是 <code>Move</code>。</p><hr><h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2. 变量的作用域"></a>2. 变量的作用域</h2><p>变量的生命周期与作用域相关：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;                      <span class="comment">// s 在此处无效，还未声明</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s 从这里开始有效</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 s</span></span><br><span class="line">    &#125;                      <span class="comment">// 作用域结束，s 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-String-类型"><a href="#3-String-类型" class="headerlink" title="3. String 类型"></a>3. String 类型</h2><p>字符串字面量（如 <code>&quot;hello&quot;</code>）被硬编码到程序中，<strong>不可变</strong>。如果需要可变或运行时获取的字符串，可以使用 <code>String</code>，它在堆上分配内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// 在 String 后追加文本</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// 输出 &quot;hello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-内存与分配"><a href="#4-内存与分配" class="headerlink" title="4. 内存与分配"></a>4. 内存与分配</h2><p><code>String</code> 的工作流程：</p><ol><li>在调用 <code>String::from</code> 或其它分配时，向堆请求内存。</li><li>当变量超出作用域时，Rust 自动调用 <code>drop</code>，释放该内存。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 有效</span></span><br><span class="line">    &#125; <span class="comment">// s 超出作用域，自动调用 drop，内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Move-与-Clone"><a href="#5-Move-与-Clone" class="headerlink" title="5. Move 与 Clone"></a>5. Move 与 Clone</h2><h3 id="Move（移动语义）"><a href="#Move（移动语义）" class="headerlink" title="Move（移动语义）"></a>Move（移动语义）</h3><p>对于不实现 <code>Copy</code> 的类型，赋值或传参会发生 <strong>move</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 的所有权被移到 s2，s1 不再有效</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;s1&#125;&quot;); // 编译错误：s1 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计是为了防止出现 <strong>二次释放（double free）</strong> 的安全问题（两个变量同时指向同一堆内存，且各自尝试释放）。</p><h3 id="Clone（深拷贝）"><a href="#Clone（深拷贝）" class="headerlink" title="Clone（深拷贝）"></a>Clone（深拷贝）</h3><p>如果需要真正复制堆上的数据，使用 <code>clone()</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 深拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Copy（栈上数据的自动复制）"><a href="#Copy（栈上数据的自动复制）" class="headerlink" title="Copy（栈上数据的自动复制）"></a>Copy（栈上数据的自动复制）</h3><p>实现了 <code>Copy</code> 的类型在赋值时会按位复制（不会发生 Move），例如：整数、浮点、布尔、字符，以及不包含堆数据的元组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">// x 被 Copy，所以仍然可用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;, y = &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数传值与返回值"><a href="#6-函数传值与返回值" class="headerlink" title="6. 函数传值与返回值"></a>6. 函数传值与返回值</h2><h3 id="传参时的所有权行为"><a href="#传参时的所有权行为" class="headerlink" title="传参时的所有权行为"></a>传参时的所有权行为</h3><p>将值传给函数时也会发生 Move 或 Copy：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值被 move 到函数，s 在这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域（i32 实现了 Copy）</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 被 Copy，依然可用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入函数作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// some_string 离开作用域，drop 被调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// some_integer 离开作用域，无需特殊处理</span></span><br></pre></td></tr></table></figure><p>如果你在 <code>takes_ownership(s);</code> 之后再使用 <code>s</code>，会编译错误，因为 s 的所有权已被移动。</p><h3 id="返回值也会移动所有权"><a href="#返回值也会移动所有权" class="headerlink" title="返回值也会移动所有权"></a>返回值也会移动所有权</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 返回一个 String，所有权转给 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被 move 到函数里，函数再返回所有权给 s3</span></span><br><span class="line">&#125; <span class="comment">// s3 被 drop，s2 已被 move，不再有效，s1 被 drop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>);</span><br><span class="line">    some_string <span class="comment">// 返回所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    a_string <span class="comment">// 返回所有权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果不想在函数间频繁移动所有权，通常可以使用引用（借用）。</p><hr><h2 id="7-引用与借用（References-Borrowing）"><a href="#7-引用与借用（References-Borrowing）" class="headerlink" title="7. 引用与借用（References &amp; Borrowing）"></a>7. 引用与借用（References &amp; Borrowing）</h2><p>引用是指向数据的指针，但<strong>不拥有</strong>数据：</p><h3 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1); <span class="comment">// 将 s1 的不可变借用传入函数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// s 是引用，不会影响所有权，也不会在此处释放 s1</span></span><br></pre></td></tr></table></figure><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>默认引用是不可变的。若要修改被借用的数据，使用可变引用 <code>&amp;mut</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可变引用的限制</strong>：在任一给定时间，对某个值<strong>最多只能有一个可变引用</strong>。这避免了并发写入导致的数据竞争。数据竞争会被以下三种行为触发：</p><ul><li><p>两个或多个指针同时访问同一块内存。</p></li><li><p>至少有一个指针正在写入数据。</p></li><li><p>访问没有任何同步机制保护。</p></li></ul><p><strong>错误示例：多个可变引用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure><p><strong>通过作用域解决</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 离开作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ✅ 可以</span></span><br></pre></td></tr></table></figure><p><strong>不可变引用与可变引用不能同时存在</strong>：如果有不可变引用仍在使用，则不能创建可变引用；但如果不可变引用的作用域结束且不再使用，就可以随后创建可变引用。</p><p>示例如下：</p><p><strong>可变引用与不可变引用冲突</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure><p><strong>合理利用作用域</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>); <span class="comment">// r1 和 r2 的使用在这里结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 现在可以创建可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-悬垂引用（Dangling-References）"><a href="#8-悬垂引用（Dangling-References）" class="headerlink" title="8. 悬垂引用（Dangling References）"></a>8. 悬垂引用（Dangling References）</h2><p>悬垂引用是指引用指向的值已被释放，但引用仍被使用。Rust 的所有权系统和借用规则在编译期防止了悬垂引用。</p><p><strong>错误示例（编译失败）</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// ❌ 返回引用到一个局部变量，s 离开作用域后被 drop，引用悬空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：返回值的所有权（而不是引用），或确保引用指向的值在调用者作用域内保持有效：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s <span class="comment">// 返回所有权，安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-切片（Slice）"><a href="#9-切片（Slice）" class="headerlink" title="9. 切片（Slice）"></a>9. 切片（Slice）</h2><p>切片是对集合（如字符串、数组）中连续元素的引用，<strong>不取得所有权</strong>。</p><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;hello&#125;, &#123;world&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写与尾部省略：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice1</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice2</span> = &amp;s[..<span class="number">2</span>];   <span class="comment">// 等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice3</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice4</span> = &amp;s[<span class="number">3</span>..];   <span class="comment">// 等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">all2</span> = &amp;s[..];      <span class="comment">// 等效</span></span><br></pre></td></tr></table></figure><h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>所有权是 Rust 的核心机制，用以在<strong>编译期</strong>保证内存安全。</li><li>了解 <code>Move</code>、<code>Clone</code>、<code>Copy</code> 的区别有助于写出高效且无内存错误的代码。</li><li>引用（借用）允许临时使用数据而不转移所有权，且借用规则在编译期防止数据竞争和悬垂引用。</li><li>切片提供对集合部分的安全引用，不会取得所有权。</li></ul><p><strong>Hooray！所有权学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 流程控制</title>
      <link href="/2025/09/22/rust-control-flows/"/>
      <url>/2025/09/22/rust-control-flows/</url>
      
        <content type="html"><![CDATA[<h2 id="1-条件分支"><a href="#1-条件分支" class="headerlink" title="1. 条件分支"></a>1. 条件分支</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><ul><li>Rust 不会像 Ruby、JavaScript 等语言一样自动将非布尔值转换为布尔值。</li><li><strong>条件必须是布尔类型</strong>，否则会编译错误。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 这段代码会编译报错，因为整数 3 不能当作布尔值</span></span><br><span class="line">    <span class="keyword">if</span> number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number was three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if</code> 是一个 <strong>表达式</strong>（Expression），有返回值，可以赋值给变量。</li><li>注意：所有分支必须返回 <strong>同一类型</strong> 的值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 表达式的结果赋值给 number</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="else-if-表达式"><a href="#else-if-表达式" class="headerlink" title="else if 表达式"></a>else if 表达式</h3><ul><li>Rust 会依次检查 <code>if</code> 条件，执行第一个为 <code>true</code> 的分支。</li><li>一旦匹配成功，后续的条件不会再检查。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 如果 <code>else if</code> 太多，代码会变得复杂，此时可以用 <strong>模式匹配（Pattern Matching）</strong> 来简化。</p><hr><h2 id="2-循环控制"><a href="#2-循环控制" class="headerlink" title="2. 循环控制"></a>2. 循环控制</h2><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><ul><li><code>loop</code> 关键字表示无限循环，除非遇到 <code>break</code> 才会停止。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>break</code> 后面可以带返回值，作为 <code>loop</code> 表达式的结果。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>循环标签</strong>：用于在多层循环中跳出外层循环。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出当前循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>; <span class="comment">// 跳出外层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><ul><li><code>while</code> 更适合用在基于条件判断的循环。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>while</code> 遍历数组：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 缺点：数组大小若更改，可能导致 <strong>数组越界</strong>。</p><hr><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><ul><li><code>for</code> 更简洁、安全，不会发生数组越界。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hooray！流程控制学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 数据类型和函数</title>
      <link href="/2025/09/21/rust-datatype-and-functions/"/>
      <url>/2025/09/21/rust-datatype-and-functions/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型（Data-Type）"><a href="#数据类型（Data-Type）" class="headerlink" title="数据类型（Data Type）"></a>数据类型（Data Type）</h2><p>Rust 是一门静态编译语言，必须在编译时知道所有变量的类型，所以声明时需要标注数据类型。</p><h3 id="1-标量类型（Scalar-Type）"><a href="#1-标量类型（Scalar-Type）" class="headerlink" title="1. 标量类型（Scalar Type）"></a>1. 标量类型（Scalar Type）</h3><p>Rust 有四种主要标量类型：整数、浮点数、布尔值和字符。</p><h4 id="1-1-整数类型（Integer）"><a href="#1-1-整数类型（Integer）" class="headerlink" title="1.1 整数类型（Integer）"></a>1.1 整数类型（Integer）</h4><table><thead><tr><th>Length</th><th>Signed (有符号类型)</th><th>Unsigned (无符号类型)</th></tr></thead><tbody><tr><td>8-bit</td><td>i8 (-128 to 127)</td><td>u8 (0 to 255)</td></tr><tr><td>16-bit</td><td>i16 (-32,768 to 32,767)</td><td>u16 (0 to 65,535)</td></tr><tr><td>32-bit</td><td>i32 (-2^31 to 2^31-1)</td><td>u32 (0 to 2^32-1)</td></tr><tr><td>64-bit</td><td>i64 (-2^63 to 2^63-1)</td><td>u64 (0 to 2^64-1)</td></tr><tr><td>128-bit</td><td>i128 (-2^127 to 2^127-1)</td><td>u128 (0 to 2^128-1)</td></tr><tr><td>arch（依架构而定）</td><td>isize</td><td>usize</td></tr></tbody></table><ul><li><code>isize</code> 和 <code>usize</code> 的大小取决于运行程序的计算机架构：<ul><li>64 位系统 → 64 位</li><li>32 位系统 → 32 位</li></ul></li></ul><p>⚠️ 注意：如果声明变量的值超过数据类型的范围会导致 <strong>整数溢出（Integer Overflow）</strong>。</p><h4 id="1-2-浮点数类型（Floating-Point-Type）"><a href="#1-2-浮点数类型（Floating-Point-Type）" class="headerlink" title="1.2 浮点数类型（Floating-Point Type）"></a>1.2 浮点数类型（Floating-Point Type）</h4><p>Rust 中浮点数类型有两种：<code>f32</code> 和 <code>f64</code>。默认是 <code>f64</code>。</p><p>在现代 CPU 上，<code>f64</code> 的速度和 <code>f32</code> 基本相同，但精度更高。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>;      <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-布尔类型（Boolean-Type）"><a href="#1-3-布尔类型（Boolean-Type）" class="headerlink" title="1.3 布尔类型（Boolean Type）"></a>1.3 布尔类型（Boolean Type）</h4><p>布尔值有两个可能的值：<code>true</code> 和 <code>false</code>，大小为 1 个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// 显式类型标注</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;就这样吧&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-字符类型（Char-Type）"><a href="#1-4-字符类型（Char-Type）" class="headerlink" title="1.4 字符类型（Char Type）"></a>1.4 字符类型（Char Type）</h4><ul><li>Rust 中用 <code>&#39;&#39;</code> 来指定 <code>char</code> 类型的字符</li><li>用 <code>&quot;&quot;</code> 来指定字符串 <code>string</code></li><li><code>char</code> 占用 <strong>4 个字节</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-复合类型（Compound-Type）"><a href="#2-复合类型（Compound-Type）" class="headerlink" title="2. 复合类型（Compound Type）"></a>2. 复合类型（Compound Type）</h3><p>Rust 有两种复合类型：<strong>元组（Tuple）</strong> 和 <strong>数组（Array）</strong>。</p><h4 id="2-1-元组（Tuple-Type）"><a href="#2-1-元组（Tuple-Type）" class="headerlink" title="2.1 元组（Tuple Type）"></a>2.1 元组（Tuple Type）</h4><ul><li>元组可以存放不同类型的值</li><li>长度固定，声明后不可改变</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取元组的值有两种方式：</p><ul><li><p><strong>解构（Destructuring）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>索引（Index）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = tup.<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>⚠️ 没有任何值的元组叫 <strong>unit 类型</strong>，写作 <code>()</code>。</p><hr><h4 id="2-2-数组（Array-Type）"><a href="#2-2-数组（Array-Type）" class="headerlink" title="2.2 数组（Array Type）"></a>2.2 数组（Array Type）</h4><ul><li>所有元素必须是相同类型</li><li>长度固定，存放在 <strong>栈</strong> 上</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 中的数组具有固定长度，这点与其它语言不同，其它编程语言中数组是可变长度，与 Rust 中的 vector 类似。当你想将数据分配在栈上而不是堆或者你想确保始终有固定数量的元素时，数组非常有用，比如一年的月数是固定的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [</span><br><span class="line">    <span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>,</span><br><span class="line">    <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>指定数组类型与长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>指定初始值和长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 等同于 [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure><p>数组是连续存放在栈上的有序结构，可以通过索引访问。Rust 的索引下标从 <strong>0</strong> 开始。</p><ul><li><p>访问数组元素</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];  <span class="comment">// 访问数组中第一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>]; <span class="comment">// 访问数组中第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组下标越界</p><p>如果下标不在 <code>[0, Length-1]</code> 范围内：</p><ul><li>编译阶段：直接报 <strong>panic</strong> 警告</li><li>运行阶段：无法提前知道输入，越界时会 <strong>立即终止程序</strong>，而不是访问无效内存</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of the element at index &#123;index&#125; is: &#123;element&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ Rust 的安全特性：<strong>遇到越界立刻退出</strong>，避免无效内存访问。</p><hr><h2 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h2><p>函数由以下部分构成：</p><ul><li><code>fn</code> 关键字</li><li>函数名 <code>add</code></li><li>参数 <code>x, y</code> 和参数类型 <code>i32</code></li><li>函数体 <code>x + y</code></li><li>返回值类型 <code>i32</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><ul><li><p><strong>语句（Statements）</strong>：执行操作，但不返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ❌ 错误写法</span></span><br><span class="line">    <span class="comment">// 因为 let y = 6 是语句，没有返回值</span></span><br><span class="line">    <span class="comment">// 这是 Rust 的一个特性，如果是 C 或 Ruby，赋值操作会返回被赋的值 6</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>表达式（Expression）</strong>：计算并返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span>   <span class="comment">// 没有分号，表示表达式</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Hooray！数据类型和函数学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 变量和可变性</title>
      <link href="/2025/09/20/rust-variables-and-mutability/"/>
      <url>/2025/09/20/rust-variables-and-mutability/</url>
      
        <content type="html"><![CDATA[<h2 id="1-可变与不可变变量"><a href="#1-可变与不可变变量" class="headerlink" title="1. 可变与不可变变量"></a>1. 可变与不可变变量</h2><ul><li><strong>不可变变量（Immutable）</strong>：Rust 中变量默认不可变，一旦绑定后值不能改变。</li><li><strong>可变变量（Mutable）</strong>：使用 <code>mut</code> 关键字，可以让变量的值在绑定后发生改变。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// ✅ 可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// y = 11; // ❌ 错误：不可修改</span></span><br></pre></td></tr></table></figure><h2 id="2-常量（Constants）"><a href="#2-常量（Constants）" class="headerlink" title="2. 常量（Constants）"></a>2. 常量（Constants）</h2><ul><li>使用 <code>const</code> 关键字声明，始终不可变</li><li>常量名全部大写，单词之间用下划线分隔</li><li>常量必须在编译期已知，并且类型必须显式标注</li><li>与变量不同，常量不能用 <code>mut</code> 声明</li><li>常量可以在任意作用域定义，包括全局作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="3-遮蔽（Shadowing）"><a href="#3-遮蔽（Shadowing）" class="headerlink" title="3. 遮蔽（Shadowing）"></a>3. 遮蔽（Shadowing）</h2><p>使用 <code>let</code> 重复声明同名变量时，新变量会 <strong>遮蔽</strong> 旧变量。</p><ul><li><strong>在同一作用域内</strong>：旧绑定被完全隐藏，无法访问</li><li><strong>跨作用域时</strong>：内层遮蔽外层，内层作用域结束后外层绑定重新可见</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;  <span class="comment">// 新的 x 遮蔽旧的 x=5</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;  <span class="comment">// 仅在当前作用域生效，不会遮蔽前面的x = x + 1</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);<span class="comment">// 输出 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);<span class="comment">// 输出 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与 <code>mut</code> 的区别<ul><li><strong><code>mut</code></strong>：修改同一个变量的值。</li><li><strong>遮蔽</strong>：创建一个新的变量绑定，旧的绑定被隐藏，而且可以改变类型。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 mut：错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="comment">// spaces = spaces.len(); // ❌ 类型不匹配，&amp;str 不能赋值为 usize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用遮蔽：正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>(); <span class="comment">// ✅ 类型从 &amp;str → usize</span></span><br></pre></td></tr></table></figure><p><strong>Hooray！变量和可变性学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— Hello, World!</title>
      <link href="/2025/09/19/rust-hello-world/"/>
      <url>/2025/09/19/rust-hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p><strong>Rust</strong>是一门静态编译的语言，强调<strong>性能</strong>、<strong>类型安全</strong>、<strong>并发性</strong>。</p><h2 id="1-安装-Rust"><a href="#1-安装-Rust" class="headerlink" title="1. 安装 Rust"></a>1. 安装 Rust</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rust 安装</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载环境变量</span></span><br><span class="line">. <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">rustc --version</span><br></pre></td></tr></table></figure><p><strong>其他常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rust 更新</span></span><br><span class="line">rustup update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rust 卸载</span></span><br><span class="line">rustup self uninstall</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rust 离线文档</span></span><br><span class="line">rustup doc</span><br></pre></td></tr></table></figure><h2 id="2-VS-Code-插件拓展"><a href="#2-VS-Code-插件拓展" class="headerlink" title="2. VS Code 插件拓展"></a>2. VS Code 插件拓展</h2><ul><li><strong>rust-analyzer</strong> —— 代码补全与分析</li><li><strong>Dependi</strong> —— Cargo.toml 依赖管理助手</li><li><strong>Even Better TOML</strong> —— TOML 高亮与校验</li><li><strong>CodeLLDB</strong> —— Rust Debugger</li></ul><h2 id="3-Hello，World"><a href="#3-Hello，World" class="headerlink" title="3. Hello，World"></a>3. Hello，World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line"><span class="built_in">mkdir</span> hello_world</span><br><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 main.rs</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./main.rs &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">rustc main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p><strong>执行后 Hello, world! 字符串应打印到终端</strong><br><img src="/images/Rust/hello-world.png"></p><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p>编译时报错 <code>linker &#39;cc&#39; not found</code>，说明系统缺少编译工具，安装即可：</p><p><img src="/images/Rust/linker-cc-err.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件包索引</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装构建工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential -y</span><br></pre></td></tr></table></figure><h2 id="4-Hello-Cargo"><a href="#4-Hello-Cargo" class="headerlink" title="4. Hello, Cargo"></a>4. Hello, Cargo</h2><p><strong>Cargo</strong> 是 Rust 的官方构建工具和包管理器，提供 <strong>项目管理、依赖管理、编译、测试</strong> 等功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化项目</span></span><br><span class="line">cargo new hello_cargo</span><br><span class="line"><span class="built_in">cd</span> hello_cargo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 src/main.rs</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./src/main.rs &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println!(<span class="string">&quot;Hello, cargo!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建并运行（等价于 cargo build + 执行）</span></span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><p><strong>其他常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debug 构建</span></span><br><span class="line">cargo build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Release 构建</span></span><br><span class="line">cargo build —release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Cargo 版本</span></span><br><span class="line">cargo --version</span><br></pre></td></tr></table></figure><p><strong>Hooray! Rust 学习之旅，正式启程！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Op Stack 组件日志管理</title>
      <link href="/2025/09/18/log-mgmt-part4/"/>
      <url>/2025/09/18/log-mgmt-part4/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Layer 2 节点的各项组件（如 <code>op-geth</code>、<code>op-node</code>、<code>op-batcher</code>、<code>op-proposer</code>）在运行过程中会产生大量日志数据。如果缺乏有效的日志管理策略，这些日志文件会持续增长，最终可能导致：</p><ul><li><strong>磁盘空间耗尽</strong>：影响节点正常运行，甚至导致服务中断</li><li><strong>查询效率低下</strong>：巨大的日志文件难以进行快速的问题定位和分析</li><li><strong>系统性能下降</strong>：持续的写操作会增加磁盘 I&#x2F;O 压力</li></ul><p>因此，选择一套稳定、高效的日志管理方案至关重要。</p><h2 id="一、传统-Logrotate-管理"><a href="#一、传统-Logrotate-管理" class="headerlink" title="一、传统 Logrotate 管理"></a>一、传统 Logrotate 管理</h2><h3 id="1-什么是-Logrotate？"><a href="#1-什么是-Logrotate？" class="headerlink" title="1. 什么是 Logrotate？"></a>1. 什么是 Logrotate？</h3><p><code>logrotate</code> 是 Linux 系统的经典日志管理工具，通过 cron 定时任务（通常每日执行）对日志文件进行轮转、压缩和清理，有效控制日志文件大小。</p><h3 id="2-Postrotate-服务重启方案"><a href="#2-Postrotate-服务重启方案" class="headerlink" title="2. Postrotate 服务重启方案"></a>2. Postrotate 服务重启方案</h3><p>这种方案在日志轮转后重启相关服务，确保服务能够正确处理新的日志文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/logrotate.d/layer2-services</span></span><br><span class="line">/home/eth/optimism/logs/*/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 30</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    create 644 root root</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    postrotate</span><br><span class="line">        systemctl reload-or-restart op-geth op-node op-batcher op-proposer &gt;/dev/null 2&gt;&amp;1 || <span class="literal">true</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优缺点分析</strong><ul><li><strong>优点</strong>：确保日志完整性，无数据丢失风险</li><li><strong>缺点</strong>：服务重启会触发区块重扫，严重影响同步效率，并可能导致新区块生成时间滞后</li></ul></li></ul><h3 id="3-copytruncate-复制并清空"><a href="#3-copytruncate-复制并清空" class="headerlink" title="3. copytruncate 复制并清空"></a>3. copytruncate 复制并清空</h3><p>此方案通过复制当前日志内容后清空原文件的方式，服务进程毫无感知，避免服务重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/logrotate.d/layer2-services</span></span><br><span class="line">/home/eth/optimism/logs/*/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 30</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    copytruncate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优缺点分析</strong><ul><li><strong>优点</strong>：无需服务重启，保证连续性</li><li><strong>缺点</strong>：在复制和截断操作的毫秒级窗口期内可能丢失少量日志，并且会产生额外的磁盘 I&#x2F;O 开销。</li></ul></li></ul><h3 id="4-测试与验证"><a href="#4-测试与验证" class="headerlink" title="4. 测试与验证"></a>4. 测试与验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预览轮转效果（不实际执行）</span></span><br><span class="line"><span class="built_in">sudo</span> logrotate -d /etc/logrotate.d/layer2-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制执行一次轮转</span></span><br><span class="line"><span class="built_in">sudo</span> logrotate -f /etc/logrotate.d/layer2-services</span><br></pre></td></tr></table></figure><h2 id="二、现代化-Journald-管理"><a href="#二、现代化-Journald-管理" class="headerlink" title="二、现代化 Journald 管理"></a>二、现代化 Journald 管理</h2><h3 id="1-什么是-Journald"><a href="#1-什么是-Journald" class="headerlink" title="1. 什么是 Journald"></a>1. 什么是 Journald</h3><p><code>journald</code> 是 systemd 生态的原生日志管理服务，它将日志作为结构化的事件流处理，并由其自身负责存储、轮转和清理，可以避免服务中断和数据丢失。</p><h3 id="2-迁移步骤"><a href="#2-迁移步骤" class="headerlink" title="2. 迁移步骤"></a>2. 迁移步骤</h3><h4 id="2-1-修改-Systemd-Service-文件"><a href="#2-1-修改-Systemd-Service-文件" class="headerlink" title="2.1 修改 Systemd Service 文件"></a>2.1 修改 Systemd Service 文件</h4><p>迁移的核心是移除强制将日志输出到文件的配置，让日志流回归 <code>systemd</code> 的默认通道——<code>journald</code>。</p><p>以 <strong><code>op-geth.service</code></strong> 为例，需移除 <code>StandardOutput</code> 和 <code>StandardError</code>配置。</p><ul><li><strong>需移除的配置</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-geth/geth.log</span><br></pre></td></tr></table></figure><ul><li><strong>修改后的 <code>op-geth.service</code> 示例</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=OP-Geth Execution Client</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-geth_starter.sh</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="2-2-简化启动脚本"><a href="#2-2-简化启动脚本" class="headerlink" title="2.2 简化启动脚本"></a>2.2 简化启动脚本</h4><p>由于不再需要管理日志文件，可以移除相关的目录创建逻辑。</p><ul><li><strong>需移除的配置</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-geth&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br></pre></td></tr></table></figure><ul><li><strong>修改后的 <code>op-geth_starter.sh</code> 示例:</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting Geth node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：同样的修改需要应用到 <code>op-node</code>、<code>op-batcher</code>、<code>op-proposer</code> 等所有相关服务的 <code>.service</code> 文件和启动脚本中。</p><h4 id="2-3-清理旧配置并应用更改"><a href="#2-3-清理旧配置并应用更改" class="headerlink" title="2.3 清理旧配置并应用更改"></a>2.3 清理旧配置并应用更改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除旧的 logrotate 配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /etc/logrotate.d/layer2-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 systemd 配置</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务以应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h4 id="2-4-配置-Journald-存储限制"><a href="#2-4-配置-Journald-存储限制" class="headerlink" title="2.4 配置 Journald 存储限制"></a>2.4 配置 Journald 存储限制</h4><p>为防止日志无限增长，需要设置合理的存储上限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/journald.conf</span><br></pre></td></tr></table></figure><p>在 <code>[Journal]</code> 部分添加或修改：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Journal]</span></span><br><span class="line"><span class="attr">SystemMaxUse</span>=<span class="number">10</span>G</span><br></pre></td></tr></table></figure><ul><li><strong><code>SystemMaxUse=10G</code></strong>: 设置 journald 可使用的最大磁盘空间为 10GB。可以根据服务器磁盘大小调整此值（如 <code>5G</code>, <code>20G</code>）。</li></ul><p>保存文件后，重启 <code>journald</code> 服务使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-journald</span><br></pre></td></tr></table></figure><p>配置生效后，当日志总量将要超过设置的阈值时，<code>journald</code> 就会自动、静默地删除最旧的日志文件，为新日志腾出空间，确保日志大小始终保持在限制范围内。</p><p><strong>Hooray！Journald 配置成功！！！</strong></p><h2 id="三、日志管理常用命令"><a href="#三、日志管理常用命令" class="headerlink" title="三、日志管理常用命令"></a>三、日志管理常用命令</h2><p><strong>提示</strong>：在终端直接查看时，可以去掉 <code>--no-pager</code> 参数，以使用 <code>less</code> 分页器方便地上下滚动和搜索。导出文件时则需要加上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 op-geth 服务的实时日志</span></span><br><span class="line">journalctl -u op-geth.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看 op-geth 和 op-node 两个服务的混合日志</span></span><br><span class="line">journalctl -u op-geth.service -u op-node.service -f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 op-geth 过去两小时的日志</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;2 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 op-node 今天的所有日志</span></span><br><span class="line">journalctl -u op-node.service --since <span class="string">&quot;today&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定时间段的日志 (示例日期: 2025-09-19)</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;2025-09-19 15:00:00&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2025-09-19 17:00:00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出 op-geth 昨日的全部日志到根目录</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;yesterday&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;today&quot;</span> --no-pager &gt; ~/op-geth_yesterday.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前 journald 日志占用空间</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 journald 当前的磁盘限额配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/systemd/journald.conf | grep SystemMaxUse</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 <code>Layer2</code> 节点这样需要高可用性和连续运行的关键服务，现代化的 <code>Journald</code> 管理方案显然更具优势，原因如下：</p><ul><li><strong>零服务中断</strong>：避免了 Logrotate 重启服务导致的区块重扫问题</li><li><strong>原生集成</strong>：与 Systemd 生态深度整合，管理更加统一</li><li><strong>结构化存储</strong>：支持更丰富的查询和过滤功能</li><li><strong>简化运维</strong>：无需复杂的轮转脚本，配置简单维护方便</li></ul><p>良好的日志管理是保障节点稳定运行、快速排查问题的基石，选择合适的方案能让维护工作事半功倍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> Journald </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Systemd 自动化管理 OP Stack 组件</title>
      <link href="/2025/09/17/systemd-auto-mgmt-part3/"/>
      <url>/2025/09/17/systemd-auto-mgmt-part3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在部署和运行 Optimism 的过程中，手动启动各个组件既繁琐又容易出错。本文将详细介绍如何使用 systemd 服务来自动化管理 OP Stack 的各个核心组件，包括 op-geth、op-node、op-batcher 和 op-proposer。</p><p>⚠️<strong>本文中的路径 <code>/home/eth/optimism/</code> 仅作示例，使用前请根据自己的部署目录修改</strong></p><h2 id="一、Why-Systemd？"><a href="#一、Why-Systemd？" class="headerlink" title="一、Why Systemd？"></a>一、Why Systemd？</h2><p>Systemd 是现代 Linux 发行版的标准初始化系统和服务管理器，它提供了以下优势：</p><ul><li><strong>自动重启</strong>：当服务异常退出时自动重启</li><li><strong>依赖管理</strong>：确保服务按正确顺序启动</li><li><strong>日志管理</strong>：集中管理服务日志</li><li><strong>开机自启</strong>：系统重启后自动启动服务</li></ul><h2 id="二、启动脚本"><a href="#二、启动脚本" class="headerlink" title="二、启动脚本"></a>二、启动脚本</h2><h3 id="2-1-创建脚本目录"><a href="#2-1-创建脚本目录" class="headerlink" title="2.1 创建脚本目录"></a>2.1 创建脚本目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/</span><br><span class="line"><span class="built_in">mkdir</span> -p scripts</span><br><span class="line"><span class="built_in">cd</span> scripts/</span><br></pre></td></tr></table></figure><h3 id="2-2-创建启动脚本"><a href="#2-2-创建启动脚本" class="headerlink" title="2.2 创建启动脚本"></a>2.2 创建启动脚本</h3><h4 id="OP-Geth-启动脚本"><a href="#OP-Geth-启动脚本" class="headerlink" title="OP-Geth 启动脚本"></a>OP-Geth 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-geth_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-geth&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting Geth node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Node-启动脚本"><a href="#OP-Node-启动脚本" class="headerlink" title="OP-Node 启动脚本"></a>OP-Node 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-node_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-node&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-node</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-node \</span><br><span class="line">        --l2=http://localhost:8551 \</span><br><span class="line">        --l2.jwt-secret=./jwt.txt \</span><br><span class="line">        --sequencer.enabled \</span><br><span class="line">        --sequencer.l1-confs=5 \</span><br><span class="line">        --verifier.l1-confs=4 \</span><br><span class="line">        --rollup.config=../.deployer/rollup.json \</span><br><span class="line">        --rpc.addr=0.0.0.0 \</span><br><span class="line">        --rpc.port=9545 \</span><br><span class="line">        --p2p.disable \</span><br><span class="line">        --rpc.enable-admin \</span><br><span class="line">        --p2p.sequencer.key=<span class="variable">$GS_SEQUENCER_PRIVATE_KEY</span> \</span><br><span class="line">        --l1=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">        --l1.rpckind=<span class="variable">$L1_RPC_KIND</span> \</span><br><span class="line">        --l1.beacon=<span class="variable">$L1_BEACON_URL</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Batcher-启动脚本"><a href="#OP-Batcher-启动脚本" class="headerlink" title="OP-Batcher 启动脚本"></a>OP-Batcher 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-batcher_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-batcher&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Batcher at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-batcher</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-batcher \</span><br><span class="line">        --l2-eth-rpc=http://localhost:8545 \</span><br><span class="line">        --rollup-rpc=http://localhost:9545 \</span><br><span class="line">        --poll-interval=1s \</span><br><span class="line">        --sub-safety-margin=6 \</span><br><span class="line">        --num-confirmations=1 \</span><br><span class="line">        --safe-abort-nonce-too-low-count=3 \</span><br><span class="line">        --resubmission-timeout=30s \</span><br><span class="line">        --rpc.addr=0.0.0.0 \</span><br><span class="line">        --rpc.port=8548 \</span><br><span class="line">        --rpc.enable-admin \</span><br><span class="line">        --max-channel-duration=25 \</span><br><span class="line">        --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">        --private-key=<span class="variable">$GS_BATCHER_PRIVATE_KEY</span></span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="OP-Proposer-启动脚本"><a href="#OP-Proposer-启动脚本" class="headerlink" title="OP-Proposer 启动脚本"></a>OP-Proposer 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-proposer_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-proposer&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Proposer at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-proposer</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-proposer \</span><br><span class="line">    --poll-interval=12s \</span><br><span class="line">    --rpc.port=8560 \</span><br><span class="line">    --rollup-rpc=http://localhost:9545 \</span><br><span class="line">    --private-key=<span class="variable">$GS_PROPOSER_PRIVATE_KEY</span> \</span><br><span class="line">    --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-3-设置脚本权限"><a href="#2-3-设置脚本权限" class="headerlink" title="2.3 设置脚本权限"></a>2.3 设置脚本权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x op-geth_starter.sh op-node_starter.sh op-batcher_starter.sh  op-proposer_starter.sh</span><br></pre></td></tr></table></figure><h3 id="2-4-测试脚本"><a href="#2-4-测试脚本" class="headerlink" title="2.4 测试脚本"></a>2.4 测试脚本</h3><p>此时可以尝试启动一下脚本，检查脚本是否正常工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 L2 节点的 Geth</span></span><br><span class="line">./op-geth_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 OP Node</span></span><br><span class="line">./op-node_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Batcher</span></span><br><span class="line">./op-batcher_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Proposer</span></span><br><span class="line">./op-proposer_starter.sh</span><br></pre></td></tr></table></figure><h2 id="三、Systemd-服务文件"><a href="#三、Systemd-服务文件" class="headerlink" title="三、Systemd 服务文件"></a>三、Systemd 服务文件</h2><h3 id="3-1-创建服务文件目录"><a href="#3-1-创建服务文件目录" class="headerlink" title="3.1 创建服务文件目录"></a>3.1 创建服务文件目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/</span><br><span class="line"><span class="built_in">mkdir</span> -p service</span><br><span class="line"><span class="built_in">cd</span> service/</span><br></pre></td></tr></table></figure><h3 id="3-2-创建-Systemd-服务文件"><a href="#3-2-创建-Systemd-服务文件" class="headerlink" title="3.2 创建 Systemd 服务文件"></a>3.2 创建 Systemd 服务文件</h3><h4 id="OP-Geth-服务配置"><a href="#OP-Geth-服务配置" class="headerlink" title="OP-Geth 服务配置"></a>OP-Geth 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-geth.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Geth Execution Client</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-geth_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Node-服务配置"><a href="#OP-Node-服务配置" class="headerlink" title="OP-Node 服务配置"></a>OP-Node 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-node.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Node L2 Consensus Client</span><br><span class="line">After=network-online.target op-geth.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-geth.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-node_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-node/op-node.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-node/op-node.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Batcher-服务配置"><a href="#OP-Batcher-服务配置" class="headerlink" title="OP-Batcher 服务配置"></a>OP-Batcher 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-batcher.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Batcher L2 Transaction Batcher</span><br><span class="line">After=network-online.target op-node.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-node.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-batcher_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-batcher/op-batcher.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-batcher/op-batcher.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Proposer-服务配置"><a href="#OP-Proposer-服务配置" class="headerlink" title="OP-Proposer 服务配置"></a>OP-Proposer 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ./op-proposer.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Proposer L2 State Proposer</span><br><span class="line">After=network-online.target op-node.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-node.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-proposer_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-proposer/op-proposer.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-proposer/op-proposer.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="服务依赖关系说明"><a href="#服务依赖关系说明" class="headerlink" title="服务依赖关系说明"></a>服务依赖关系说明</h4><p>服务启动的依赖顺序如下：</p><ol><li><strong>op-geth</strong>：基础执行客户端，必须首先启动</li><li><strong>op-node</strong>：依赖 op-geth 提供的 Engine API</li><li><strong>op-batcher</strong> 和 <strong>op-proposer</strong>：都依赖 op-node 提供的 Rollup RPC</li></ol><p>通过 <code>After</code> 和 <code>Requires</code> 指令，systemd 会自动处理这些依赖关系。</p><h3 id="3-3-安装服务文件"><a href="#3-3-安装服务文件" class="headerlink" title="3.3 安装服务文件"></a>3.3 安装服务文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -sf /home/eth/optimism/service/*.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 systemd 配置</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查服务文件语法是否有误</span></span><br><span class="line"><span class="built_in">sudo</span> systemd-analyze verify /etc/systemd/system/<span class="variable">$&#123;service&#125;</span>.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><p><strong>启动成功状态应如下图所示：</strong><br><img src="/images/2025/layer2status.png"></p><p><strong>Hooray！Systemd 配置成功！！！</strong></p><h2 id="五、常见故障排查"><a href="#五、常见故障排查" class="headerlink" title="五、常见故障排查"></a>五、常见故障排查</h2><p><strong>日志管理</strong></p><blockquote><ul><li><p>OP-Geth: <code>/home/eth/optimism/logs/op-geth/geth.log</code></p></li><li><p>OP-Node: <code>/home/eth/optimism/logs/op-node/op-node.log</code></p></li><li><p>OP-Batcher: <code>/home/eth/optimism/logs/op-batcher/op-batcher.log</code></p></li><li><p>OP-Proposer: <code>/home/eth/optimism/logs/op-proposer/op-proposer.log</code></p></li></ul></blockquote><h3 id="5-1-code-exited-status-1-FAILURE"><a href="#5-1-code-exited-status-1-FAILURE" class="headerlink" title="5.1 code&#x3D;exited, status&#x3D;1&#x2F;FAILURE"></a>5.1 code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</h3><p>进入的 logs 的路径通过命令 <code>tail -n 50 YOUR_LOG_NAME</code> 查看服务的最近日志，使用 systemd 执行脚本时不会自动加载环境变量，如果脚本中使用了环境变量但没有正确加载，就会导致找不到相关变量而报错。</p><p><img src="/images/2025/addressnotfound.png"></p><p><strong>解决方案</strong>：确保启动脚本中正确配置环境变量加载语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/optimism/.envrc</span><br></pre></td></tr></table></figure><h3 id="5-2-code-exited-status-209-STDOUT"><a href="#5-2-code-exited-status-209-STDOUT" class="headerlink" title="5.2 code&#x3D;exited, status&#x3D;209&#x2F;STDOUT"></a>5.2 code&#x3D;exited, status&#x3D;209&#x2F;STDOUT</h3><p>通过命令 <code>sudo journalctl -u YOUR_SERVICE_NAME -n 50 --no-pager</code>查看服务的最近日志。服务启动时会检查配置的路径是否可访问或存在，需要检查配置的路径是否存在以及是否具有访问权限。</p><p><strong>排查步骤</strong>：</p><ol><li>检查 <code>WorkingDirectory</code> 路径是否存在</li><li>检查 <code>ExecStart</code> 指向的脚本文件是否存在且有执行权限</li><li>检查日志目录是否可写</li></ol><p><img src="/images/2025/209-stdout.png"></p><h3 id="5-3-其他常用调试命令示例"><a href="#5-3-其他常用调试命令示例" class="headerlink" title="5.3 其他常用调试命令示例"></a>5.3 其他常用调试命令示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看服务实时日志</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u op-geth -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行组件实时日志</span></span><br><span class="line"><span class="built_in">tail</span> -f op-geth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查所有服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl is-active op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过使用 systemd 管理 OP Stack 组件，我们实现了：</p><ul><li><strong>自动化管理</strong>：服务自动启动、重启和监控</li><li><strong>依赖管理</strong>：确保服务按正确顺序启动</li><li><strong>日志集中管理</strong>：方便问题排查和监控</li><li><strong>生产环境就绪</strong>：满足生产环境的稳定性要求</li></ul><p>这种配置方式特别适合生产环境部署，能够显著减少手动维护工作量，提高系统的可靠性和稳定性。当遇到问题时，通过查看具体的错误代码和日志，能够快速定位和解决问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> Systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Blockscout 部署指南</title>
      <link href="/2025/09/16/blockscout-deployment-part2/"/>
      <url>/2025/09/16/blockscout-deployment-part2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本指南详细介绍了如何为搭建的 Layer2 区块链网络部署 Blockscout 区块浏览器。Blockscout 是一个功能全面的开源区块链浏览器，专为以太坊虚拟机（EVM）兼容网络设计。它提供了直观的用户界面来查看交易、区块、合约和账户信息，是区块链项目不可或缺的基础设施组件。</p><h2 id="一、系统环境准备"><a href="#一、系统环境准备" class="headerlink" title="一、系统环境准备"></a>一、系统环境准备</h2><h3 id="1-1-安装软件依赖"><a href="#1-1-安装软件依赖" class="headerlink" title="1.1 安装软件依赖"></a>1.1 安装软件依赖</h3><p>打开 Ubuntu-24.04 子系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y curl wget git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译工具 / 构建</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y build-essential make g++ gcc automake libtool cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统库</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y libudev-dev libgmp-dev libgmp10 libssl-dev libncurses-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩 / 解压</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y zip unzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y inotify-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 asdf</span></span><br><span class="line">go install github.com/asdf-vm/asdf/cmd/asdf@v0.18.0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/go/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 postgreSQL-17 数据库</span></span><br><span class="line">curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc|<span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/trusted.gpg.d/postgresql.gpg</span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo &quot;deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install postgresql-17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 rust</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure><h3 id="1-2-配置-asdf"><a href="#1-2-配置-asdf" class="headerlink" title="1.2 配置 asdf"></a>1.2 配置 asdf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Erlang、Elixir、Node.js 插件</span></span><br><span class="line">asdf plugin add erlang</span><br><span class="line">asdf plugin add elixir</span><br><span class="line">asdf plugin add nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 blockscout backend</span></span><br><span class="line">asdf install erlang 27.3.4</span><br><span class="line">asdf install elixir 1.17.3-otp-27</span><br><span class="line">asdf install nodejs 20.17.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 blockscout frontend</span></span><br><span class="line">asdf install nodejs 22.11.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 asdf 环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.asdf/shims:<span class="variable">$HOME</span>/.asdf/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="1-3-配置-Postgres-数据库"><a href="#1-3-配置-Postgres-数据库" class="headerlink" title="1.3 配置 Postgres 数据库"></a>1.3 配置 Postgres 数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库管理员</span></span><br><span class="line">su - postgres <span class="comment"># for Root</span></span><br><span class="line"><span class="built_in">sudo</span> -i -u postgres <span class="comment"># for user</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库用户</span></span><br><span class="line">createuser --interactive</span><br><span class="line"><span class="comment"># 输入角色名: YOUR_DBUSER_NAME</span></span><br><span class="line"><span class="comment"># 是否为超级用户? (y/n) y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">createdb blockscout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户密码</span></span><br><span class="line">psql</span><br><span class="line">ALTER USER YOUR_DBUSER_NAME WITH PASSWORD <span class="string">&#x27;YourSecurePassword&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE blockscout TO YOUR_DBUSER_NAME;</span><br><span class="line">\q</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart postgresql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据库设置是否成功</span></span><br><span class="line">su - YOUR_DBUSER_NAME <span class="comment"># for Root</span></span><br><span class="line"><span class="built_in">sudo</span> su - YOUR_DBUSER_NAME <span class="comment"># for user</span></span><br><span class="line">psql -d blockscout<span class="comment"># 如果能看到 blockscout=# 说明成功</span></span><br><span class="line">\q</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 psql 运行状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status postgresql</span><br></pre></td></tr></table></figure><h2 id="二、构建-Blockscout-Backend"><a href="#二、构建-Blockscout-Backend" class="headerlink" title="二、构建 Blockscout Backend"></a>二、构建 Blockscout Backend</h2><h3 id="2-1-克隆-Blockscout-Backend-仓库"><a href="#2-1-克隆-Blockscout-Backend-仓库" class="headerlink" title="2.1 克隆 Blockscout Backend 仓库"></a>2.1 克隆 Blockscout Backend 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 blockscout 工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> -p blockscout</span><br><span class="line"><span class="built_in">cd</span> blockscout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 blockscout backend 并切换到最新 release 分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/blockscout/blockscout.git backend</span><br><span class="line"><span class="built_in">cd</span> backend</span><br><span class="line">git checkout v9.1.0 -b v9.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Mix 依赖并编译</span></span><br><span class="line">mix <span class="keyword">do</span> deps.get, local.rebar --force, deps.compile, compile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据库生成新的 secret_key_base</span></span><br><span class="line">mix phx.gen.secret</span><br></pre></td></tr></table></figure><h3 id="2-2-编辑环境变量文件"><a href="#2-2-编辑环境变量文件" class="headerlink" title="2.2 编辑环境变量文件"></a>2.2 编辑环境变量文件</h3><p>创建 <code>env_vars.env</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano env_vars.env</span><br></pre></td></tr></table></figure><p>填写以下变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATABASE_URL=postgresql://YOUR_DBUSER_NAME:YourSecurePassword@localhost:5432/blockscout</span><br><span class="line"><span class="built_in">export</span> SECRET_KEY_BASE= <span class="comment"># generated by mix phx.gen.secret</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_VARIANT=geth</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_HTTP_URL=http://localhost:8545</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_WS_URL=ws://localhost:8546</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_TRACE_URL=http://localhost:8545</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> API_V2_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> PORT=4000</span><br><span class="line"><span class="built_in">export</span> MIX_ENV=prod</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CHAIN_ID=L2_CHAIN_ID</span><br><span class="line"><span class="built_in">export</span> L1_RPC=L1_RPC_URL</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> COIN=ETH</span><br><span class="line"><span class="built_in">export</span> COIN_NAME=<span class="string">&quot;Sepolia ETH&quot;</span></span><br><span class="line"><span class="built_in">export</span> COINGECKO_COIN_ID=ethereum</span><br><span class="line"><span class="built_in">export</span> DISPLAY_TOKEN_ICONS=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SC_VERIFIER_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SC_VERIFIER_URL=http://localhost:8082/</span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_VISUALIZE_SOL2UML_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_VISUALIZE_SOL2UML_URL=http://localhost:8081/</span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SIG_PROVIDER_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SIG_PROVIDER_URL=http://localhost:8083/</span><br></pre></td></tr></table></figure><p>加载环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> env_vars.env</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 postgresql 运行状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status postgresql</span><br><span class="line"><span class="comment"># 创建数据库并迁移</span></span><br><span class="line">mix <span class="keyword">do</span> ecto.create, ecto.migrate</span><br></pre></td></tr></table></figure><h3 id="2-3-安装-Blockscout-Backend-内置前端静态资源"><a href="#2-3-安装-Blockscout-Backend-内置前端静态资源" class="headerlink" title="2.3 安装 Blockscout Backend 内置前端静态资源"></a>2.3 安装 Blockscout Backend 内置前端静态资源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Node.js 依赖</span></span><br><span class="line"><span class="built_in">cd</span> apps/block_scout_web/assets</span><br><span class="line">npm install</span><br><span class="line">node_modules/webpack/bin/webpack.js --mode production</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">cd</span> apps/explorer</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译静态资源</span></span><br><span class="line"><span class="built_in">cd</span> ../block_scout_web/</span><br><span class="line">mix phx.digest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成自签名证书以启用 HTTPS（开发环境）：</span></span><br><span class="line">mix phx.gen.cert blockscout blockscout.local</span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><p>将 <code>blockscout</code> 和 <code>blockscout.local</code> 添加到 <code>/etc/hosts</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加以下行</span></span><br><span class="line">127.0.0.1 localhost blockscout blockscout.local</span><br><span class="line">::1 localhost blockscout blockscout.local</span><br></pre></td></tr></table></figure><h2 id="三、运行微服务"><a href="#三、运行微服务" class="headerlink" title="三、运行微服务"></a>三、运行微服务</h2><h3 id="3-1-修改-stats-yml"><a href="#3-1-修改-stats-yml" class="headerlink" title="3.1 修改 stats.yml"></a>3.1 修改 stats.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> docker-compose/services</span><br><span class="line">nano stats.yml</span><br></pre></td></tr></table></figure><p>将 <code>stats.yml</code> 文件的第 <strong>49</strong> 行改为自己的 <code>postgresql</code> 数据库，将 localhost 改为本机 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#STATS__BLOCKSCOUT_DB_URL=$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://blockscout:ceWb1MeLBEeOIfk65gU8EjF8@db:5432/blockscout&#125;</span></span><br><span class="line"></span><br><span class="line">STATS__BLOCKSCOUT_DB_URL=<span class="variable">$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://YOUR_DBUSER_NAME:YourSecurePassword@YourIPADDR:5432/blockscout&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-修改-user-ops-indexer-yml"><a href="#3-2-修改-user-ops-indexer-yml" class="headerlink" title="3.2 修改 user-ops-indexer.yml"></a>3.2 修改 user-ops-indexer.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano user-ops-indexer.yml</span><br></pre></td></tr></table></figure><p>修改 <code>user-ops-indexer.yml</code> 文件的第 <strong>15</strong> 和 <strong>16</strong> 行，替换自己的 <code>postgresql</code> 数据库和本机 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># USER_OPS_INDEXER__INDEXER__RPC_URL=$&#123;USER_OPS_INDEXER__INDEXER__RPC_URL:ws://host.docker.internal:8545/&#125;</span></span><br><span class="line"><span class="comment"># USER_OPS_INDEXER__DATABASE__CONNECT__URL=$&#123;USER_OPS_INDEXER__DATABASE__CONNECT__URL:postgresql://blockscout:ceWb1MeLBEeOIfk65gU8EjF8@db:5432/blockscout&#125;</span></span><br><span class="line"></span><br><span class="line">USER_OPS_INDEXER__INDEXER__RPC_URL=<span class="variable">$&#123;USER_OPS_INDEXER__INDEXER__RPC_URL:-ws://YourIPADDR:8546/&#125;</span></span><br><span class="line">STATS__BLOCKSCOUT_DB_URL=<span class="variable">$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://YOUR_DBUSER_NAME:YourSecurePassword@YourIPADDR:5432/blockscout&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-删除-explorer-conf-template"><a href="#3-3-删除-explorer-conf-template" class="headerlink" title="3.3 删除 explorer.conf.template"></a>3.3 删除 explorer.conf.template</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../proxy</span><br><span class="line"><span class="built_in">mv</span> explorer.conf.template explorer.conf.template.backup</span><br></pre></td></tr></table></figure><h3 id="3-4-修改-common-stats-yml"><a href="#3-4-修改-common-stats-yml" class="headerlink" title="3.4 修改 common-stats.yml"></a>3.4 修改 common-stats.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../envs</span><br><span class="line">nano common-stats.env</span><br></pre></td></tr></table></figure><p>将 <code>common-stats.yml</code> 的第 <strong>29</strong> 行修改为自己的后端服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># STATS__BLOCKSCOUT_API_URL=http://host.docker.internal</span></span><br><span class="line">STATS__BLOCKSCOUT_API_URL=http://YourIPADDR:4000</span><br></pre></td></tr></table></figure><h3 id="3-5-启动内置微服务"><a href="#3-5-启动内置微服务" class="headerlink" title="3.5 启动内置微服务"></a>3.5 启动内置微服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">docker-compose -f microservices.yml up -d</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>此时如果 <code>layer2</code> 是启动状态，所有微服务都应该启动成功，如果失败查看 logs <code>docker logs ServiceName</code></p><p><img src="/images/2025/microservice.png" alt="microservice"></p><h3 id="3-6-启动后端服务"><a href="#3-6-启动后端服务" class="headerlink" title="3.6 启动后端服务"></a>3.6 启动后端服务</h3><p>返回 <code>blockscout-backend</code> 根目录并启动 Phoenix 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/blockscout/backend/</span><br><span class="line">mix phx.server</span><br></pre></td></tr></table></figure><p>后端应运行在 <code>http://localhost:4000</code>（或配置的域名）</p><p><img src="/images/2025/backend.png" alt="backend"></p><h2 id="四、构建-Blockscout-Frontend"><a href="#四、构建-Blockscout-Frontend" class="headerlink" title="四、构建 Blockscout Frontend"></a>四、构建 Blockscout Frontend</h2><h3 id="4-1-克隆-Blockscout-Frontend-仓库"><a href="#4-1-克隆-Blockscout-Frontend-仓库" class="headerlink" title="4.1 克隆 Blockscout Frontend 仓库"></a>4.1 克隆 Blockscout Frontend 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 blockscout frontend 并切换到最新 release 分支</span></span><br><span class="line"><span class="built_in">cd</span> ~/blockscout</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/blockscout/frontend.git frontend</span><br><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">git checkout v2.3.2 -b v2.3.2</span><br></pre></td></tr></table></figure><p>在 <code>frontend</code> 目录下新建 <code>.tool-versions</code> 文件并写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodejs 22.11.0</span><br></pre></td></tr></table></figure><h3 id="4-2-在-configs-envs-与根目录下分别创建-env-namepreset-和-env-文件"><a href="#4-2-在-configs-envs-与根目录下分别创建-env-namepreset-和-env-文件" class="headerlink" title="4.2 在 configs&#x2F;envs 与根目录下分别创建 .env.namepreset 和 .env 文件"></a>4.2 在 configs&#x2F;envs 与根目录下分别创建 .env.namepreset 和 .env 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用基础配置</span></span><br><span class="line">NEXT_PUBLIC_APP_HOST=localhost</span><br><span class="line">NEXT_PUBLIC_APP_PORT=3000</span><br><span class="line">NEXT_PUBLIC_APP_INSTANCE=localhost</span><br><span class="line">NEXT_PUBLIC_APP_ENV=development</span><br><span class="line"></span><br><span class="line">NEXT_PUBLIC_API_HOST=localhost</span><br><span class="line">NEXT_PUBLIC_API_PORT=4000</span><br><span class="line">NEXT_PUBLIC_API_PROTOCOL=http</span><br><span class="line">NEXT_PUBLIC_API_WEBSOCKET_PROTOCOL=<span class="string">&#x27;ws&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务配置</span></span><br><span class="line">NEXT_PUBLIC_STATS_API_HOST=http://localhost:8080</span><br><span class="line">NEXT_PUBLIC_VISUALIZE_API_HOST=http://localhost:8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首页内容配置</span></span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_CHARTS=[<span class="string">&#x27;daily_txs&#x27;</span>, <span class="string">&#x27;coin_price&#x27;</span>, <span class="string">&#x27;market_cap&#x27;</span>]</span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_HERO_BANNER_CONFIG=&#123;<span class="string">&quot;background&quot;</span>:[<span class="string">&quot;rgba(27, 74, 221, 1)&quot;</span>]&#125;</span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_STATS=[<span class="string">&#x27;total_blocks&#x27;</span>,<span class="string">&#x27;average_block_time&#x27;</span>,<span class="string">&#x27;total_txs&#x27;</span>,<span class="string">&#x27;wallet_addresses&#x27;</span>,<span class="string">&#x27;gas_tracker&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广告配置</span></span><br><span class="line">NEXT_PUBLIC_AD_BANNER_PROVIDER=none</span><br><span class="line">NEXT_PUBLIC_AD_TEXT_PROVIDER=none</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区块链网络配置</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_NAME=<span class="string">&quot;YangFan&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_ID=L2_CHAIN_ID</span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_NAME=<span class="string">&quot;Sepolia ETH&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_SYMBOL=<span class="string">&quot;ETH&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_DECIMALS=18</span><br></pre></td></tr></table></figure><h3 id="4-3-启动前端服务"><a href="#4-3-启动前端服务" class="headerlink" title="4.3 启动前端服务"></a>4.3 启动前端服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装项目依赖并启动前端调试</span></span><br><span class="line">yarn install</span><br><span class="line">yarn dev:preset namepreset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试完成后启动服务</span></span><br><span class="line">yarn build</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>后端应运行在 <code>http://localhost:3000</code>（或配置的域名）</p><p><img src="/images/2025/frontend.png" alt="frontend"></p><p><strong>Hooray！Blockscout 部署成功！！！</strong></p><h2 id="五、故障排查"><a href="#五、故障排查" class="headerlink" title="五、故障排查"></a>五、故障排查</h2><h3 id="5-1-数据库最大连接数限制"><a href="#5-1-数据库最大连接数限制" class="headerlink" title="5.1 数据库最大连接数限制"></a>5.1 数据库最大连接数限制</h3><p><code>PostgreSQL</code> 的默认最大连接数（max_connections）通常为 <strong>100</strong>，Blockscout 后端和多个微服务会创建大量数据库连接，占用了所有可用连接槽。此时会遇到：<code>FATAL: sorry, too many clients already</code> 之类的错误，此时需要修改数据库默认最大连接数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postgresql/*/main/postgresql.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections = 500</span><br></pre></td></tr></table></figure><p>更改后需要重启 <code>PostgreSQL</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart postgresql</span><br></pre></td></tr></table></figure><h3 id="5-2-JavaScript-heap-out-of-memory"><a href="#5-2-JavaScript-heap-out-of-memory" class="headerlink" title="5.2 JavaScript heap out of memory"></a>5.2 JavaScript heap out of memory</h3><p><code>yarn build</code> 时可能会遇到 <code>JavaScript</code> 内存溢出，此时需要加载环境变量 <code>NODE_OPTIONS</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_OPTIONS=<span class="string">&quot;--max-old-space-size=4096&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-后端连接数据库失败"><a href="#5-3-后端连接数据库失败" class="headerlink" title="5.3 后端连接数据库失败"></a>5.3 后端连接数据库失败</h3><p>在用户名和密码都正确的前提下数据库连接失败，可能时因为 <code>PostgreSQL</code> 数据库的认证配置限制了密码认证方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postgresql/17/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>在 <code># IPv4 local connections:</code>下添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             0.0.0.0/0               scram-sha-256</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Blockscout 官方文档: <a href="https://docs.blockscout.com/setup/deployment/manual-deployment-guide">https://docs.blockscout.com/setup/deployment/manual-deployment-guide</a></li><li>前端仓库: <a href="https://github.com/blockscout/frontend">https://github.com/blockscout/frontend</a></li><li>后端仓库: <a href="https://github.com/blockscout/blockscout">https://github.com/blockscout/blockscout</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Blockscout </tag>
            
            <tag> Layer2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— OP Stack 部署指南</title>
      <link href="/2025/09/15/op-stack-deployment-part1/"/>
      <url>/2025/09/15/op-stack-deployment-part1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OP Stack 是 Optimism 开发的模块化区块链技术栈，允许开发者轻松创建自己的 Layer2 网络。本指南提供了在 Ubuntu 环境下从零开始搭建一个完整的 Layer2 网络，包括环境配置、合约部署、节点启动和基本操作验证。</p><h2 id="一、准备系统环境"><a href="#一、准备系统环境" class="headerlink" title="一、准备系统环境"></a>一、准备系统环境</h2><h3 id="1-1-安装-Ubuntu"><a href="#1-1-安装-Ubuntu" class="headerlink" title="1.1 安装 Ubuntu"></a>1.1 安装 Ubuntu</h3><p>打开 Windows PowerShell 终端</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用的 Ubuntu 发行版</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的 Ubuntu</span></span><br><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> Ubuntu<span class="literal">-24</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><h3 id="1-2-安装软件依赖"><a href="#1-2-安装软件依赖" class="headerlink" title="1.2 安装软件依赖"></a>1.2 安装软件依赖</h3><p>打开 Ubuntu-24.04 子系统（在安装 pnpm 和 mise 时，需修改自己环境变量加载的路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y curl wget git build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 go</span></span><br><span class="line">wget https://go.dev/dl/go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local -xzf go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">rm</span> go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n# Go Language\nexport PATH=$PATH:/usr/local/go/bin&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 node.js</span></span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_22.x | <span class="built_in">sudo</span> -E bash -</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 pnpm</span></span><br><span class="line">curl -fsSL https://get.pnpm.io/install.sh | sh</span><br><span class="line"><span class="built_in">source</span> /home/eth/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 foundry</span></span><br><span class="line">curl -L https://foundry.paradigm.xyz | bash</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">~/.foundry/bin/foundryup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 make</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 jq</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y jq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 direnv</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y direnv</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n# Direnv hook\neval &quot;$(direnv hook bash)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 just</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br><span class="line">. <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span></span><br><span class="line">cargo install just</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 mise</span></span><br><span class="line">curl https://mise.run | sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;eval \&quot;\$(/home/eth/.local/bin/mise activate bash)\&quot;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="1-3-验证安装"><a href="#1-3-验证安装" class="headerlink" title="1.3 验证安装"></a>1.3 验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查所需软件依赖是否正确安装</span></span><br><span class="line">git --version<span class="comment"># git version 2.43.0</span></span><br><span class="line">go version        <span class="comment"># go version go1.25.0 linux/amd64</span></span><br><span class="line">node --version <span class="comment"># v22.19.0</span></span><br><span class="line">pnpm --version<span class="comment"># 10.16.1</span></span><br><span class="line">forge --version<span class="comment"># forge Version: 1.3.5-stable</span></span><br><span class="line">make --version<span class="comment"># GNU Make 4.3</span></span><br><span class="line">jq --version<span class="comment"># jq-1.7</span></span><br><span class="line">direnv --version<span class="comment"># 2.32.1</span></span><br><span class="line">rustc --version<span class="comment"># rustc 1.89.0 (29483883e 2025-08-04)</span></span><br><span class="line">just --version<span class="comment"># just 1.42.4</span></span><br><span class="line">mise --version<span class="comment"># 2025.9.10 linux-x64 (2025-09-13)</span></span><br></pre></td></tr></table></figure><h2 id="二、获取-Sepolia-测试网资源"><a href="#二、获取-Sepolia-测试网资源" class="headerlink" title="二、获取 Sepolia 测试网资源"></a>二、获取 Sepolia 测试网资源</h2><h3 id="2-1-获取-Sepolia-RPC-URL"><a href="#2-1-获取-Sepolia-RPC-URL" class="headerlink" title="2.1 获取 Sepolia RPC URL"></a>2.1 获取 Sepolia RPC URL</h3><p>从以下服务之一获取 Sepolia RPC URL:</p><ul><li><a href="https://www.alchemy.com/">Alchemy</a>（推荐）</li><li><a href="https://www.quicknode.com/">QuickNode</a></li><li><a href="https://zan.top/">ZAN</a></li></ul><h3 id="2-2-获取测试-ETH"><a href="#2-2-获取测试-ETH" class="headerlink" title="2.2 获取测试 ETH"></a>2.2 获取测试 ETH</h3><p>在以下链接中获取测试币 SepoliaETH。</p><ul><li><a href="https://console.optimism.io/faucet">Superchain Faucet</a></li><li><a href="https://cloud.google.com/application/web3/faucet/ethereum/sepolia">Google Ethereum Sepolia Faucet</a></li><li><a href="https://www.alchemy.com/faucets/ethereum-sepolia">Alchemy Ethereum Sepolia Faucet</a></li></ul><h2 id="三、构建-OP-Stack-组件"><a href="#三、构建-OP-Stack-组件" class="headerlink" title="三、构建 OP-Stack 组件"></a>三、构建 OP-Stack 组件</h2><h3 id="3-1-克隆-optimism-和-op-geth-仓库"><a href="#3-1-克隆-optimism-和-op-geth-仓库" class="headerlink" title="3.1 克隆 optimism 和 op-geth 仓库"></a>3.1 克隆 optimism 和 op-geth 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 optimism 并切换到最新 release 分支</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum-optimism/optimism.git</span><br><span class="line"><span class="built_in">cd</span> optimism</span><br><span class="line">git checkout v1.13.6 -b v1.13.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 op-geth 到 optimism 目录下并切换到最新 release 分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum-optimism/op-geth.git</span><br><span class="line"><span class="built_in">cd</span> op-geth</span><br><span class="line">git checkout v1.101602.0 -b v1.101602.0</span><br></pre></td></tr></table></figure><h3 id="3-2-构建-op-geth，op-node，op-batcher，op-proposer"><a href="#3-2-构建-op-geth，op-node，op-batcher，op-proposer" class="headerlink" title="3.2 构建 op-geth，op-node，op-batcher，op-proposer"></a>3.2 构建 op-geth，op-node，op-batcher，op-proposer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-geth</span><br><span class="line">make geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">make op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查组件是否构建成功</span></span><br><span class="line">./op-geth/build/bin/geth --version</span><br><span class="line">./op-node/bin/op-node --version</span><br><span class="line">./op-batcher/bin/op-batcher --version</span><br><span class="line">./op-proposer/bin/op-proposer --version</span><br></pre></td></tr></table></figure><h2 id="四、配置环境变量"><a href="#四、配置环境变量" class="headerlink" title="四、配置环境变量"></a>四、配置环境变量</h2><h3 id="4-1-生成账户"><a href="#4-1-生成账户" class="headerlink" title="4.1 生成账户"></a>4.1 生成账户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism</span><br><span class="line">./packages/contracts-bedrock/scripts/getting-started/wallets.sh</span><br></pre></td></tr></table></figure><p>此命令会生成五个地址及其私钥：</p><ul><li><code>Admin</code>（管理员）</li><li><code>Batcher</code>（批处理者）</li><li><code>Proposer</code>（提议者）</li><li><code>Sequencer</code>（排序者）</li><li><code>Challenger</code>（挑战者）</li></ul><h3 id="4-2-编辑环境变量文件"><a href="#4-2-编辑环境变量文件" class="headerlink" title="4.2 编辑环境变量文件"></a>4.2 编辑环境变量文件</h3><p>创建<code>.envrc</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano .envrc</span><br></pre></td></tr></table></figure><p>填写以下变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Admin account</span></span><br><span class="line"><span class="built_in">export</span> GS_ADMIN_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_ADMIN_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Batcher account</span></span><br><span class="line"><span class="built_in">export</span> GS_BATCHER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_BATCHER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Proposer account</span></span><br><span class="line"><span class="built_in">export</span> GS_PROPOSER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_PROPOSER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sequencer account</span></span><br><span class="line"><span class="built_in">export</span> GS_SEQUENCER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_SEQUENCER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Challenger account</span></span><br><span class="line"><span class="built_in">export</span> GS_CHALLENGER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_CHALLENGER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment">#            Layer1 RPC Configuration            #</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RPC URL for the L1 network to interact with</span></span><br><span class="line"><span class="built_in">export</span> L1_RPC_URL=</span><br><span class="line"><span class="built_in">export</span> L1_BEACON_URL=<span class="string">&quot;https://ethereum-sepolia-beacon-api.publicnode.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The kind of RPC provider, used to inform optimal transactions receipts</span></span><br><span class="line"><span class="comment"># fetching. Valid options: alchemy, quicknode, infura, parity, nethermind,</span></span><br><span class="line"><span class="comment"># debug_geth, erigon, basic, any.</span></span><br><span class="line"><span class="built_in">export</span> L1_RPC_KIND=</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment">#               Chain Configuration              #</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The unique chain ID of the Layer 1 network(e.g., Sepolia = 11155111)</span></span><br><span class="line"><span class="built_in">export</span> L1_CHAIN_ID=11155111</span><br><span class="line"><span class="comment"># The unique chain ID you assign to your Layer 2 network (custom value)</span></span><br><span class="line"><span class="built_in">export</span> L2_CHAIN_ID=</span><br><span class="line"><span class="comment"># The average block time of the Layer 1 network (in seconds)</span></span><br><span class="line"><span class="built_in">export</span> L1_BLOCK_TIME=12</span><br><span class="line"><span class="comment"># The block time you configure for your Layer 2 network (in seconds)</span></span><br><span class="line"><span class="built_in">export</span> L2_BLOCK_TIME=2</span><br></pre></td></tr></table></figure><p>保存文件(Ctrl+O, Enter, Ctrl+X)</p><h3 id="4-3-加载环境变量"><a href="#4-3-加载环境变量" class="headerlink" title="4.3 加载环境变量"></a>4.3 加载环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direnv allow</span><br></pre></td></tr></table></figure><p>验证环境变量是否加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 环境变量检查 ===&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_ADMIN_ADDRESS: <span class="variable">$GS_ADMIN_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_BATCHER_ADDRESS: <span class="variable">$GS_BATCHER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_PROPOSER_ADDRESS: <span class="variable">$GS_PROPOSER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_SEQUENCER_ADDRESS: <span class="variable">$GS_SEQUENCER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_CHALLENGER_ADDRESS: <span class="variable">$GS_CHALLENGER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_RPC_KIND: <span class="variable">$L1_RPC_KIND</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_RPC_URL: <span class="variable">$L1_RPC_URL</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_BEACON_URL: <span class="variable">$L1_BEACON_URL</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_CHAIN_ID: <span class="variable">$L1_CHAIN_ID</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L2_CHAIN_ID: <span class="variable">$L2_CHAIN_ID</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_BLOCK_TIME: <span class="variable">$L1_BLOCK_TIME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L2_BLOCK_TIME: <span class="variable">$L2_BLOCK_TIME</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-为账户充值"><a href="#4-4-为账户充值" class="headerlink" title="4.4 为账户充值"></a>4.4 为账户充值</h3><p>为以下地址充值 SepoliaETH：</p><ul><li><code>Admin</code> — 0.5 SepoliaETH</li><li><code>Batcher</code> — 0.1 SepoliaETH</li><li><code>Proposer</code> — 0.2 SepoliaETH</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看账户余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_PROPOSER_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br></pre></td></tr></table></figure><h2 id="五、部署-L1-合约"><a href="#五、部署-L1-合约" class="headerlink" title="五、部署 L1 合约"></a>五、部署 L1 合约</h2><h3 id="5-1-获取-op-deployer"><a href="#5-1-获取-op-deployer" class="headerlink" title="5.1 获取 op-deployer"></a>5.1 获取 op-deployer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism</span><br><span class="line"><span class="built_in">mkdir</span> -p bin</span><br><span class="line">wget https://github.com/ethereum-optimism/optimism/releases/download/op-deployer%2Fv0.2.6/op-deployer-0.2.6-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -C ./bin -xzf op-deployer-0.2.6-linux-amd64.tar.gz --strip-components=1</span><br><span class="line"><span class="built_in">rm</span> op-deployer-0.2.6-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否下载解压成功</span></span><br><span class="line">./bin/op-deployer --version</span><br></pre></td></tr></table></figure><h3 id="5-2-初始化-op-deployer-配置"><a href="#5-2-初始化-op-deployer-配置" class="headerlink" title="5.2 初始化 op-deployer 配置"></a>5.2 初始化 op-deployer 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.deployer</span><br><span class="line">./bin/op-deployer init --l1-chain-id <span class="variable">$L1_CHAIN_ID</span> --l2-chain-ids <span class="variable">$L2_CHAIN_ID</span> --workdir .deployer</span><br></pre></td></tr></table></figure><p>此命令会生成 <code>intend.json</code> 和 <code>state.json</code></p><h3 id="5-3-修改-intend-json-配置"><a href="#5-3-修改-intend-json-配置" class="headerlink" title="5.3 修改 intend.json 配置"></a>5.3 修改 intend.json 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano .deployer/intent.toml</span><br></pre></td></tr></table></figure><p>确保配置中包含以下内容并替换相应的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">configType = <span class="string">&quot;standard&quot;</span></span><br><span class="line">l1ChainID = 11155111</span><br><span class="line">opcmAddress = <span class="string">&quot;0x6b6f9129efb1b7a48f84e3b787333d1dca02ee34&quot;</span><span class="comment"># L1 上的 OP Chain Manager 合约地址</span></span><br><span class="line">fundDevAccounts = <span class="literal">false</span></span><br><span class="line">useInterop = <span class="literal">false</span></span><br><span class="line">l1ContractsLocator = <span class="string">&quot;tag://op-contracts/v2.2.0&quot;</span></span><br><span class="line">l2ContractsLocator = <span class="string">&quot;tag://op-contracts/v1.7.0-beta.1+l2-contracts&quot;</span></span><br><span class="line"></span><br><span class="line">[[chains]]</span><br><span class="line">  <span class="built_in">id</span> = <span class="string">&quot;0x00000000000000000000000000000000000000000000000000000000004f5da2&quot;</span><span class="comment"># L2_CHAIN_ID 的十六进制</span></span><br><span class="line">  baseFeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  l1FeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  sequencerFeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  eip1559DenominatorCanyon = 250</span><br><span class="line">  eip1559Denominator = 50</span><br><span class="line">  eip1559Elasticity = 6</span><br><span class="line">  [chains.roles]</span><br><span class="line">    l1ProxyAdminOwner = <span class="string">&quot;0x1eb2ffc903729a0f03966b917003800b145f56e2&quot;</span></span><br><span class="line">    l2ProxyAdminOwner = <span class="string">&quot;0x2fc3ffc903729a0f03966b917003800b145f67f3&quot;</span></span><br><span class="line">    systemConfigOwner = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">    unsafeBlockSigner = <span class="string">&quot;YOUR_SEQUENCER_ADDRESS&quot;</span></span><br><span class="line">    batcher = <span class="string">&quot;YOUR_BATCHER_ADDRESS&quot;</span></span><br><span class="line">    proposer = <span class="string">&quot;YOUR_PROPOSER_ADDRESS&quot;</span></span><br><span class="line">    challenger = <span class="string">&quot;0xfd1d2e729ae8eee2e146c033bf4400fe75284301&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-部署-L1-合约"><a href="#5-4-部署-L1-合约" class="headerlink" title="5.4 部署 L1 合约"></a>5.4 部署 L1 合约</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询 L1 gas fee，判断 L1 RPC 是否连接成功</span></span><br><span class="line">cast gas-price --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署合约</span></span><br><span class="line">./bin/op-deployer apply --workdir .deployer --l1-rpc-url <span class="variable">$L1_RPC_URL</span> --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span></span><br></pre></td></tr></table></figure><h3 id="5-5-生成-L2-配置文件"><a href="#5-5-生成-L2-配置文件" class="headerlink" title="5.5 生成 L2 配置文件"></a>5.5 生成 L2 配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 genesis.json（用于 op-geth）</span></span><br><span class="line">./bin/op-deployer inspect genesis --workdir .deployer <span class="variable">$L2_CHAIN_ID</span> &gt; .deployer/genesis.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 rollup.json（用于 op-node）</span></span><br><span class="line">./bin/op-deployer inspect rollup --workdir .deployer <span class="variable">$L2_CHAIN_ID</span> &gt; .deployer/rollup.json</span><br></pre></td></tr></table></figure><h2 id="六、启动-Layer2"><a href="#六、启动-Layer2" class="headerlink" title="六、启动 Layer2"></a>六、启动 Layer2</h2><h3 id="6-1-初始化并启动-op-geth"><a href="#6-1-初始化并启动-op-geth" class="headerlink" title="6.1 初始化并启动 op-geth"></a>6.1 初始化并启动 op-geth</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 jwt 密钥用于 op-geth 与 op-node 通信</span></span><br><span class="line"><span class="built_in">cd</span> ~/optimism/op-geth</span><br><span class="line">openssl rand -hex 32 &gt; jwt.txt</span><br><span class="line"><span class="built_in">cp</span> jwt.txt ../op-node/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 op-geth</span></span><br><span class="line"><span class="built_in">mkdir</span> -p datadir</span><br><span class="line">build/bin/geth init --state.scheme=<span class="built_in">hash</span> --datadir=datadir ../.deployer/genesis.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 op-geth</span></span><br><span class="line">./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="6-2-启动-op-node"><a href="#6-2-启动-op-node" class="headerlink" title="6.2 启动 op-node"></a>6.2 启动 op-node</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-node</span><br><span class="line"></span><br><span class="line">./bin/op-node \</span><br><span class="line">--l2=http://localhost:8551 \</span><br><span class="line">--l2.jwt-secret=./jwt.txt \</span><br><span class="line">--sequencer.enabled \</span><br><span class="line">--sequencer.l1-confs=5 \</span><br><span class="line">--verifier.l1-confs=4 \</span><br><span class="line">--rollup.config=../.deployer/rollup.json \</span><br><span class="line">--rpc.addr=0.0.0.0 \</span><br><span class="line">--rpc.port=9545 \</span><br><span class="line">--p2p.disable \</span><br><span class="line">--rpc.enable-admin \</span><br><span class="line">--p2p.sequencer.key=<span class="variable">$GS_SEQUENCER_PRIVATE_KEY</span> \</span><br><span class="line">--l1=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">--l1.rpckind=<span class="variable">$L1_RPC_KIND</span> \</span><br><span class="line">--l1.beacon=<span class="variable">$L1_BEACON_URL</span></span><br></pre></td></tr></table></figure><h3 id="6-3-启动-op-batcher"><a href="#6-3-启动-op-batcher" class="headerlink" title="6.3 启动 op-batcher"></a>6.3 启动 op-batcher</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-batcher</span><br><span class="line"></span><br><span class="line">./bin/op-batcher \</span><br><span class="line">--l2-eth-rpc=http://localhost:8545 \</span><br><span class="line">--rollup-rpc=http://localhost:9545 \</span><br><span class="line">--poll-interval=1s \</span><br><span class="line">--sub-safety-margin=6 \</span><br><span class="line">--num-confirmations=1 \</span><br><span class="line">--safe-abort-nonce-too-low-count=3 \</span><br><span class="line">--resubmission-timeout=30s \</span><br><span class="line">--rpc.addr=0.0.0.0 \</span><br><span class="line">--rpc.port=8548 \</span><br><span class="line">--rpc.enable-admin \</span><br><span class="line">--max-channel-duration=25 \</span><br><span class="line">--l1-eth-rpc=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">--private-key=<span class="variable">$GS_BATCHER_PRIVATE_KEY</span></span><br></pre></td></tr></table></figure><h3 id="6-4-启动-op-proposer"><a href="#6-4-启动-op-proposer" class="headerlink" title="6.4 启动 op-proposer"></a>6.4 启动 op-proposer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 op-proposer 配置变量（也可加到 .envrc 里面）</span></span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_WAIT_NODE_SYNC=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_PROPOSAL_INTERVAL=15m</span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_GAME_FACTORY_ADDRESS=$(<span class="built_in">cat</span> ~/.deployer/state.json | jq -r <span class="string">&#x27;.opChainDeployments[0].disputeGameFactoryProxyAddress&#x27;</span>)</span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_GAME_TYPE=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/optimism/op-proposer</span><br><span class="line"></span><br><span class="line">./bin/op-proposer \</span><br><span class="line">  --poll-interval=12s \</span><br><span class="line">  --rpc.port=8560 \</span><br><span class="line">  --rollup-rpc=http://localhost:9545 \</span><br><span class="line">  --private-key=<span class="variable">$GS_PROPOSER_PRIVATE_KEY</span> \</span><br><span class="line">  --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span></span><br></pre></td></tr></table></figure><h2 id="七、验证部署"><a href="#七、验证部署" class="headerlink" title="七、验证部署"></a>七、验证部署</h2><h3 id="7-1-检查-L2-链状态"><a href="#7-1-检查-L2-链状态" class="headerlink" title="7.1 检查 L2 链状态"></a>7.1 检查 L2 链状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  --data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_blockNumber&quot;,&quot;params&quot;:[],&quot;id&quot;:1&#125;&#x27;</span> \</span><br><span class="line">  <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="7-2-连接钱包到-Layer2"><a href="#7-2-连接钱包到-Layer2" class="headerlink" title="7.2 连接钱包到 Layer2"></a>7.2 连接钱包到 Layer2</h3><p>在 MetaMask 中添加自定义网络：</p><ul><li>网络名称：OP Stack Rollup</li><li>RPC URL：<a href="http://localhost:8545/">http://localhost:8545</a></li><li>链 ID：L2_CHAIN_ID</li><li>符号：ETH</li></ul><h3 id="7-3-将-SepoliaETH-发送到-Bridge-合约"><a href="#7-3-将-SepoliaETH-发送到-Bridge-合约" class="headerlink" title="7.3 将 SepoliaETH 发送到 Bridge 合约"></a>7.3 将 SepoliaETH 发送到 Bridge 合约</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 L1StandardBridge 地址</span></span><br><span class="line">L1StandardBridge=$(<span class="built_in">cat</span> ~/optimism/.deployer/state.json | jq -r <span class="string">&#x27;.opChainDeployments[0].l1StandardBridgeProxyAddress&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1StandardBridge 地址: <span class="variable">$L1StandardBridge</span>&quot;</span></span><br></pre></td></tr></table></figure><p>通过 Metamask 向你的 <strong>桥接地址</strong> 发送(0.0001 SepoliaETH)，发送成功后大约需要 5 分钟才能在 Layer2 上看到 ETH.</p><p><strong>Hooray！Op Stack 部署成功！！！</strong></p><h2 id="八、基本转账-CLI-操作实例"><a href="#八、基本转账-CLI-操作实例" class="headerlink" title="八、基本转账 CLI 操作实例"></a>八、基本转账 CLI 操作实例</h2><h3 id="8-1-从-L1-的-Admin-桥接到-L2-的-admin"><a href="#8-1-从-L1-的-Admin-桥接到-L2-的-admin" class="headerlink" title="8.1 从 L1 的 Admin 桥接到 L2 的 admin"></a>8.1 从 L1 的 Admin 桥接到 L2 的 admin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cast send <span class="variable">$L1StandardBridge</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.0001ether \</span><br><span class="line">  <span class="string">&quot;depositETH(uint32,bytes)&quot;</span> \</span><br><span class="line">  200000 \</span><br><span class="line">  <span class="string">&quot;0x&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L1 和 L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="8-2-从-L1-的-Admin-桥接到-L2-的-Batcher"><a href="#8-2-从-L1-的-Admin-桥接到-L2-的-Batcher" class="headerlink" title="8.2 从 L1 的 Admin 桥接到 L2 的 Batcher"></a>8.2 从 L1 的 Admin 桥接到 L2 的 Batcher</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cast send <span class="variable">$L1StandardBridge</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.0001ether \</span><br><span class="line">  <span class="string">&quot;depositETHTo(address,uint32,bytes)&quot;</span> \</span><br><span class="line">  <span class="variable">$GS_BATCHER_ADDRESS</span> \</span><br><span class="line">  200000 \</span><br><span class="line">  <span class="string">&quot;0x&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L1 和 Batcher L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="8-3-L2-转账"><a href="#8-3-L2-转账" class="headerlink" title="8.3 L2 转账"></a>8.3 L2 转账</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L2 从 Batcher 转账到 Admin</span></span><br><span class="line">cast send <span class="variable">$GS_ADMIN_ADDRESS</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L2_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_BATCHER_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.00001ether</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L2 和 Batcher L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> OPStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢练勤修，别急放松 | 道家武术馆一月清修</title>
      <link href="/2025/02/22/taichi-28/"/>
      <url>/2025/02/22/taichi-28/</url>
      
        <content type="html"><![CDATA[<p>一月上旬读了三本书 ——《36 万遍感恩的奇迹》、《清醒地活》、《内在工程》，这三本书中都有部分篇幅讲述了阴阳哲学，让我对道家文化产生了浓厚兴趣，再次看到之前觉得平平无奇的太极图的第一反应竟然是 —— <em>It is fascinating</em>，刚好今年也有学习太极和养生的计划，然后就报名了武当山道家传统武术馆的养生班，开启了一个月的清修生活。</p><img src="/images/2025/slow_is_fast.jpg" width="70%" alt="Slow is Fast" style="display: block; margin: 0 auto;"><hr><h2 id="武馆日常"><a href="#武馆日常" class="headerlink" title="武馆日常"></a>武馆日常</h2><ul><li>早上 <strong>6:30</strong> 到练功堂共修五行气功</li><li>上午 <strong>9:00</strong> 和下午 <strong>15:00</strong> 的武术课是教练带同学们一起练习大约一小时的基本功<br>（包含柔韧性、耐力、平衡性、协调性、爆发力的训练。这一部分我超级喜欢，有开心快乐的蹦蹦跳跳环节）</li><li>之后到各自教练的带练区域学习或复习自己的功法</li><li>傍晚 <strong>18:30</strong> 有一个小时的静坐课，教练会带大家做几组静态拉伸然后开启禅修模式</li></ul><p>武馆日常伙食清淡，素食者友好，我感觉在武馆待了一个月体表脂肪都厚了一点点。<br>住宿我选的是舒适单人间，我觉得环境很舒适很方便而且下午的时候我的房间可以晒到大太阳，洒进房间的阳光让人心情舒畅~</p><img src="/images/2025/standing.jpg" width="60%" alt="站桩" style="display: block; margin: 0 auto;"><hr><h2 id="阅读与体悟"><a href="#阅读与体悟" class="headerlink" title="阅读与体悟"></a>阅读与体悟</h2><p>在武馆清修期间阅读了五本书，其中两本和武馆修习很搭特别推荐：</p><ul><li>《The Inner Game of Tennis》（中文版是《身心合一的奇迹力量》，武志红老师推荐）和这本书中提及的《箭术与禅心》</li></ul><p>在平日练功的时候我会让自己的大脑安静下来，让自己的注意力放松，不去过度尝试努力，而是有觉知地卸掉多余紧张的力，相信自己的身体并让其自然流动，并在攻与防的招式转换中体验势的变化。</p><p>在这个过程中好像对“消融的自我”也有了一些体悟：</p><ul><li>太极养我的同时我也在养太极</li><li>我在执剑的时候剑也同时在执我</li><li>消融的自我是客与主的转换，在这一瞬似乎都彼此融合，也就再没有区分的需要了</li></ul><img src="/images/2025/daodejing.jpg" width="70%" alt="Dao De Jing" style="display: block; margin: 0 auto;"><hr><h2 id="休息日体验"><a href="#休息日体验" class="headerlink" title="休息日体验"></a>休息日体验</h2><p>除了武馆的修习之外，休息日和结识的伙伴一起解锁了许多体验：</p><ul><li>除夕日从南岩徒步上金顶抽签，刚好抽到的签和这次清修的初心相关，特别喜欢——阴阳道和<br> （如果抽的签不太满意就再抽，出来玩开心最重要）</li></ul><img src="/images/2025/cat.jpg" width="55%" alt="Cat" style="display: block; margin: 0 auto;"><ul><li>去购买修道风练功服</li><li>去体验道家按摩</li><li>去打卡步行街素食餐厅</li><li>去看《武当一梦》和烟花无人机秀等等</li><li>本周三还参加了武馆汇演，刚好是清修最后一天，就算是毕业典礼了</li></ul><img src="/images/2025/dream_of_wudang.jpg" width="70%" alt="One Dream at Wudang" style="display: block; margin: 0 auto;"><hr><h2 id="感恩与前行"><a href="#感恩与前行" class="headerlink" title="感恩与前行"></a>感恩与前行</h2><p>很感恩，很开心，很幸运能够遇见那么多很好的伙伴。<br>分别之际虽有不舍，但大家表达的更多是感谢和祝福，而我也会带着这份感恩的心念继续往前走走~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神圣的静默 | 武夷山东山禅林十日内观</title>
      <link href="/2024/12/12/vipassana/"/>
      <url>/2024/12/12/vipassana/</url>
      
        <content type="html"><![CDATA[<p>在山上度过了十天禁言、与外界信息隔离的出家生活，从观呼吸开始以慈悲观结束。去之前从没想过内观禅修那么难，难在深入敏锐地专注，难在全然平等地接受。</p><hr><h2 id="关于做"><a href="#关于做" class="headerlink" title="关于做"></a>关于做</h2><p><strong>‘The doers are the major thinkers’</strong> ——这是禅修期间每天都会反反复复浮现在脑海中的一句话，然后在第十天的时候脑海浮现了一个中文翻译，感觉还挺贴切——</p><p><strong>“那些真正付出行动去实践他所思所想的人才是真正的思想家”</strong></p><p>现在回想以前很多时候大概是知道该怎么做的，但是由于内心不够强大，在意他人看法，对确定性的过度偏好再加上周围遇到的人事物，经常陷入自我怀疑和自我否定的状态，这种状态反反复复，消耗了本就不多的心力，淹没了本就微弱的心声，导致无法行动。</p><p>可是当我从广泛的阅读中越来越多地感受到，无论是像苏格拉底、庄子、尼采、黑塞这样的智慧先哲，还是像佛陀、克里希那穆提、葛印卡、萨古茹这样的无私古茹，亦或是像芒格、乔布斯、段永平、纳瓦尔这样的当代名人等等，这些自己内心所尊敬的灵魂或榜样在一生中大部分时间都在践行那些基本的价值观和准则。</p><p>当感受到这点后，自己这颗惶恐不安、迷茫无措、心猿意马的心也慢慢变得更平稳、更清晰、更坚定，向前踏出的脚步也多了几分笃定。</p><p>而当我不再仅仅满足于知识上的理解，而是更多地专注于经验上的理解时，根本性的改变也随之自然而然地发生。</p><hr><h2 id="关于真"><a href="#关于真" class="headerlink" title="关于真"></a>关于真</h2><p>今年的某天我突然意识到我和父母和谐的关系存在泡沫之中，这种虚假的和谐是以无意识地接受那些习以为常的违背自身感受的隐性要求为代价。</p><p>这种长期无意识地接受，这种假只会产生无尽的无意识的否定、扭曲、压抑、控制，这种假永远不会带来真正的了解、真正的尊重、真正的关心、真正的责任。</p><p><strong>假无法带来真正的爱，而真正的爱不会带来伤害。</strong></p><p>当意识到这点后，那些曾经以为已经修复的原生家庭创伤又开始频繁地让我陷入愤怒或悲伤式的情绪闪回，时常让我暴躁不安。</p><p>但这次我决定接受这份创伤就是我的一部分这个事实，不再去否定、合理化、压抑或是试图去原谅，只是全然平等地接受，我决心拥抱完整的自己。</p><p>于是我用内观这把手术刀更深地剖析自己的内心，没有恐惧，没有犹豫。因为我很幸运，我找到了心底那处一直缺失的力量。</p><p>当愤怒像熔岩般喷薄而出时，自我保护和自我支持的意愿便会更加强烈；当悲伤像海浪般呼啸而来时，自我同情和自我关怀的心意便会愈发柔软；当愤怒与悲伤彼此碰撞消融，爱就再次开始流动。</p><hr><h2 id="关于自我"><a href="#关于自我" class="headerlink" title="关于自我"></a>关于自我</h2><p>之前一直有听到说我们这一代比较自我，不健康的自我。可是在意尊重自己的感受真的是一种错误吗？</p><p>当我在学习爱自己的道路上越往前走，我越能深刻理解爱的四要素：</p><ul><li><strong>了解</strong></li><li><strong>尊重</strong></li><li><strong>关心</strong></li><li><strong>责任</strong></li></ul><p>都同等重要并相辅相成。</p><p>如果不能尊重自己的感受，则会产生对自己的否定和压抑，而被压抑的感受则会进入潜意识深层难以根除。</p><p>但是后来我突然明白，那些动机是要求别人违背自己感受以满足自己需求，或是只想周围都围着自己转的人，才是不健康的自我，或是说我执。</p><p>健康的自我需要修炼平等心，如果内心有过多的贪爱，必然会有过多的嗔恨，便会带来我执的痛苦。</p><p>而只有健康的自我或是消融的自我，才更有可能发展出创造性倾向的能力。</p><hr><h2 id="关于变化"><a href="#关于变化" class="headerlink" title="关于变化"></a>关于变化</h2><p>此处引用今年阅读《芒格之道》时直接刻在我心底的一句话——</p><p><strong>“变化总在发生，不去主动迎接进步的变化，就会等到退步的变化。”</strong></p><p>无常，无常，无常，既然不确定性是常态，那就与不确定性共舞，继续往前走走~</p><hr><p>培养觉知，练习感恩<br>持续精进，坚定决心！</p><p><img src="/images/2024/vipassana.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25 Today, Halfway to 50 🤭</title>
      <link href="/2024/01/15/happy-birthday/"/>
      <url>/2024/01/15/happy-birthday/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2024/happy_birthday.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Dialogue with Myself</title>
      <link href="/2023/12/31/2023/"/>
      <url>/2023/12/31/2023/</url>
      
        <content type="html"><![CDATA[<div align="center"><p><strong>2023 年的每一个月、每一周都有一点点不一样</strong><br>某一天，我做了一个小小的改变，从那之后，<strong>每一天</strong>也随之焕然一新<br>因为在喜欢我的人里，多了一位很重要的人 —— <strong>我自己</strong></p><p><em>Just a little change can make all the difference.</em></p><hr><p>当我决定喜欢我自己<br>我开始记录下我每天做得不错的地方<br>以及那些让我开心的事情</p><p>某一天，在日常记录中，我恍然大悟 ——<br>噢，原来这就是 <strong>「具体」</strong></p><hr><p>当内耗与模糊渐渐消散<br>当我开始拥抱所有的感受<br>当我的状态变得越来越好时<br>某一天，我突然明白了《当我开始真正爱自己》这首诗中<br>“<strong>「真正」</strong>”这一词的含义</p><p>那一刻，我知道自己也真正<br>习得了喜欢与爱的能力<br>当然现在还不够有力<br>仍在积蓄力量中~</p><hr><h3 id="✨-My-Vision-for-2024"><a href="#✨-My-Vision-for-2024" class="headerlink" title="✨ My Vision for 2024"></a>✨ My Vision for 2024</h3><p><strong>继续践行长期主义</strong><br><strong>每过完一天，要努力比早上醒来时更聪明一点点</strong><br><strong>培养理性 · 保持好奇 · 珍惜日常</strong> 🌻</p><img src="/images/2023/hello_2024.jpg" width="85%" alt="hello, 2024"></div>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortunate to Cross Paths</title>
      <link href="/2023/12/17/fortunate_to_cross_paths/"/>
      <url>/2023/12/17/fortunate_to_cross_paths/</url>
      
        <content type="html"><![CDATA[<div align="center"><p>原来每段相遇都有一份恩情<br>回望今年走过的路，徒过的步<br>不知不觉大家已经认识这么久了<br>感谢相遇，感谢一路同行 🔆</p></div><img src="/images/2023/companions.jpg" width="85%" alt="companions">]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于人来人往中，不惧离索</title>
      <link href="/2022/12/31/2022/"/>
      <url>/2022/12/31/2022/</url>
      
        <content type="html"><![CDATA[<p>生命是一个淡淡的悲伤的过程，我们要不断地和过去告别，和很多事物告别</p><p>既然现实就是为了分别而相遇，那希望在今后的日子里，能够勇敢去爱，在所有的相遇中不断朝着＂最佳分别＂而努力，直到生命的最后一天</p><p>也希望未来的自己，内心能如水一般，变得更柔软、更包容、更平静~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
