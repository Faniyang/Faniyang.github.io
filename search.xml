<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Raydium Swap —— Config</title>
      <link href="/2025/10/11/raydium-swap-config/"/>
      <url>/2025/10/11/raydium-swap-config/</url>
      
        <content type="html"><![CDATA[<p>在 Raydium Swap 系统中，<strong>Config</strong> 是全局配置中心，用于统一管理费率参数、权限开关和资金接收地址，是各个流动性池运行的基础控制单元。</p><h2 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h2><h3 id="1-states-config-rs-配置账户数据结构"><a href="#1-states-config-rs-配置账户数据结构" class="headerlink" title="1. states&#x2F;config.rs 配置账户数据结构"></a>1. states&#x2F;config.rs 配置账户数据结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// programs/swap/src/states/config.rs</span></span><br><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> AMM_CONFIG_SEED: &amp;<span class="type">str</span> = <span class="string">&quot;amm_config&quot;</span>; <span class="comment">// AMM 配置账户的种子前缀</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> FEE_RATE_DENOMINATOR_VALUE: <span class="type">u64</span> = <span class="number">1_000_000</span>; <span class="comment">// 费率分母值，所有费率参数都使用这个作为分母</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[account]</span></span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AmmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> bump: <span class="type">u8</span>,                  <span class="comment">// PDA的bump种子</span></span><br><span class="line">    <span class="keyword">pub</span> disable_create_pool: <span class="type">bool</span>, <span class="comment">// 是否禁止创建新池子</span></span><br><span class="line">    <span class="keyword">pub</span> index: <span class="type">u16</span>,                <span class="comment">// 配置索引，用于区分不同配置</span></span><br><span class="line">    <span class="keyword">pub</span> trade_fee_rate: <span class="type">u64</span>,       <span class="comment">// 交易手续费率，单位：百万分之一，例如2500表示0.25%</span></span><br><span class="line">    <span class="keyword">pub</span> protocol_fee_rate: <span class="type">u64</span>,    <span class="comment">// 协议费率，从交易费中抽取的比例，例如200000表示20%</span></span><br><span class="line">    <span class="keyword">pub</span> fund_fee_rate: <span class="type">u64</span>,        <span class="comment">// 基金费率，从交易费中抽取的比例，例如300000表示30%</span></span><br><span class="line">    <span class="keyword">pub</span> create_pool_fee: <span class="type">u64</span>, <span class="comment">// 创建新池子需要支付的费用，单位：lamports，例如1_000_000_000表示1 SOL</span></span><br><span class="line">    <span class="keyword">pub</span> protocol_owner: Pubkey, <span class="comment">// 协议费用接收地址</span></span><br><span class="line">    <span class="keyword">pub</span> fund_owner: Pubkey,   <span class="comment">// 基金费用接收地址</span></span><br><span class="line">    <span class="keyword">pub</span> creator_fee_rate: <span class="type">u64</span>, <span class="comment">// 池子创建者费率，单位：百万分之一，例如5000表示0.5%</span></span><br><span class="line">    <span class="keyword">pub</span> padding: [<span class="type">u64</span>; <span class="number">15</span>],   <span class="comment">// 预留空间，用于未来扩展功能而不需要迁移账户（120字节）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AmmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> LEN: <span class="type">usize</span> = <span class="number">8</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> * <span class="number">8</span> + <span class="number">32</span> * <span class="number">2</span> + <span class="number">8</span> + <span class="number">8</span> * <span class="number">15</span>; <span class="comment">// 账户总大小：236字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-accounts-struct-create-config-account-rs-账户约束"><a href="#2-accounts-struct-create-config-account-rs-账户约束" class="headerlink" title="2. accounts_struct&#x2F;create_config_account.rs - 账户约束"></a>2. accounts_struct&#x2F;create_config_account.rs - 账户约束</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// programs/swap/src/accounts_struct/create_config_account.rs</span></span><br><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::states::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建AMM配置的账户约束</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="meta">#[instruction(index: u16)]</span> <span class="comment">// 从指令参数中获取index，用于生成PDA</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateAmmConfig</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// AMM 配置账户，使用PDA确保每个index只能创建一个配置</span></span><br><span class="line">    <span class="comment">/// Seeds: [&quot;amm_config&quot;, index]</span></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init,  // 初始化新账户</span></span><br><span class="line"><span class="meta">        seeds = [</span></span><br><span class="line"><span class="meta">            AMM_CONFIG_SEED.as_bytes(),  // <span class="string">&quot;amm_config&quot;</span></span></span><br><span class="line"><span class="meta">            &amp;index.to_be_bytes()  // 配置索引</span></span><br><span class="line"><span class="meta">        ]</span>,</span><br><span class="line">        bump,  <span class="comment">// PDA bump，由Anchor自动查找</span></span><br><span class="line">        payer = owner,  <span class="comment">// 支付账户租金的账户</span></span><br><span class="line">        space = AmmConfig::LEN  <span class="comment">// 账户所需空间大小</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> amm_config: Account&lt;<span class="symbol">&#x27;info</span>, AmmConfig&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> owner: Signer&lt;<span class="symbol">&#x27;info</span>&gt;, <span class="comment">// 配置创建者，支付账户租金和交易费用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;, <span class="comment">// Solana系统程序，用于创建账户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-instructions-create-config-rs-指令逻辑"><a href="#3-instructions-create-config-rs-指令逻辑" class="headerlink" title="3. instructions&#x2F;create_config.rs 指令逻辑"></a>3. instructions&#x2F;create_config.rs 指令逻辑</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// programs/swap/src/instructions/create_config.rs</span></span><br><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::ops::DerefMut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::accounts_struct::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_amm_config</span>(</span><br><span class="line">    ctx: Context&lt;CreateAmmConfig&gt;,</span><br><span class="line">    index: <span class="type">u16</span>,</span><br><span class="line">    trade_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    protocol_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    fund_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    create_pool_fee: <span class="type">u64</span>,</span><br><span class="line">    creator_fee_rate: <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amm_config</span> = ctx.accounts.amm_config.<span class="title function_ invoke__">deref_mut</span>();</span><br><span class="line">    amm_config.protocol_owner = ctx.accounts.owner.<span class="title function_ invoke__">key</span>();</span><br><span class="line">    amm_config.bump = ctx.bumps.amm_config;</span><br><span class="line">    amm_config.disable_create_pool = <span class="literal">false</span>;</span><br><span class="line">    amm_config.index = index;</span><br><span class="line">    amm_config.trade_fee_rate = trade_fee_rate;</span><br><span class="line">    amm_config.protocol_fee_rate = protocol_fee_rate;</span><br><span class="line">    amm_config.fund_fee_rate = fund_fee_rate;</span><br><span class="line">    amm_config.create_pool_fee = create_pool_fee;</span><br><span class="line">    amm_config.fund_owner = ctx.accounts.owner.<span class="title function_ invoke__">key</span>();</span><br><span class="line">    amm_config.creator_fee_rate = creator_fee_rate;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-lib-rs-入口函数和参数校验"><a href="#4-lib-rs-入口函数和参数校验" class="headerlink" title="4. lib.rs - 入口函数和参数校验"></a>4. lib.rs - 入口函数和参数校验</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// programs/swap/src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_amm_config</span>(</span><br><span class="line">    ctx: Context&lt;CreateAmmConfig&gt;,</span><br><span class="line">    index: <span class="type">u16</span>,</span><br><span class="line">    trade_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    protocol_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    fund_fee_rate: <span class="type">u64</span>,</span><br><span class="line">    create_pool_fee: <span class="type">u64</span>,</span><br><span class="line">    creator_fee_rate: <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 费率不能超过 100%</span></span><br><span class="line">    <span class="built_in">assert!</span>(trade_fee_rate + creator_fee_rate &lt; FEE_RATE_DENOMINATOR_VALUE);</span><br><span class="line">    <span class="built_in">assert!</span>(protocol_fee_rate &lt;= FEE_RATE_DENOMINATOR_VALUE);</span><br><span class="line">    <span class="built_in">assert!</span>(fund_fee_rate &lt;= FEE_RATE_DENOMINATOR_VALUE);</span><br><span class="line">    <span class="built_in">assert!</span>(fund_fee_rate + protocol_fee_rate &lt;= FEE_RATE_DENOMINATOR_VALUE);</span><br><span class="line">    instructions::<span class="title function_ invoke__">create_amm_config</span>(</span><br><span class="line">        ctx,</span><br><span class="line">        index,</span><br><span class="line">        trade_fee_rate,</span><br><span class="line">        protocol_fee_rate,</span><br><span class="line">        fund_fee_rate,</span><br><span class="line">        create_pool_fee,</span><br><span class="line">        creator_fee_rate,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 AMM 系统中，<code>AmmConfig</code> 是底层费率治理的基础模块</p><ul><li>通过配置 AMM 账户存储全局配置参数和费率设置。</li><li>通过 index 区分不同配置，可为不同交易对设置不同费率。</li></ul><p><strong>Hooray！Raydium Swap Config 学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
            <tag> Raydium Swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 并发</title>
      <link href="/2025/10/10/rust-concurrency/"/>
      <url>/2025/10/10/rust-concurrency/</url>
      
        <content type="html"><![CDATA[<p>安全高效地处理并发编程是 Rust 的主要目标之一。<strong>并发编程</strong>（concurrent programming）是指程序的不同部分独立执行，而<strong>并行编程</strong>（parallel programming）是指程序的不同部分同时执行。随着计算机利用多处理器的优势越来越多，并发和并行编程变得日益重要。</p><p><strong>Rust 所有权和类型系统是一套强大的工具，能够同时帮助管理内存安全和并发问题</strong>，通过利用所有权和类型检查，许多并发错误在 Rust 中是<strong>编译时错误</strong>，而不是运行时错误。因此可以在编写代码时就修复问题，而不是在部署到生产环境后才发现，无畏并发让你能够编写没有细微 bug 的代码，并且易于重构而不会引入新的 bug。</p><h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><ul><li>如何创建线程来同时运行多段代码</li><li><strong>消息传递并发</strong>：通过通道在线程间发送消息</li><li><strong>共享状态并发</strong>：多个线程访问同一数据</li><li><code>Sync</code> 和 <code>Send</code> trait：将 Rust 的并发保证扩展到用户定义的类型</li></ul><h2 id="1-使用线程同时运行代码"><a href="#1-使用线程同时运行代码" class="headerlink" title="1. 使用线程同时运行代码"></a>1. 使用线程同时运行代码</h2><p>在大多数操作系统中，程序的代码在一个<strong>进程</strong>（process）中运行，操作系统同时管理多个进程。在程序内部，你也可以有多个同时运行的独立部分，运行这些部分的功能称为<strong>线程</strong>（thread）。</p><p>将程序中的计算拆分到多个线程可以提升性能，但也增加了复杂性。因为线程同时运行，无法保证不同线程中的代码执行顺序，这可能导致：</p><ul><li><strong>竞态条件</strong>（race conditions）：线程以不一致的顺序访问数据或资源</li><li><strong>死锁</strong>（deadlocks）：两个线程互相等待对方，阻止它们继续运行</li><li>只在特定情况下发生的 bug，难以可靠地复现和修复</li></ul><h3 id="1-1-使用-spawn-创建新线程"><a href="#1-1-使用-spawn-创建新线程" class="headerlink" title="1.1 使用 spawn 创建新线程"></a>1.1 使用 <code>spawn</code> 创建新线程</h3><p>使用 <code>thread::spawn</code> 函数创建新线程，传递一个闭包包含要在新线程中运行的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当主线程结束时，所有派生线程都会被关闭，无论它们是否执行完毕。</p><h3 id="1-2-使用-join-等待线程完成"><a href="#1-2-使用-join-等待线程完成" class="headerlink" title="1.2 使用 join 等待线程完成"></a>1.2 使用 <code>join</code> 等待线程完成</h3><p><code>thread::spawn</code> 返回一个 <code>JoinHandle</code>，调用它的 <code>join</code> 方法可以等待线程完成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 等待派生线程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>join</code> 会阻塞当前线程，直到 handle 代表的线程终止。</p><h3 id="1-3-在线程中使用-move-闭包"><a href="#1-3-在线程中使用-move-闭包" class="headerlink" title="1.3 在线程中使用 move 闭包"></a>1.3 在线程中使用 <code>move</code> 闭包</h3><p><code>move</code> 闭包常常与 <code>thread::spawn</code> 一起使用，它允许你在一个线程中使用另一个线程的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是 vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在闭包前使用 <code>move</code> 关键字，我们强制闭包获取它使用的值的所有权，而不是让 Rust 推断它应该借用值。</p><p>如果不使用 <code>move</code>，Rust 会尝试借用 <code>v</code>，但编译器无法确定派生线程会运行多久，所以无法确定 <code>v</code> 的引用是否始终有效。</p><h2 id="2-使用消息传递在线程间传输数据"><a href="#2-使用消息传递在线程间传输数据" class="headerlink" title="2. 使用消息传递在线程间传输数据"></a>2. 使用消息传递在线程间传输数据</h2><p>一个日益流行的确保安全并发的方法是<strong>消息传递</strong>（message passing），线程或 actor 通过互相发送包含数据的消息来通信。Go 语言文档中的口号是：</p><blockquote><p>不要通过共享内存来通信；而是通过通信来共享内存。</p></blockquote><p>Rust 实现消息传递并发的主要工具是<strong>通道</strong>（channel）。</p><h3 id="2-1-通道的概念"><a href="#2-1-通道的概念" class="headerlink" title="2.1 通道的概念"></a>2.1 通道的概念</h3><p>通道有两部分组成：</p><ul><li><strong>发送者</strong>（transmitter）</li><li><strong>接收者</strong>（receiver）</li></ul><p>当发送者或接收者任一被丢弃时，我们称通道被<strong>关闭</strong>（closed）了。</p><h3 id="2-2-创建通道"><a href="#2-2-创建通道" class="headerlink" title="2.2 创建通道"></a>2.2 创建通道</h3><p>使用 <code>mpsc::channel</code> 函数创建通道。<code>mpsc</code> 代表 <em>multiple producer, single consumer</em>（多个生产者，单个消费者）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收到：&#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mpsc::channel</code> 返回一个元组：第一个元素是发送端，第二个元素是接收端</li><li>通常使用 <code>tx</code> 和 <code>rx</code> 作为变量名（transmitter 和 receiver 的缩写）</li><li>使用 <code>move</code> 将 <code>tx</code> 移动到闭包中，派生线程就拥有了发送端</li></ul><h3 id="2-3-发送和接收消息"><a href="#2-3-发送和接收消息" class="headerlink" title="2.3 发送和接收消息"></a>2.3 发送和接收消息</h3><p>发送端的 <code>send</code> 方法：</p><ul><li>接受要发送的值</li><li>返回 <code>Result&lt;T, E&gt;</code> 类型</li><li>如果接收端已经被丢弃，发送操作会返回错误</li></ul><p>接收端有两个方法：</p><p><strong><code>recv</code> 方法</strong>：</p><ul><li>阻塞主线程执行直到有值被发送</li><li>返回 <code>Result&lt;T, E&gt;</code></li><li>当发送端关闭时返回错误</li></ul><p><strong><code>try_recv</code> 方法</strong>：</p><ul><li>不会阻塞，立即返回</li><li>返回 <code>Result&lt;T, E&gt;</code>：如果有消息返回 <code>Ok</code>，否则返回 <code>Err</code></li><li>适合在循环中调用，处理消息的同时做其他工作</li></ul><h3 id="2-4-通道与所有权转移"><a href="#2-4-通道与所有权转移" class="headerlink" title="2.4 通道与所有权转移"></a>2.4 通道与所有权转移</h3><p>发送值时会转移所有权，这防止了在发送后意外再次使用该值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// println!(&quot;val is &#123;&#125;&quot;, val); // 错误！val 的所有权已转移</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收到：&#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-发送多个值"><a href="#2-5-发送多个值" class="headerlink" title="2.5 发送多个值"></a>2.5 发送多个值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;收到：&#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>派生线程发送多个消息，每次发送后暂停 1 秒</li><li>主线程中将 <code>rx</code> 当作迭代器使用，不再显式调用 <code>recv</code></li><li>当通道关闭时，迭代结束</li></ul><h3 id="2-6-通过克隆发送者创建多个生产者"><a href="#2-6-通过克隆发送者创建多个生产者" class="headerlink" title="2.6 通过克隆发送者创建多个生产者"></a>2.6 通过克隆发送者创建多个生产者</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;more&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;messages&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;you&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;收到：&#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出可能类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">收到：hi</span><br><span class="line">收到：more</span><br><span class="line">收到：from</span><br><span class="line">收到：messages</span><br><span class="line">收到：the</span><br><span class="line">收到：for</span><br><span class="line">收到：thread</span><br><span class="line">收到：you</span><br></pre></td></tr></table></figure><p>具体顺序取决于系统的调度。</p><h2 id="3-共享状态并发"><a href="#3-共享状态并发" class="headerlink" title="3. 共享状态并发"></a>3. 共享状态并发</h2><p>消息传递是一种很好的处理并发的方式，但并不是唯一的。另一种方式是多个线程访问相同的共享数据。</p><p>回忆一下 Go 语言的口号：不要通过共享内存来通信。那么，<strong>通过共享内存来通信</strong>是什么样的呢？</p><p>某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将值传送到通道中，就不应该再使用这个值了。共享内存并发类似于多所有权：多个线程可以同时访问相同的内存位置。</p><h3 id="3-1-互斥器（Mutex）"><a href="#3-1-互斥器（Mutex）" class="headerlink" title="3.1 互斥器（Mutex）"></a>3.1 互斥器（Mutex）</h3><p><strong>互斥器</strong>（mutex）是 <em>mutual exclusion</em> 的缩写，意为在任意时刻，mutex 只允许一个线程访问某些数据。</p><p>要访问互斥器中的数据，线程必须首先发出信号表明它想要获取互斥器的<strong>锁</strong>（lock）。锁是一个数据结构，它记录谁有数据的独占访问权。因此，mutex 通过锁系统<strong>保护</strong>（guarding）其持有的数据。</p><p>使用 mutex 的两个规则：</p><ol><li>在使用数据之前必须尝试获取锁</li><li>使用完 mutex 守护的数据后，必须解锁数据，以便其他线程可以获取锁</li></ol><h3 id="3-2-Mutex-的基本使用"><a href="#3-2-Mutex-的基本使用" class="headerlink" title="3.2 Mutex&lt;T&gt; 的基本使用"></a>3.2 <code>Mutex&lt;T&gt;</code> 的基本使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>Mutex::new</code> 创建 <code>Mutex&lt;T&gt;</code></li><li>使用 <code>lock</code> 方法获取锁。这个调用会阻塞当前线程，直到获取锁为止</li><li><code>lock</code> 返回 <code>LockResult</code>，它是一个智能指针 <code>MutexGuard</code></li><li><code>MutexGuard</code> 实现了 <code>Deref</code> 指向内部数据，实现了 <code>Drop</code> 在离开作用域时自动释放锁</li></ul><h3 id="3-3-在多线程中共享-Mutex"><a href="#3-3-在多线程中共享-Mutex" class="headerlink" title="3.3 在多线程中共享 Mutex&lt;T&gt;"></a>3.3 在多线程中共享 <code>Mutex&lt;T&gt;</code></h3><p><strong>错误的尝试</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果：&#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无法编译，因为 <code>counter</code> 的所有权在第一次循环时就被移动到了第一个线程中。</p><h3 id="3-4-多线程多所有权"><a href="#3-4-多线程多所有权" class="headerlink" title="3.4 多线程多所有权"></a>3.4 多线程多所有权</h3><p>在第 15 章中，我们使用智能指针 <code>Rc&lt;T&gt;</code> 来创建引用计数值，以便拥有多个所有者。让我们尝试用 <code>Rc&lt;T&gt;</code> 包装 <code>Mutex&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果：&#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时会得到错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br></pre></td></tr></table></figure><p>问题在于 <code>Rc&lt;T&gt;</code> 不是线程安全的。当 <code>Rc&lt;T&gt;</code> 管理引用计数时，它在每次调用 <code>clone</code> 时增加计数，并在每次克隆被丢弃时减少计数。但它没有使用任何并发原语来确保改变计数的操作不会被另一个线程打断。</p><h3 id="3-5-使用-Arc-实现原子引用计数"><a href="#3-5-使用-Arc-实现原子引用计数" class="headerlink" title="3.5 使用 Arc&lt;T&gt; 实现原子引用计数"></a>3.5 使用 <code>Arc&lt;T&gt;</code> 实现原子引用计数</h3><p><code>Arc&lt;T&gt;</code> 是一个类似 <code>Rc&lt;T&gt;</code> 的类型，但可以安全地用于并发场景。字母 ‘a’ 代表<strong>原子性</strong>（atomic），意为它是一个<strong>原子引用计数</strong>（atomically reference counted）类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果：&#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：10</span><br></pre></td></tr></table></figure><p>这段代码成功编译并运行！</p><h3 id="3-6-Rc-vs-Arc"><a href="#3-6-Rc-vs-Arc" class="headerlink" title="3.6 Rc&lt;T&gt; vs Arc&lt;T&gt;"></a>3.6 <code>Rc&lt;T&gt;</code> vs <code>Arc&lt;T&gt;</code></h3><p>为什么所有原始类型不默认都是原子性的？为什么标准库类型不默认使用 <code>Arc&lt;T&gt;</code>？</p><p>原因是：<strong>线程安全带有性能损失</strong>，只有在真正需要时才应该付出这个代价。如果只是在单线程中操作值，代码可以运行得更快。</p><h3 id="3-7-RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#3-7-RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="3.7 RefCell&lt;T&gt; &#x2F; Rc&lt;T&gt; 与 Mutex&lt;T&gt; &#x2F; Arc&lt;T&gt; 的相似性"></a>3.7 <code>RefCell&lt;T&gt;</code> &#x2F; <code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code> &#x2F; <code>Arc&lt;T&gt;</code> 的相似性</h3><p>你可能注意到 <code>counter</code> 是不可变的，但我们可以获取其内部值的可变引用。这意味着 <code>Mutex&lt;T&gt;</code> 提供了<strong>内部可变性</strong>，就像 <code>Cell</code> 系列类型一样。</p><p>正如我们使用 <code>RefCell&lt;T&gt;</code> 来允许改变 <code>Rc&lt;T&gt;</code> 中的内容，我们使用 <code>Mutex&lt;T&gt;</code> 来改变 <code>Arc&lt;T&gt;</code> 中的内容。</p><p>另一个值得注意的细节是：使用 <code>Mutex&lt;T&gt;</code> 有造成<strong>死锁</strong>（deadlock）的风险。当一个操作需要锁定两个资源，而两个线程各持有一个锁，并试图获取另一个锁时，它们会永远等待对方。</p><h2 id="4-使用-Send-和-Sync-trait-扩展并发"><a href="#4-使用-Send-和-Sync-trait-扩展并发" class="headerlink" title="4. 使用 Send 和 Sync trait 扩展并发"></a>4. 使用 <code>Send</code> 和 <code>Sync</code> trait 扩展并发</h2><p>有趣的是，Rust 语言本身的并发特性很少。本章讨论的几乎所有并发特性都是标准库的一部分，而不是语言本身。你的并发选项不限于语言或标准库，你可以编写自己的并发功能或使用其他人编写的。</p><p>然而，有两个并发概念内嵌于语言中：<code>std::marker</code> trait <code>Sync</code> 和 <code>Send</code>。</p><h3 id="4-1-Send-trait：允许在线程间转移所有权"><a href="#4-1-Send-trait：允许在线程间转移所有权" class="headerlink" title="4.1 Send trait：允许在线程间转移所有权"></a>4.1 <code>Send</code> trait：允许在线程间转移所有权</h3><p><code>Send</code> 标记 trait 表明实现了 <code>Send</code> 的类型值的所有权可以在线程间传送。</p><p>几乎所有 Rust 类型都是 <code>Send</code> 的，但有一些例外，包括 <code>Rc&lt;T&gt;</code>：这不能是 <code>Send</code> 的，因为如果克隆了 <code>Rc&lt;T&gt;</code> 的值并尝试将克隆的所有权转移到另一个线程，两个线程可能同时更新引用计数。</p><p>因此，<code>Rc&lt;T&gt;</code> 被实现为用于单线程场景。</p><p>任何完全由 <code>Send</code> 类型组成的类型也会自动标记为 <code>Send</code>。几乎所有基本类型都是 <code>Send</code> 的，除了裸指针。</p><h3 id="4-2-Sync-trait：允许多线程访问"><a href="#4-2-Sync-trait：允许多线程访问" class="headerlink" title="4.2 Sync trait：允许多线程访问"></a>4.2 <code>Sync</code> trait：允许多线程访问</h3><p><code>Sync</code> 标记 trait 表明一个实现了 <code>Sync</code> 的类型可以安全地从多个线程中引用。</p><p>换句话说，对于任意类型 <code>T</code>，如果 <code>&amp;T</code>（<code>T</code> 的不可变引用）是 <code>Send</code> 的，那么 <code>T</code> 就是 <code>Sync</code> 的，这意味着引用可以安全地发送到另一个线程。</p><p>类似于 <code>Send</code>，基本类型都是 <code>Sync</code> 的，完全由 <code>Sync</code> 类型组成的类型也是 <code>Sync</code> 的。</p><p><code>Rc&lt;T&gt;</code> 也不是 <code>Sync</code> 的，原因与它不是 <code>Send</code> 的相同。<code>RefCell&lt;T&gt;</code> 类型和 <code>Cell&lt;T&gt;</code> 系列类型不是 <code>Sync</code> 的。<code>RefCell&lt;T&gt;</code> 在运行时进行的借用检查不是线程安全的。</p><p>智能指针 <code>Mutex&lt;T&gt;</code> 是 <code>Sync</code> 的，可以用来在多线程中共享访问。</p><h3 id="4-3-手动实现-Send-和-Sync-是不安全的"><a href="#4-3-手动实现-Send-和-Sync-是不安全的" class="headerlink" title="4.3 手动实现 Send 和 Sync 是不安全的"></a>4.3 手动实现 <code>Send</code> 和 <code>Sync</code> 是不安全的</h3><p>因为由 <code>Send</code> 和 <code>Sync</code> trait 组成的类型会自动成为 <code>Send</code> 和 <code>Sync</code>，所以我们不必手动实现这些 trait。作为标记 trait，它们甚至没有任何需要实现的方法。</p><p>手动实现这些 trait 涉及实现不安全的 Rust 代码。我们将在第 19 章讨论使用不安全 Rust 代码。现在重要的是，构建由非 <code>Send</code> 和 <code>Sync</code> 部分组成的新并发类型需要仔细思考以维持安全保证。</p><h2 id="5-并发模式对比"><a href="#5-并发模式对比" class="headerlink" title="5. 并发模式对比"></a>5. 并发模式对比</h2><h3 id="5-1-消息传递-vs-共享状态"><a href="#5-1-消息传递-vs-共享状态" class="headerlink" title="5.1 消息传递 vs 共享状态"></a>5.1 消息传递 vs 共享状态</h3><p><strong>消息传递</strong>（使用通道）：</p><ul><li>✅ 更容易推理，减少共享状态</li><li>✅ 避免了锁和死锁问题</li><li>✅ 符合”通过通信来共享内存”的理念</li><li>❌ 可能有一些性能开销</li></ul><p><strong>共享状态</strong>（使用 Mutex）：</p><ul><li>✅ 在某些场景下性能更好</li><li>✅ 对某些问题更自然（如共享配置）</li><li>❌ 需要小心处理锁，避免死锁</li><li>❌ 更容易引入竞态条件</li></ul><p>Rust 允许你根据具体情况选择最合适的并发方式。</p><h3 id="5-2-线程安全类型对照表"><a href="#5-2-线程安全类型对照表" class="headerlink" title="5.2 线程安全类型对照表"></a>5.2 线程安全类型对照表</h3><table><thead><tr><th>类型</th><th>线程安全</th><th>用途</th></tr></thead><tbody><tr><td><code>Rc&lt;T&gt;</code></td><td>❌</td><td>单线程引用计数</td></tr><tr><td><code>Arc&lt;T&gt;</code></td><td>✅</td><td>多线程引用计数</td></tr><tr><td><code>RefCell&lt;T&gt;</code></td><td>❌</td><td>单线程内部可变性</td></tr><tr><td><code>Mutex&lt;T&gt;</code></td><td>✅</td><td>多线程内部可变性</td></tr><tr><td><code>Cell&lt;T&gt;</code></td><td>❌ (但 <code>Send</code>)</td><td>单线程内部可变性（<code>Copy</code> 类型）</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust 提供了强大的并发编程工具：</p><ul><li><strong>线程</strong>：使用 <code>thread::spawn</code> 创建，用 <code>join</code> 等待完成</li><li><strong>消息传递</strong>：使用 <code>mpsc::channel</code> 在线程间安全传递数据</li><li><strong>共享状态</strong>：使用 <code>Mutex&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 实现线程安全的共享</li><li><strong><code>Send</code> 和 <code>Sync</code> trait</strong>：确保类型可以安全地在线程间使用</li></ul><p>Rust 的类型系统和所有权规则使得编写并发代码时，许多并发错误都能在编译期捕获，而不是在运行时才暴露。这就是 Rust 的<strong>无畏并发</strong>：你可以放心地编写并发代码，因为编译器会帮你检查大部分问题。</p><p>一旦代码能够编译通过，你就可以确信它能在多线程环境中正确运行，而不会出现其他语言中常见的难以追踪的 bug。</p><p>掌握 Rust 的并发特性，能让你充分利用现代多核处理器的能力，编写高性能、安全可靠的并发程序！</p><p><strong>Hooray！并发小节完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 智能指针</title>
      <link href="/2025/10/09/rust-smart-pointers/"/>
      <url>/2025/10/09/rust-smart-pointers/</url>
      
        <content type="html"><![CDATA[<p>指针（Pointer）是一个包含内存地址的变量，这个地址指向存储在内存中的其他数据。Rust 中最常见的指针是引用（reference），用 <code>&amp;</code> 符号表示，它们只借用数据而不拥有所有权。</p><p>而智能指针（Smart Pointer）则是一种数据结构，不仅像指针一样工作，还拥有额外的元数据和功能。智能指针的概念并非 Rust 独有，它起源于 C++，也存在于其他编程语言中。</p><p>Rust 的所有权和借用机制让智能指针有了额外的特性：<strong>引用只借用数据，而智能指针通常拥有它们指向的数据</strong>。</p><p>比如 <code>String</code> 和 <code>Vec&lt;T&gt;</code>。它们都拥有一些内存并允许你操作它们，同时还有元数据（如容量）和额外的能力（如 <code>String</code> 确保数据始终是有效的 UTF-8）。</p><h2 id="1-智能指针的特征"><a href="#1-智能指针的特征" class="headerlink" title="1. 智能指针的特征"></a>1. 智能指针的特征</h2><p>智能指针通常使用结构体实现，但与普通结构体不同的是，它们实现了 <code>Deref</code> 和 <code>Drop</code> trait：</p><ul><li><strong><code>Deref</code> trait</strong>：允许智能指针实例像引用一样使用，使你的代码可以同时适用于引用和智能指针</li><li><strong><code>Drop</code> trait</strong>：允许你自定义智能指针离开作用域时运行的代码</li></ul><p>本章将介绍标准库中最常用的智能指针：</p><ul><li><code>Box&lt;T&gt;</code>：在堆上分配值</li><li><code>Rc&lt;T&gt;</code>：引用计数类型，支持多所有权</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>：通过 <code>RefCell&lt;T&gt;</code> 访问，在运行时而非编译时执行借用规则</li></ul><p>此外，我们还会讨论<strong>内部可变性模式</strong>（interior mutability pattern），以及如何避免引用循环导致的内存泄漏。</p><h2 id="2-Box-堆上的数据"><a href="#2-Box-堆上的数据" class="headerlink" title="2. Box - 堆上的数据"></a>2. Box<T> - 堆上的数据</h2><p><code>Box&lt;T&gt;</code> 是最简单的智能指针，它允许你将数据存储在堆上而不是栈上。栈上只保留指向堆数据的指针。</p><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，数字 5 被存储在堆上，<code>b</code> 是指向它的指针。当 <code>b</code> 离开作用域时，堆上的数据会被自动释放。</p><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><p><strong>递归类型</strong></p><p>Rust 不允许直接在栈上存储递归类型，因为它们的大小无法在编译时确定。但是 <code>Box&lt;T&gt;</code> 可以帮助我们创建递归数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>List</code> 是一个递归类型，每个 <code>Cons</code> 变体都包含一个 <code>Box&lt;List&gt;</code>，使得 List 可以递归嵌套，同时编译器能够确定所需的空间大小。</p><p><strong>大型数据转移所有权</strong></p><p>当你有大量数据需要转移所有权，但又不想复制数据时，可以使用 <code>Box&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">large_data</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0</span>; <span class="number">1000000</span>]);</span><br><span class="line">    <span class="comment">// 转移所有权时只复制指针，不复制数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_owner</span> = large_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Rc-引用计数智能指针"><a href="#3-Rc-引用计数智能指针" class="headerlink" title="3. Rc - 引用计数智能指针"></a>3. Rc<T> - 引用计数智能指针</h2><p>有时候，一个值可能有多个所有者。例如在图数据结构中，多条边可能指向同一个节点，这个节点从概念上讲被所有指向它的边所拥有。<code>Rc&lt;T&gt;</code> 就是为这种场景设计的。</p><p><code>Rc&lt;T&gt;</code> 是 <em>reference counting</em>（引用计数）的缩写。它通过跟踪值的引用数量来判断这个值是否仍在使用。当引用数量变为 0 时，该值就可以被清理。</p><p><strong>注意</strong>：<code>Rc&lt;T&gt;</code> 只能用于单线程场景。</p><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;计数：&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;计数：&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;计数：&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;计数：&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>a</code> 是一个包含 5 和 10 的列表</li><li><code>b</code> 和 <code>c</code> 都共享 <code>a</code> 的所有权</li><li>使用 <code>Rc::clone(&amp;a)</code> 增加引用计数，而不是深拷贝数据</li><li>每次 <code>Rc::clone</code> 只增加引用计数，不会复制堆上的数据，所以速度很快</li></ul><h3 id="3-2-Rc-clone-vs-clone"><a href="#3-2-Rc-clone-vs-clone" class="headerlink" title="3.2 Rc::clone vs .clone()"></a>3.2 <code>Rc::clone</code> vs <code>.clone()</code></h3><p>虽然可以使用 <code>a.clone()</code> 代替 <code>Rc::clone(&amp;a)</code>，但 Rust 的惯例是使用 <code>Rc::clone</code>，因为：</p><ul><li><code>Rc::clone</code> 只增加引用计数，非常快</li><li>普通的 <code>.clone()</code> 通常会深拷贝数据，耗时较多</li><li>使用 <code>Rc::clone</code> 能清楚地表明这只是增加引用计数</li></ul><h2 id="4-RefCell-和内部可变性"><a href="#4-RefCell-和内部可变性" class="headerlink" title="4. RefCell 和内部可变性"></a>4. RefCell<T> 和内部可变性</h2><h3 id="4-1-什么是内部可变性"><a href="#4-1-什么是内部可变性" class="headerlink" title="4.1 什么是内部可变性"></a>4.1 什么是内部可变性</h3><p><strong>内部可变性</strong>（interior mutability）是 Rust 的一种设计模式，它允许你在只有不可变引用的情况下修改数据。这通常是借用规则所不允许的。</p><p>为了改变数据，该模式在数据结构内部使用 <code>unsafe</code> 代码来绕过 Rust 的可变性和借用规则。我们可以使用这些类型，只要能确保在运行时遵循借用规则，即使编译器无法保证这一点。</p><h3 id="4-2-RefCell-的特点"><a href="#4-2-RefCell-的特点" class="headerlink" title="4.2 RefCell&lt;T&gt; 的特点"></a>4.2 <code>RefCell&lt;T&gt;</code> 的特点</h3><ul><li><p><code>RefCell&lt;T&gt;</code> 代表其持有数据的<strong>唯一所有权</strong></p></li><li><p>与 <code>Rc&lt;T&gt;</code> 类似，<code>RefCell&lt;T&gt;</code> 只能用于单线程场景</p></li><li><p>编译时检查 vs 运行时检查</p><ul><li><code>Box&lt;T&gt;</code> 的借用规则在编译时检查</li><li><code>RefCell&lt;T&gt;</code> 的借用规则在运行时检查</li><li>如果违反借用规则，<code>RefCell&lt;T&gt;</code> 会在运行时 panic</li></ul></li></ul><h3 id="4-3-Box-vs-Rc-vs-RefCell"><a href="#4-3-Box-vs-Rc-vs-RefCell" class="headerlink" title="4.3 Box&lt;T&gt; vs Rc&lt;T&gt; vs RefCell&lt;T&gt;"></a>4.3 <code>Box&lt;T&gt;</code> vs <code>Rc&lt;T&gt;</code> vs <code>RefCell&lt;T&gt;</code></h3><table><thead><tr><th>类型</th><th>所有权</th><th>借用检查时机</th><th>可变性</th></tr></thead><tbody><tr><td><code>Box&lt;T&gt;</code></td><td>单一所有者</td><td>编译时</td><td>可变或不可变借用</td></tr><tr><td><code>Rc&lt;T&gt;</code></td><td>多个所有者</td><td>编译时</td><td>只能不可变借用</td></tr><tr><td><code>RefCell&lt;T&gt;</code></td><td>单一所有者</td><td>运行时</td><td>可变或不可变借用</td></tr></tbody></table><h3 id="4-4-基本使用"><a href="#4-4-基本使用" class="headerlink" title="4.4 基本使用"></a>4.4 基本使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可变借用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">        *y += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取不可变借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = x.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, z); <span class="comment">// 输出: x = 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RefCell&lt;T&gt;</code> 提供了两个方法：</p><ul><li><code>borrow()</code>：返回不可变引用 <code>Ref&lt;T&gt;</code></li><li><code>borrow_mut()</code>：返回可变引用 <code>RefMut&lt;T&gt;</code></li></ul><p>这两个返回值都是智能指针，实现了 <code>Deref</code> trait。</p><h3 id="4-5-运行时借用检查"><a href="#4-5-运行时借用检查" class="headerlink" title="4.5 运行时借用检查"></a>4.5 运行时借用检查</h3><p>如果违反借用规则，程序会在运行时 panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_y</span> = x.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_z</span> = x.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// panic! 已经有一个可变借用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时会出现类似错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;already borrowed: BorrowMutError&#x27;</span><br></pre></td></tr></table></figure><h2 id="5-Rc-与-RefCell-结合使用"><a href="#5-Rc-与-RefCell-结合使用" class="headerlink" title="5. Rc&lt;T&gt; 与 RefCell&lt;T&gt; 结合使用"></a>5. <code>Rc&lt;T&gt;</code> 与 <code>RefCell&lt;T&gt;</code> 结合使用</h2><p><code>Rc&lt;T&gt;</code> 允许多个所有者，但只提供不可变访问。<code>RefCell&lt;T&gt;</code> 允许可变访问，但只能有一个所有者。将它们结合使用，可以创建<strong>有多个所有者且可修改的值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改共享的值</span></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c = &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出中，<code>a</code>、<code>b</code>、<code>c</code> 中的共享值都会是 15，因为它们都指向同一个 <code>RefCell&lt;i32&gt;</code>。</p><h2 id="6-引用循环与内存泄漏"><a href="#6-引用循环与内存泄漏" class="headerlink" title="6. 引用循环与内存泄漏"></a>6. 引用循环与内存泄漏</h2><h3 id="6-1-什么是引用循环"><a href="#6-1-什么是引用循环" class="headerlink" title="6.1 什么是引用循环"></a>6.1 什么是引用循环</h3><p>使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 可能会创建引用循环：两个 <code>Rc&lt;T&gt;</code> 值互相引用，导致引用计数永远不会变为 0，从而造成内存泄漏。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建循环引用</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a 和 b 形成循环，引用计数永远不会为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-使用-Weak-避免循环引用"><a href="#6-2-使用-Weak-避免循环引用" class="headerlink" title="6.2 使用 Weak&lt;T&gt; 避免循环引用"></a>6.2 使用 <code>Weak&lt;T&gt;</code> 避免循环引用</h3><p>为了避免引用循环，Rust 提供了 <code>Weak&lt;T&gt;</code>：</p><ul><li><code>Rc::clone</code> 增加 <code>strong_count</code>（强引用计数）</li><li><code>Rc::downgrade</code> 创建 <code>Weak&lt;T&gt;</code>，增加 <code>weak_count</code>（弱引用计数）</li><li>只有当 <code>strong_count</code> 为 0 时，值才会被清理，不管 <code>weak_count</code> 是多少</li><li>使用 <code>weak.upgrade()</code> 获取 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果值已被清理则返回 <code>None</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Weak 引用父节点，避免循环</span></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Deref-trait-像引用一样使用"><a href="#7-Deref-trait-像引用一样使用" class="headerlink" title="7. Deref trait - 像引用一样使用"></a>7. <code>Deref</code> trait - 像引用一样使用</h2><p>实现 <code>Deref</code> trait 允许你自定义解引用运算符 <code>*</code> 的行为。通过实现 <code>Deref</code>，智能指针可以像常规引用一样被处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y); <span class="comment">// Deref 让这成为可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-Deref-强制转换"><a href="#7-1-Deref-强制转换" class="headerlink" title="7.1 Deref 强制转换"></a>7.1 Deref 强制转换</h3><p>当把某个类型的引用传递给函数或方法，但它的类型与参数类型不匹配时，Rust 会自动进行 <strong>Deref 强制转换</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;name&#125;!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m); <span class="comment">// &amp;MyBox&lt;String&gt; -&gt; &amp;String -&gt; &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 会自动调用 <code>deref</code> 方法，将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>&amp;String</code>，再转换为 <code>&amp;str</code>。</p><h2 id="8-Drop-trait-清理代码"><a href="#8-Drop-trait-清理代码" class="headerlink" title="8. Drop trait - 清理代码"></a>8. <code>Drop</code> trait - 清理代码</h2><p><code>Drop</code> trait 允许你自定义值离开作用域时的行为。智能指针通常会实现 <code>Drop</code> trait 来释放资源：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;销毁 CustomSmartPointer，数据：`&#123;&#125;`&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;my stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;other stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointers 已创建&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// d 和 c 离开作用域，自动调用 drop</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CustomSmartPointers 已创建</span><br><span class="line">销毁 CustomSmartPointer，数据：`other stuff`</span><br><span class="line">销毁 CustomSmartPointer，数据：`my stuff`</span><br></pre></td></tr></table></figure><p>注意：变量以创建时相反的顺序被丢弃（先创建的后销毁）。</p><h3 id="8-1-提前丢弃值"><a href="#8-1-提前丢弃值" class="headerlink" title="8.1 提前丢弃值"></a>8.1 提前丢弃值</h3><p>如果需要提前清理值，不能直接调用 <code>drop</code> 方法，而应该使用 <code>std::mem::drop</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;some data&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer 已创建&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c); <span class="comment">// 提前清理</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer 在 main 结束前被丢弃&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>智能指针是 Rust 中管理内存和所有权的强大工具：</p><ul><li><strong><code>Box&lt;T&gt;</code></strong>：适用于堆上分配和单一所有权场景，特别是递归类型</li><li><strong><code>Rc&lt;T&gt;</code></strong>：适用于单线程环境中需要多个所有者共享数据的场景</li><li><strong><code>RefCell&lt;T&gt;</code></strong>：适用于需要内部可变性和运行时借用检查的场景</li><li><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></strong>：结合两者优势，实现多所有权的可变数据</li><li><strong><code>Weak&lt;T&gt;</code></strong>：避免 <code>Rc&lt;T&gt;</code> 引用循环导致的内存泄漏</li></ul><p>通过 <code>Deref</code> 和 <code>Drop</code> trait，智能指针可以像普通引用一样使用，并在离开作用域时自动清理资源。</p><p>掌握智能指针的使用，对于编写安全、高效的 Rust 代码至关重要。它们为我们提供了更灵活的内存管理方式，同时保持了 Rust 的内存安全保证。</p><p><strong>Hooray！智能指针小节完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— PDA 与 CPI</title>
      <link href="/2025/10/08/solana-cpi-pda/"/>
      <url>/2025/10/08/solana-cpi-pda/</url>
      
        <content type="html"><![CDATA[<h2 id="Program-Derived-Address-PDA"><a href="#Program-Derived-Address-PDA" class="headerlink" title="Program Derived Address (PDA)"></a>Program Derived Address (PDA)</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>PDA 是 Solana 中一种特殊的地址，具有两个关键特性：</p><p><strong>确定性派生</strong>: 使用预定义的”种子”和程序 ID 组合，可以确定性地生成地址。就像用固定的配方总能做出同样的菜，给定相同的输入就能得到相同的地址。</p><p><strong>程序签名能力</strong>: 虽然 PDA 没有私钥，但 Solana 运行时允许程序代表其派生的 PDA 进行签名。这是 PDA 最强大的特性。</p><h3 id="为什么需要-PDA？"><a href="#为什么需要-PDA？" class="headerlink" title="为什么需要 PDA？"></a>为什么需要 PDA？</h3><p>传统区块链中，程序要控制资产需要管理私钥，这既复杂又不安全。PDA 解决了这个问题：</p><ul><li>无需私钥管理，程序本身就能控制账户</li><li>地址可预测，容易查找和管理</li><li>类似链上的哈希映射，用种子映射到地址</li></ul><h3 id="派生机制"><a href="#派生机制" class="headerlink" title="派生机制"></a>派生机制</h3><p>PDA 派生需要三个输入：</p><p><strong>可选种子</strong>: 任意数据，如字符串 <code>&quot;user_profile&quot;</code> 或用户地址。可以使用多个种子组合，例如 <code>[&quot;vault&quot;, user_address, &quot;v1&quot;]</code>。</p><p><strong>Bump 种子</strong>: 一个 0-255 的数字，用于确保地址落在 Ed25519 曲线之外（即没有私钥）。系统从 255 开始递减查找，第一个有效的值称为”规范 bump”。</p><p><strong>程序 ID</strong>: 派生 PDA 的程序地址。只有这个程序能代表该 PDA 签名。</p><h3 id="规范-Bump（Canonical-Bump）的重要性"><a href="#规范-Bump（Canonical-Bump）的重要性" class="headerlink" title="规范 Bump（Canonical Bump）的重要性"></a>规范 Bump（Canonical Bump）的重要性</h3><p>同一组种子可能有多个 bump 值能生成有效的 PDA，但这些 PDA 的地址各不相同。</p><p><strong>安全风险</strong>：</p><p>如果程序不验证是否使用规范 bump，攻击者可能：</p><ul><li>使用非规范 bump 创建”影子账户”</li><li>传入这个影子 PDA 地址而非预期的账户</li><li>绕过程序的安全检查和业务逻辑</li><li>导致资金损失、状态错误或权限绕过</li></ul><p>**注意：**始终使用规范 bump，并将其存储在账户数据中供后续验证。</p><h3 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h3><ul><li>派生 PDA 只是计算地址，不会自动创建账户</li><li>账户必须通过程序指令显式创建</li><li>PDA 账户的所有权属于系统程序，数据所有权属于创建它的程序</li><li>种子设计要考虑唯一性和可预测性</li></ul><h2 id="Cross-Program-Invocation-CPI"><a href="#Cross-Program-Invocation-CPI" class="headerlink" title="Cross Program Invocation (CPI)"></a>Cross Program Invocation (CPI)</h2><h3 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h3><p>CPI 是一个程序调用另一个程序的指令，类似于 API 调用 API。这是 Solana 程序可组合性的基础。</p><p>当程序 A 通过 CPI 调用程序 B 时，原始交易中的权限会自动传递给程序 B，实现了安全的程序间协作。</p><h3 id="权限传递机制"><a href="#权限传递机制" class="headerlink" title="权限传递机制"></a>权限传递机制</h3><p>假设用户发起交易调用程序 A：</p><ul><li>用户钱包是签名者且可写</li><li>某个数据账户只读</li><li>某个代币账户可写</li></ul><p>当程序 A 通过 CPI 调用程序 B 时：</p><ul><li>程序 B 可以使用用户钱包的签名权限</li><li>程序 B 可以读取数据账户</li><li>程序 B 可以写入代币账户</li><li>程序 B 还能继续 CPI 调用程序 C</li></ul><p>这种自动权限传递确保了安全性和便利性的平衡。</p><h3 id="调用深度限制"><a href="#调用深度限制" class="headerlink" title="调用深度限制"></a>调用深度限制</h3><p>Solana 限制 CPI 调用深度为 4 层：</p><ul><li>第 1 层：用户原始交易</li><li>第 2-5 层：最多 4 次 CPI 调用</li></ul><p>超过限制会导致交易失败。这个设计防止无限递归，控制计算成本。</p><h3 id="两种-CPI-类型"><a href="#两种-CPI-类型" class="headerlink" title="两种 CPI 类型"></a>两种 CPI 类型</h3><p><strong>普通 CPI</strong>: 只传递原始交易中的签名者权限。适用于简单的中介场景，如用户通过程序 A 向程序 B 转账。</p><p><strong>带 PDA 签名的 CPI</strong>: 程序可以代表其控制的 PDA 签名。这需要提供 PDA 的派生种子，Solana 运行时会验证 PDA 的有效性后授予签名权限。</p><h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><p>执行 CPI 前必须验证：</p><ul><li>账户所有权是否正确</li><li>账户状态是否有效</li><li>调用者是否有权限</li><li>PDA 派生是否使用规范 bump</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>PDA</strong> 提供了确定性地址生成和程序签名能力，使程序能够拥有和控制账户。</p><p><strong>CPI</strong> 实现了程序间的可组合性，通过权限传递机制实现安全的跨程序调用。</p><p><strong>Hooray！Solana PDA 与 CPI 小节完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 迭代器</title>
      <link href="/2025/10/07/rust-iterators/"/>
      <url>/2025/10/07/rust-iterators/</url>
      
        <content type="html"><![CDATA[<p>迭代器（Iterator）是 Rust 中用于处理元素序列的强大工具。迭代器模式允许你对一系列项进行某些操作，而无需手动管理索引或循环逻辑。Rust 的迭代器是惰性的（lazy），只在需要时才会执行计算，这使得它们既高效又灵活。</p><h2 id="1-迭代器基础"><a href="#1-迭代器基础" class="headerlink" title="1. 迭代器基础"></a>1. 迭代器基础</h2><h3 id="1-1-创建迭代器"><a href="#1-1-创建迭代器" class="headerlink" title="1.1 创建迭代器"></a>1.1 创建迭代器</h3><p>在 Rust 中，所有集合类型都可以创建迭代器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建迭代器（惰性的，此时不会执行任何操作）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for 循环消费迭代器</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;值: &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-三种迭代方法"><a href="#1-2-三种迭代方法" class="headerlink" title="1.2 三种迭代方法"></a>1.2 三种迭代方法</h3><p>Rust 提供三种获取迭代器的方法，它们在所有权处理上有所不同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter() - 返回不可变引用</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;不可变引用: &#123;&#125;&quot;</span>, val); <span class="comment">// val 的类型是 &amp;i32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter_mut() - 返回可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v_mut</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v_mut.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">        *val += <span class="number">1</span>; <span class="comment">// val 的类型是 &amp;mut i32</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;修改后: &#123;:?&#125;&quot;</span>, v_mut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// into_iter() - 获取所有权</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;获取所有权: &#123;&#125;&quot;</span>, val); <span class="comment">// val 的类型是 i32</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, v); // 错误！v 已被移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Iterator-Trait"><a href="#2-Iterator-Trait" class="headerlink" title="2. Iterator Trait"></a>2. Iterator Trait</h2><h3 id="2-1-Iterator-trait-定义"><a href="#2-1-Iterator-trait-定义" class="headerlink" title="2.1 Iterator trait 定义"></a>2.1 Iterator trait 定义</h3><p>所有迭代器都实现了 <code>Iterator</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有许多提供默认实现的方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-手动调用-next-方法"><a href="#2-2-手动调用-next-方法" class="headerlink" title="2.2 手动调用 next 方法"></a>2.2 手动调用 next 方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：调用 <code>next</code> 需要 <code>mut</code>，因为迭代器内部状态会改变。</p><h3 id="2-3-实现自定义迭代器"><a href="#2-3-实现自定义迭代器" class="headerlink" title="2.3 实现自定义迭代器"></a>2.3 实现自定义迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-消费适配器（Consuming-Adaptors）"><a href="#3-消费适配器（Consuming-Adaptors）" class="headerlink" title="3. 消费适配器（Consuming Adaptors）"></a>3. 消费适配器（Consuming Adaptors）</h2><p>消费适配器会调用 <code>next</code> 方法，消耗迭代器：</p><h3 id="3-1-sum-求和"><a href="#3-1-sum-求和" class="headerlink" title="3.1 sum - 求和"></a>3.1 sum - 求和</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总和: &#123;&#125;&quot;</span>, total); <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, v1_iter); // 错误！迭代器已被消费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-collect-收集为集合"><a href="#3-2-collect-收集为集合" class="headerlink" title="3.2 collect - 收集为集合"></a>3.2 collect - 收集为集合</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收集结果: &#123;:?&#125;&quot;</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-其他消费适配器"><a href="#3-3-其他消费适配器" class="headerlink" title="3.3 其他消费适配器"></a>3.3 其他消费适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count - 计数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">count</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;元素数量: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// last - 最后一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">last</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;最后元素: &#123;:?&#125;&quot;</span>, last);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max 和 min</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">min</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;最大值: &#123;:?&#125;, 最小值: &#123;:?&#125;&quot;</span>, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-迭代器适配器（Iterator-Adaptors）"><a href="#4-迭代器适配器（Iterator-Adaptors）" class="headerlink" title="4. 迭代器适配器（Iterator Adaptors）"></a>4. 迭代器适配器（Iterator Adaptors）</h2><p>迭代器适配器会产生新的迭代器，它们是惰性的：</p><h3 id="4-1-map-映射转换"><a href="#4-1-map-映射转换" class="headerlink" title="4.1 map - 映射转换"></a>4.1 map - 映射转换</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map 是惰性的，不会立即执行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;映射后: &#123;:?&#125;&quot;</span>, v2); <span class="comment">// [2, 3, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-filter-过滤元素"><a href="#4-2-filter-过滤元素" class="headerlink" title="4.2 filter - 过滤元素"></a>4.2 filter - 过滤元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;运动鞋&quot;</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">13</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;凉鞋&quot;</span>) &#125;,</span><br><span class="line">        Shoe &#123; size: <span class="number">10</span>, style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;靴子&quot;</span>) &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;我的尺码: &#123;:?&#125;&quot;</span>, in_my_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-常用迭代器适配器"><a href="#4-3-常用迭代器适配器" class="headerlink" title="4.3 常用迭代器适配器"></a>4.3 常用迭代器适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take - 获取前 n 个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_three</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(<span class="number">3</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;前三个: &#123;:?&#125;&quot;</span>, first_three);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip - 跳过前 n 个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">after_two</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">skip</span>(<span class="number">2</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;跳过两个: &#123;:?&#125;&quot;</span>, after_two);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enumerate - 添加索引</span></span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;索引 &#123;&#125;: 值 &#123;&#125;&quot;</span>, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zip - 组合两个迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">letters</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zipped</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(letters.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;组合结果: &#123;:?&#125;&quot;</span>, zipped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-链式调用"><a href="#5-链式调用" class="headerlink" title="5. 链式调用"></a>5. 链式调用</h2><p>迭代器的强大之处在于可以链式调用多个方法：</p><h3 id="5-1-复杂的数据处理"><a href="#5-1-复杂的数据处理" class="headerlink" title="5.1 复杂的数据处理"></a>5.1 复杂的数据处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">i32</span> = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">// 过滤偶数</span></span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|&amp;x| x * x)            <span class="comment">// 平方</span></span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();                      <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;偶数平方和: &#123;&#125;&quot;</span>, result); <span class="comment">// 220</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-字符串处理"><a href="#5-2-字符串处理" class="headerlink" title="5.2 字符串处理"></a>5.2 字符串处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world rust programming&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_words</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = text.<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|word| word.<span class="title function_ invoke__">len</span>() &gt; <span class="number">5</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;长单词: &#123;:?&#125;&quot;</span>, long_words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-结构化数据处理"><a href="#5-3-结构化数据处理" class="headerlink" title="5.3 结构化数据处理"></a>5.3 结构化数据处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">people</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Person &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>), age: <span class="number">30</span> &#125;,</span><br><span class="line">        Person &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>), age: <span class="number">25</span> &#125;,</span><br><span class="line">        Person &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Charlie&quot;</span>), age: <span class="number">35</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = people.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|p| p.age &gt; <span class="number">28</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|p| p.name.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;年龄大于28的人: &#123;:?&#125;&quot;</span>, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-实用方法"><a href="#6-实用方法" class="headerlink" title="6. 实用方法"></a>6. 实用方法</h2><h3 id="6-1-find-查找元素"><a href="#6-1-find-查找元素" class="headerlink" title="6.1 find - 查找元素"></a>6.1 find - 查找元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_even</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|&amp;&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> first_even &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第一个偶数: &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有偶数&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-any-和-all-条件检查"><a href="#6-2-any-和-all-条件检查" class="headerlink" title="6.2 any 和 all - 条件检查"></a>6.2 any 和 all - 条件检查</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">has_even</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;有偶数: &#123;&#125;&quot;</span>, has_even);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">all_positive</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">all</span>(|&amp;x| x &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;全是正数: &#123;&#125;&quot;</span>, all_positive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-fold-累积计算"><a href="#6-3-fold-累积计算" class="headerlink" title="6.3 fold - 累积计算"></a>6.3 fold - 累积计算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fold 的第一个参数是初始值，第二个是累积函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |acc, &amp;x| acc + x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总和: &#123;&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">1</span>, |acc, &amp;x| acc * x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;乘积: &#123;&#125;&quot;</span>, product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-flat-map-扁平化映射"><a href="#6-4-flat-map-扁平化映射" class="headerlink" title="6.4 flat_map - 扁平化映射"></a>6.4 flat_map - 扁平化映射</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">words</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">chars</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = words.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|word| word.<span class="title function_ invoke__">chars</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;所有字符: &#123;:?&#125;&quot;</span>, chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-迭代器与性能"><a href="#7-迭代器与性能" class="headerlink" title="7. 迭代器与性能"></a>7. 迭代器与性能</h2><h3 id="7-1-零成本抽象"><a href="#7-1-零成本抽象" class="headerlink" title="7.1 零成本抽象"></a>7.1 零成本抽象</h3><p>Rust 的迭代器是零成本抽象，编译后的性能与手写循环相当：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_iterator</span>(numbers: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用循环</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_loop</span>(numbers: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> &amp;n <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者编译后的性能几乎相同</span></span><br></pre></td></tr></table></figure><h3 id="7-2-惰性求值的优势"><a href="#7-2-惰性求值的优势" class="headerlink" title="7.2 惰性求值的优势"></a>7.2 惰性求值的优势</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些操作不会立即执行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter</span> = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;映射 &#123;&#125;&quot;</span>, x);</span><br><span class="line">            x * <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;过滤 &#123;&#125;&quot;</span>, x);</span><br><span class="line">            x &gt; &amp;<span class="number">5</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有在需要结果时才会执行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;开始收集:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Vec</span>&lt;_&gt; = iter.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-高级用法"><a href="#8-高级用法" class="headerlink" title="8. 高级用法"></a>8. 高级用法</h2><h3 id="8-1-组合多个迭代器"><a href="#8-1-组合多个迭代器" class="headerlink" title="8.1 组合多个迭代器"></a>8.1 组合多个迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = counter</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, sum); <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-范围迭代器"><a href="#8-2-范围迭代器" class="headerlink" title="8.2 范围迭代器"></a>8.2 范围迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 范围也是迭代器</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向迭代</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">5</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步长迭代</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-partition-分区"><a href="#8-3-partition-分区" class="headerlink" title="8.3 partition - 分区"></a>8.3 partition - 分区</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (evens, odds): (<span class="type">Vec</span>&lt;_&gt;, <span class="type">Vec</span>&lt;_&gt;) = numbers.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">partition</span>(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;偶数: &#123;:?&#125;&quot;</span>, evens);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;奇数: &#123;:?&#125;&quot;</span>, odds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-常见陷阱与最佳实践"><a href="#9-常见陷阱与最佳实践" class="headerlink" title="9. 常见陷阱与最佳实践"></a>9. 常见陷阱与最佳实践</h2><h3 id="9-1-避免不必要的-collect"><a href="#9-1-避免不必要的-collect" class="headerlink" title="9.1 避免不必要的 collect"></a>9.1 避免不必要的 collect</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法 - 创建了临时 Vec</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_of_squares_bad</span>(numbers: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">squares</span>: <span class="type">Vec</span>&lt;_&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x * x)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    squares.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法 - 直接链式调用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_of_squares_good</span>(numbers: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x * x)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;平方和: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">sum_of_squares_good</span>(&amp;numbers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-注意迭代器的消费"><a href="#9-2-注意迭代器的消费" class="headerlink" title="9.2 注意迭代器的消费"></a>9.2 注意迭代器的消费</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：迭代器只能使用一次</span></span><br><span class="line">    <span class="comment">// let sum: i32 = iter.sum();</span></span><br><span class="line">    <span class="comment">// let count = iter.count(); // 错误！iter 已被消费</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确做法：重新创建迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总和: &#123;&#125;, 数量: &#123;&#125;&quot;</span>, sum, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-使用迭代器而非索引"><a href="#9-3-使用迭代器而非索引" class="headerlink" title="9.3 使用迭代器而非索引"></a>9.3 使用迭代器而非索引</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不推荐：使用索引</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..numbers.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐：直接迭代</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> &amp;numbers &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要索引时使用 enumerate</span></span><br><span class="line">    <span class="keyword">for</span> (index, num) <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;索引 &#123;&#125;: &#123;&#125;&quot;</span>, index, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-实战案例"><a href="#10-实战案例" class="headerlink" title="10. 实战案例"></a>10. 实战案例</h2><h3 id="10-1-统计单词频率"><a href="#10-1-统计单词频率" class="headerlink" title="10.1 统计单词频率"></a>10.1 统计单词频率</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">word_frequency</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|word| word.<span class="title function_ invoke__">to_lowercase</span>())</span><br><span class="line">        .<span class="title function_ invoke__">fold</span>(HashMap::<span class="title function_ invoke__">new</span>(), |<span class="keyword">mut</span> map, word| &#123;</span><br><span class="line">            *map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">            map</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Hello world hello Rust world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">freq</span> = <span class="title function_ invoke__">word_frequency</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (word, count) <span class="keyword">in</span> freq &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, word, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-数据转换管道"><a href="#10-2-数据转换管道" class="headerlink" title="10.2 数据转换管道"></a>10.2 数据转换管道</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    price: <span class="type">f64</span>,</span><br><span class="line">    category: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">products</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Product &#123; name: <span class="string">&quot;笔记本&quot;</span>.<span class="title function_ invoke__">to_string</span>(), price: <span class="number">5000.0</span>, category: <span class="string">&quot;电子&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;,</span><br><span class="line">        Product &#123; name: <span class="string">&quot;鼠标&quot;</span>.<span class="title function_ invoke__">to_string</span>(), price: <span class="number">100.0</span>, category: <span class="string">&quot;电子&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;,</span><br><span class="line">        Product &#123; name: <span class="string">&quot;书籍&quot;</span>.<span class="title function_ invoke__">to_string</span>(), price: <span class="number">50.0</span>, category: <span class="string">&quot;图书&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;,</span><br><span class="line">        Product &#123; name: <span class="string">&quot;键盘&quot;</span>.<span class="title function_ invoke__">to_string</span>(), price: <span class="number">300.0</span>, category: <span class="string">&quot;电子&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出电子类别中价格超过200的产品名称</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_electronics</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = products.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|p| p.category == <span class="string">&quot;电子&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|p| p.price &gt; <span class="number">200.0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|p| p.name.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;昂贵的电子产品: &#123;:?&#125;&quot;</span>, expensive_electronics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-矩阵转置"><a href="#10-3-矩阵转置" class="headerlink" title="10.3 矩阵转置"></a>10.3 矩阵转置</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">transpose</span>(matrix: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> matrix.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec!</span>[];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rows</span> = matrix.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cols</span> = matrix[<span class="number">0</span>].<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    (<span class="number">0</span>..cols)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|col| &#123;</span><br><span class="line">            (<span class="number">0</span>..rows)</span><br><span class="line">                .<span class="title function_ invoke__">map</span>(|row| matrix[row][col])</span><br><span class="line">                .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">matrix</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transposed</span> = <span class="title function_ invoke__">transpose</span>(matrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> transposed &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-查找重复元素"><a href="#10-4-查找重复元素" class="headerlink" title="10.4 查找重复元素"></a>10.4 查找重复元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_duplicates</span>(numbers: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">seen</span> = HashSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">duplicates</span> = HashSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;&amp;num| !seen.<span class="title function_ invoke__">insert</span>(num))</span><br><span class="line">        .for_each(|&amp;num| &#123; duplicates.<span class="title function_ invoke__">insert</span>(num); &#125;);</span><br><span class="line"></span><br><span class="line">    duplicates.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dups</span> = <span class="title function_ invoke__">find_duplicates</span>(&amp;numbers);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;重复的元素: &#123;:?&#125;&quot;</span>, dups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5-分组和聚合"><a href="#10-5-分组和聚合" class="headerlink" title="10.5 分组和聚合"></a>10.5 分组和聚合</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sale</span> &#123;</span><br><span class="line">    product: <span class="type">String</span>,</span><br><span class="line">    amount: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">group_by_product</span>(sales: <span class="type">Vec</span>&lt;Sale&gt;) <span class="punctuation">-&gt;</span> HashMap&lt;<span class="type">String</span>, <span class="type">f64</span>&gt; &#123;</span><br><span class="line">    sales.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">fold</span>(HashMap::<span class="title function_ invoke__">new</span>(), |<span class="keyword">mut</span> map, sale| &#123;</span><br><span class="line">            *map.<span class="title function_ invoke__">entry</span>(sale.product).<span class="title function_ invoke__">or_insert</span>(<span class="number">0.0</span>) += sale.amount;</span><br><span class="line">            map</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sales</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Sale &#123; product: <span class="string">&quot;苹果&quot;</span>.<span class="title function_ invoke__">to_string</span>(), amount: <span class="number">100.0</span> &#125;,</span><br><span class="line">        Sale &#123; product: <span class="string">&quot;香蕉&quot;</span>.<span class="title function_ invoke__">to_string</span>(), amount: <span class="number">50.0</span> &#125;,</span><br><span class="line">        Sale &#123; product: <span class="string">&quot;苹果&quot;</span>.<span class="title function_ invoke__">to_string</span>(), amount: <span class="number">150.0</span> &#125;,</span><br><span class="line">        Sale &#123; product: <span class="string">&quot;橙子&quot;</span>.<span class="title function_ invoke__">to_string</span>(), amount: <span class="number">80.0</span> &#125;,</span><br><span class="line">        Sale &#123; product: <span class="string">&quot;香蕉&quot;</span>.<span class="title function_ invoke__">to_string</span>(), amount: <span class="number">30.0</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">totals</span> = <span class="title function_ invoke__">group_by_product</span>(sales);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (product, total) <span class="keyword">in</span> totals &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;:.2&#125;&quot;</span>, product, total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-迭代器与错误处理"><a href="#11-迭代器与错误处理" class="headerlink" title="11. 迭代器与错误处理"></a>11. 迭代器与错误处理</h2><h3 id="11-1-filter-map-过滤和映射"><a href="#11-1-filter-map-过滤和映射" class="headerlink" title="11.1 filter_map - 过滤和映射"></a>11.1 filter_map - 过滤和映射</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = strings.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|s| s.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;解析成功的数字: &#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-处理-Result-序列"><a href="#11-2-处理-Result-序列" class="headerlink" title="11.2 处理 Result 序列"></a>11.2 处理 Result 序列</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;4&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1: collect 到 Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, _&gt; = strings.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|s| s.parse::&lt;<span class="type">i32</span>&gt;())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(numbers) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;所有解析成功: &#123;:?&#125;&quot;</span>, numbers),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;解析失败: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2: 使用 filter_map 跳过错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = strings.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|s| s.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;部分解析成功: &#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-性能优化技巧"><a href="#12-性能优化技巧" class="headerlink" title="12. 性能优化技巧"></a>12. 性能优化技巧</h2><h3 id="12-1-使用-drain-避免复制"><a href="#12-1-使用-drain-避免复制" class="headerlink" title="12.1 使用 drain 避免复制"></a>12.1 使用 drain 避免复制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drain 会移除并返回元素，避免复制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_three</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">drain</span>(<span class="number">0</span>..<span class="number">3</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;提取的: &#123;:?&#125;&quot;</span>, first_three);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;剩余的: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-避免重复计算"><a href="#12-2-避免重复计算" class="headerlink" title="12.2 避免重复计算"></a>12.2 避免重复计算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不好：重复调用 iter()</span></span><br><span class="line">    <span class="comment">// let sum: i32 = numbers.iter().sum();</span></span><br><span class="line">    <span class="comment">// let count = numbers.iter().count();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好：使用 fold 一次遍历</span></span><br><span class="line">    <span class="keyword">let</span> (sum, count) = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">fold</span>((<span class="number">0</span>, <span class="number">0</span>), |(sum, count), &amp;x| (sum + x, count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总和: &#123;&#125;, 数量: &#123;&#125;&quot;</span>, sum, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-使用-by-ref-保留迭代器"><a href="#12-3-使用-by-ref-保留迭代器" class="headerlink" title="12.3 使用 by_ref 保留迭代器"></a>12.3 使用 by_ref 保留迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 by_ref 只消费部分迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_two</span>: <span class="type">Vec</span>&lt;_&gt; = iter.<span class="title function_ invoke__">by_ref</span>().<span class="title function_ invoke__">take</span>(<span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;前两个: &#123;:?&#125;&quot;</span>, first_two);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续使用剩余的迭代器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rest</span>: <span class="type">Vec</span>&lt;_&gt; = iter.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;剩余的: &#123;:?&#125;&quot;</span>, rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器是 Rust 中处理序列数据的核心工具，掌握它能让你的代码更加：</p><ul><li><strong>简洁优雅</strong>：用链式调用替代复杂的循环逻辑</li><li><strong>安全可靠</strong>：编译期保证类型安全，避免越界访问</li><li><strong>高效性能</strong>：零成本抽象，编译后性能与手写循环相当</li><li><strong>函数式风格</strong>：结合闭包实现声明式编程</li><li><strong>可组合性</strong>：多个简单操作组合成复杂的数据处理管道</li></ul><p>迭代器与闭包是 Rust 函数式编程的两大支柱，它们共同构成了 Rust 中优雅而高效的数据处理范式。熟练运用迭代器，是编写惯用 Rust 代码的必备技能。</p><p><strong>Hooray！Iterators 小节完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 闭包</title>
      <link href="/2025/10/06/rust-closures/"/>
      <url>/2025/10/06/rust-closures/</url>
      
        <content type="html"><![CDATA[<p>闭包（Closure）是 Rust 中一种可以捕获环境变量的匿名函数。与普通函数不同，闭包可以保存在变量中、作为参数传递给其他函数，并且能够捕获定义时所在作用域的变量。闭包是 Rust 函数式编程特性的核心组成部分。</p><h2 id="1-闭包基础"><a href="#1-闭包基础" class="headerlink" title="1. 闭包基础"></a>1. 闭包基础</h2><h3 id="1-1-定义闭包"><a href="#1-1-定义闭包" class="headerlink" title="1.1 定义闭包"></a>1.1 定义闭包</h3><p>闭包使用 <code>||</code> 语法定义，参数放在竖线之间，函数体跟在后面：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个闭包：接受参数 x，返回 x + 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one</span> = |x| x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用闭包，就像调用函数一样</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">5</span>)); <span class="comment">// 输出: 结果: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-闭包的语法形式"><a href="#1-2-闭包的语法形式" class="headerlink" title="1.2 闭包的语法形式"></a>1.2 闭包的语法形式</h3><p>闭包有多种等价的写法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 完整的类型标注（最详细，但通常不需要）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v1</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略返回类型（编译器可以推断）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略参数类型（编译器可以推断）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x| &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单行表达式可省略花括号（最简洁）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x| x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one_v4</span>(<span class="number">5</span>)); <span class="comment">// 输出: 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一旦闭包的类型被推断确定，就不能再用不同类型调用它。</p><h3 id="1-3-闭包与函数的对比"><a href="#1-3-闭包与函数的对比" class="headerlink" title="1.3 闭包与函数的对比"></a>1.3 闭包与函数的对比</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_fn</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;  <span class="comment">// 普通函数定义</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_cl</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;; <span class="comment">// 闭包定义</span></span><br></pre></td></tr></table></figure><p><strong>主要区别</strong>：</p><ul><li>闭包使用 <code>||</code> 而不是 <code>()</code></li><li>闭包的类型标注通常是可选的（可以被推断）</li><li><strong>最重要的区别</strong>：闭包可以捕获环境变量，函数不能</li></ul><h2 id="2-捕获环境"><a href="#2-捕获环境" class="headerlink" title="2. 捕获环境"></a>2. 捕获环境</h2><h3 id="2-1-不可变借用"><a href="#2-1-不可变借用" class="headerlink" title="2.1 不可变借用"></a>2.1 不可变借用</h3><p>闭包默认以最小权限捕获变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;定义闭包前: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个闭包只是读取 list，所以使用不可变借用</span></span><br><span class="line">    <span class="comment">// 闭包&quot;捕获&quot;了外部的 list 变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">only_borrows</span> = || <span class="built_in">println!</span>(<span class="string">&quot;闭包中: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;调用闭包前: &#123;:?&#125;&quot;</span>, list); <span class="comment">// list 仍然可用</span></span><br><span class="line">    <span class="title function_ invoke__">only_borrows</span>(); <span class="comment">// 调用闭包</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;调用闭包后: &#123;:?&#125;&quot;</span>, list); <span class="comment">// list 仍然可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-可变借用"><a href="#2-2-可变借用" class="headerlink" title="2.2 可变借用"></a>2.2 可变借用</h3><p>如果闭包需要修改变量，会自动使用可变借用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;调用前: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个闭包修改了 list，所以使用可变借用</span></span><br><span class="line">    <span class="comment">// 注意：闭包本身也要声明为 mut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">borrows_mutably</span> = || list.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrows_mutably</span>(); <span class="comment">// 调用闭包，修改 list</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;调用后: &#123;:?&#125;&quot;</span>, list); <span class="comment">// 输出: [1, 2, 3, 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-获取所有权"><a href="#2-3-获取所有权" class="headerlink" title="2.3 获取所有权"></a>2.3 获取所有权</h3><p>在某些情况下，闭包会获取变量的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;主线程: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move 关键字强制闭包获取 list 的所有权</span></span><br><span class="line">    <span class="comment">// 这在多线程中很常见，因为新线程需要拥有数据</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;线程中: &#123;:?&#125;&quot;</span>, list))</span><br><span class="line">        .<span class="title function_ invoke__">join</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, list); // 错误！list 已被移动到闭包中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 <code>move</code> 关键字强制闭包获取所有权，这在多线程编程中很常见。</p><h2 id="3-闭包的三种-Trait"><a href="#3-闭包的三种-Trait" class="headerlink" title="3. 闭包的三种 Trait"></a>3. 闭包的三种 Trait</h2><p>Rust 的闭包会自动实现以下一个或多个 trait，这决定了闭包如何使用捕获的变量：</p><h3 id="3-1-Fn-不可变借用"><a href="#3-1-Fn-不可变借用" class="headerlink" title="3.1 Fn - 不可变借用"></a>3.1 Fn - 不可变借用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受一个实现了 Fn trait 的闭包</span></span><br><span class="line"><span class="comment">// Fn(i32) -&gt; i32 表示：接受 i32 参数，返回 i32</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply_fn</span>&lt;F&gt;(f: F, x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, <span class="comment">// F 必须实现 Fn trait</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(x) <span class="comment">// 调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>; <span class="comment">// 这个闭包实现了 Fn trait</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply_fn</span>(double, <span class="number">5</span>)); <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>闭包只是读取捕获的变量（不可变借用）</li><li>可以被多次调用</li><li>最灵活的闭包类型</li></ul><h3 id="3-2-FnMut-可变借用"><a href="#3-2-FnMut-可变借用" class="headerlink" title="3.2 FnMut - 可变借用"></a>3.2 FnMut - 可变借用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受一个实现了 FnMut trait 的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply_fn_mut</span>&lt;F&gt;(<span class="keyword">mut</span> f: F, x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, <span class="comment">// F 必须实现 FnMut trait</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个闭包修改了 total，所以实现了 FnMut trait</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">accumulate</span> = |x| &#123;</span><br><span class="line">        total += x; <span class="comment">// 修改外部变量</span></span><br><span class="line">        total</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;累加后: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">accumulate</span>(<span class="number">5</span>));  <span class="comment">// 输出: 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;累加后: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">accumulate</span>(<span class="number">3</span>));  <span class="comment">// 输出: 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>闭包修改了捕获的变量（可变借用）</li><li>可以被多次调用</li><li>需要声明为 <code>mut</code></li></ul><h3 id="3-3-FnOnce-消耗捕获的变量"><a href="#3-3-FnOnce-消耗捕获的变量" class="headerlink" title="3.3 FnOnce - 消耗捕获的变量"></a>3.3 FnOnce - 消耗捕获的变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受一个实现了 FnOnce trait 的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_closure</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(), <span class="comment">// F 必须实现 FnOnce trait</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>(); <span class="comment">// 只能调用一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个闭包会消耗（drop）s，所以只实现了 FnOnce trait</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = || <span class="title function_ invoke__">drop</span>(s); <span class="comment">// drop 会获取 s 的所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">consume_with_closure</span>(consume);</span><br><span class="line">    <span class="comment">// consume_with_closure(consume); // 错误！闭包已被消费</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s); // 错误！s 已被移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>闭包获取并消耗了捕获变量的所有权</li><li>只能被调用一次</li><li>最受限的闭包类型</li></ul><h2 id="4-实际应用示例"><a href="#4-实际应用示例" class="headerlink" title="4. 实际应用示例"></a>4. 实际应用示例</h2><h3 id="4-1-结合迭代器使用"><a href="#4-1-结合迭代器使用" class="headerlink" title="4.1 结合迭代器使用"></a>4.1 结合迭代器使用</h3><p>闭包最常见的用法是和迭代器一起使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map: 使用闭包将每个元素加倍</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>) <span class="comment">// 闭包：每个元素乘以 2</span></span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;翻倍后: &#123;:?&#125;&quot;</span>, doubled); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter: 使用闭包过滤出偶数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">evens</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">i32</span>&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 闭包：判断是否为偶数</span></span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;偶数: &#123;:?&#125;&quot;</span>, evens); <span class="comment">// [2, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-结合-sort-by-key-使用"><a href="#4-2-结合-sort-by-key-使用" class="headerlink" title="4.2 结合 sort_by_key 使用"></a>4.2 结合 sort_by_key 使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">users</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        User &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>), age: <span class="number">30</span> &#125;,</span><br><span class="line">        User &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>), age: <span class="number">25</span> &#125;,</span><br><span class="line">        User &#123; name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Charlie&quot;</span>), age: <span class="number">35</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort_by_key 接受一个闭包，用于提取排序的键</span></span><br><span class="line">    users.<span class="title function_ invoke__">sort_by_key</span>(|u| u.age); <span class="comment">// 闭包：提取 age 字段进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;按年龄排序: &#123;:#?&#125;&quot;</span>, users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-延迟计算"><a href="#4-3-延迟计算" class="headerlink" title="4.3 延迟计算"></a>4.3 延迟计算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个缓存结构，只在第一次调用时计算</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>, <span class="comment">// T 是一个闭包类型</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,      <span class="comment">// 存储闭包</span></span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,  <span class="comment">// 存储计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>, <span class="comment">// 初始时没有值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v, <span class="comment">// 如果已经计算过，直接返回</span></span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="comment">// 第一次调用，执行闭包计算</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v); <span class="comment">// 缓存结果</span></span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个&quot;昂贵&quot;的计算闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;慢速计算中...&quot;</span>);</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, expensive.<span class="title function_ invoke__">value</span>(<span class="number">10</span>)); <span class="comment">// 第一次：会执行计算</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, expensive.<span class="title function_ invoke__">value</span>(<span class="number">10</span>)); <span class="comment">// 第二次：直接返回缓存的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-闭包与所有权"><a href="#5-闭包与所有权" class="headerlink" title="5. 闭包与所有权"></a>5. 闭包与所有权</h2><h3 id="5-1-Copy-类型的捕获"><a href="#5-1-Copy-类型的捕获" class="headerlink" title="5.1 Copy 类型的捕获"></a>5.1 Copy 类型的捕获</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// i32 实现了 Copy trait</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// move 关键字：闭包获取 x 的所有权</span></span><br><span class="line">    <span class="comment">// 但因为 i32 是 Copy 类型，实际上是复制了一份</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 仍可用: &#123;&#125;&quot;</span>, x); <span class="comment">// 5，x 仍然有效（因为被复制了）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y)); <span class="comment">// 闭包使用的是 x 的副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-非-Copy-类型的捕获"><a href="#5-2-非-Copy-类型的捕获" class="headerlink" title="5.2 非 Copy 类型的捕获"></a>5.2 非 Copy 类型的捕获</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// String 没有实现 Copy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包通过不可变借用捕获 s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">print_s</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_s</span>(); <span class="comment">// 第一次调用</span></span><br><span class="line">    <span class="title function_ invoke__">print_s</span>(); <span class="comment">// 第二次调用，因为只是借用，可以多次调用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// s 仍然有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-move-导致的所有权转移"><a href="#5-3-move-导致的所有权转移" class="headerlink" title="5.3 move 导致的所有权转移"></a>5.3 move 导致的所有权转移</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// String 没有实现 Copy</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// move 关键字：强制闭包获取 s 的所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_s</span> = s; <span class="comment">// s 被移动到闭包内部</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">consume</span>(); <span class="comment">// 调用闭包，s 被消耗</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s); // 错误！s 的所有权已经转移给闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数指针与闭包"><a href="#6-函数指针与闭包" class="headerlink" title="6. 函数指针与闭包"></a>6. 函数指针与闭包</h2><p>函数指针可以作为不捕获环境的闭包使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受函数指针作为参数</span></span><br><span class="line"><span class="comment">// fn(i32) -&gt; i32 是函数指针类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg) <span class="comment">// 调用函数两次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 传递函数指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, answer); <span class="comment">// 12 (6 + 6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以传递闭包（如果闭包不捕获环境）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer2</span> = <span class="title function_ invoke__">do_twice</span>(|x| x + <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, answer2); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-返回闭包"><a href="#7-返回闭包" class="headerlink" title="7. 返回闭包"></a>7. 返回闭包</h2><p>由于闭包的大小在编译时未知，返回闭包需要使用 trait 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Box 包装闭包，因为闭包的大小未知</span></span><br><span class="line"><span class="comment">// dyn Fn(i32) -&gt; i32 表示&quot;任何实现了 Fn(i32) -&gt; i32 的类型&quot;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>) <span class="comment">// 将闭包装箱返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">returns_closure</span>(); <span class="comment">// f 的类型是 Box&lt;dyn Fn(i32) -&gt; i32&gt;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">5</span>)); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或使用 <code>impl Trait</code> 语法（更简洁，但需要单一具体类型）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl Fn(i32) -&gt; i32 表示&quot;返回某个实现了 Fn(i32) -&gt; i32 的类型&quot;</span></span><br><span class="line"><span class="comment">// 编译器会自动推断具体类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">returns_closure</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">5</span>)); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-常见应用场景"><a href="#8-常见应用场景" class="headerlink" title="8. 常见应用场景"></a>8. 常见应用场景</h2><h3 id="8-1-错误处理"><a href="#8-1-错误处理" class="headerlink" title="8.1 错误处理"></a>8.1 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;4&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter_map: 结合过滤和映射</span></span><br><span class="line">    <span class="comment">// parse().ok() 将 Result 转换为 Option，失败时返回 None</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|s| s.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">ok</span>()) <span class="comment">// 闭包：尝试解析，只保留成功的</span></span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;解析成功: &#123;:?&#125;&quot;</span>, parsed); <span class="comment">// [1, 2, 4]（&quot;three&quot;被过滤掉了）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-自定义迭代器适配器"><a href="#8-2-自定义迭代器适配器" class="headerlink" title="8.2 自定义迭代器适配器"></a>8.2 自定义迭代器适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用多个闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = numbers.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x * x)         <span class="comment">// 闭包1：计算平方</span></span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 闭包2：过滤偶数</span></span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();                  <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;偶数平方和: &#123;&#125;&quot;</span>, sum); <span class="comment">// 4 + 16 = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-回调函数"><a href="#8-3-回调函数" class="headerlink" title="8.3 回调函数"></a>8.3 回调函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个闭包作为回调函数</span></span><br><span class="line"><span class="comment">// F: Fn(i32) 表示 F 是一个接受 i32 参数的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_data</span>&lt;F&gt;(data: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, callback: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>), <span class="comment">// 回调函数类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> data &#123;</span><br><span class="line">        <span class="title function_ invoke__">callback</span>(item); <span class="comment">// 对每个元素调用回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递一个闭包作为回调</span></span><br><span class="line">    <span class="title function_ invoke__">process_data</span>(data, |x| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;处理: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包是 Rust 中强大而灵活的特性，它能够：</p><ul><li><strong>简洁表达</strong>：用简短的语法定义匿名函数</li><li><strong>捕获环境</strong>：访问定义时作用域内的变量</li><li><strong>类型推断</strong>：编译器自动推断参数和返回值类型</li><li><strong>零成本抽象</strong>：编译后性能与手写代码相当</li><li><strong>灵活的所有权</strong>：根据需要选择借用或移动语义</li></ul><p><strong>三种 Trait 总结</strong>：</p><ul><li><code>Fn</code>：只读取捕获的变量，可以多次调用</li><li><code>FnMut</code>：可以修改捕获的变量，可以多次调用</li><li><code>FnOnce</code>：会消耗捕获的变量，只能调用一次</li></ul><p>掌握闭包是编写惯用的、高性能 Rust 代码的关键。它们与迭代器结合使用，能够写出既简洁又高效的代码，是 Rust 函数式编程风格的核心。</p><p><strong>Hooray！Closures 小节完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— OP Stack 介绍</title>
      <link href="/2025/10/05/op-stack-intro-part5/"/>
      <url>/2025/10/05/op-stack-intro-part5/</url>
      
        <content type="html"><![CDATA[<p>OP Stack 是由 Optimism 团队开发的模块化区块链技术栈，让开发者能够像”搭积木”一样构建自己的 Layer2 网络。可以将 OP Stack 想象成一个”区块链建设套件”，里面包含了构建高性能区块链所需的所有核心组件。</p><h2 id="1-核心要点"><a href="#1-核心要点" class="headerlink" title="1. 核心要点"></a>1. 核心要点</h2><ul><li><strong>Optimistic Rollup 技术</strong>：采用”乐观验证”机制——默认信任交易是正确的，只在出现争议时才进行验证</li><li><strong>完全 EVM 兼容</strong>：现有的以太坊智能合约可以无需修改直接部署</li><li><strong>安全性继承</strong>：通过将数据发布到以太坊主网，继承了以太坊 L1 的安全性</li><li><strong>模块化设计</strong>：各个组件职责明确，可以独立升级和替换</li><li><strong>六大核心组件</strong>：op-geth（执行引擎）、op-node（共识层）、op-batcher（批处理器）、op-proposer（状态提议器）、op-challenger（争议挑战器）和 L1 合约系统</li></ul><p><strong>性能提升对比：</strong></p><table><thead><tr><th>指标</th><th>以太坊 L1</th><th>OP Stack L2</th><th>提升倍数</th></tr></thead><tbody><tr><td>TPS</td><td>15-30</td><td>150-2000</td><td>10-100x</td></tr><tr><td>出块时间</td><td>12 秒</td><td>2 秒</td><td>6x 加速</td></tr><tr><td>交易费用</td><td>5-50 USD</td><td>0.01-0.5 USD</td><td>降低 90%+</td></tr></tbody></table><h2 id="2-为什么需要-OP-Stack？"><a href="#2-为什么需要-OP-Stack？" class="headerlink" title="2. 为什么需要 OP Stack？"></a>2. 为什么需要 OP Stack？</h2><h3 id="2-1-Rollup-解决方案"><a href="#2-1-Rollup-解决方案" class="headerlink" title="2.1 Rollup 解决方案"></a>2.1 Rollup 解决方案</h3><p>OP Stack 采用 <strong>Rollup</strong> 技术——将计算和状态存储移到链下（Layer2），只把交易数据和最终状态发布到链上（Layer1）。</p><p><strong>工作原理类比：</strong> 想象你在玩一个复杂的棋局：</p><ul><li><strong>传统方式</strong>：每走一步都要裁判（以太坊主网）记录并验证</li><li><strong>Rollup 方式</strong>：你们自己下完整局（L2 执行），最后只把完整棋谱交给裁判存档（L1 数据发布）</li></ul><p>这样做的好处：减轻主网计算负担、降低交易成本、保持安全性。</p><h3 id="2-2-Optimistic-的”乐观”哲学"><a href="#2-2-Optimistic-的”乐观”哲学" class="headerlink" title="2.2 Optimistic 的”乐观”哲学"></a>2.2 Optimistic 的”乐观”哲学</h3><p>OP Stack 采用 <strong>Optimistic Rollup</strong>，核心理念是”乐观假设”：</p><ul><li><strong>默认信任</strong>：假设所有提交的状态都是正确的</li><li><strong>挑战期机制</strong>：给予 7 天时间让任何人挑战错误状态</li><li><strong>欺诈证明</strong>：只有在出现争议时才进行链上验证</li></ul><p>这就像是”先上车后补票”——大部分情况下大家都诚实，只有少数情况需要核查。</p><h2 id="3-OP-Stack-整体架构"><a href="#3-OP-Stack-整体架构" class="headerlink" title="3. OP Stack 整体架构"></a>3. OP Stack 整体架构</h2><p>OP Stack 采用分层架构，每一层都有明确的职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                 L1 (以太坊主网)                      │</span><br><span class="line">│  ┌──────────────┐    ┌──────────────────────┐       │</span><br><span class="line">│  │ L1 桥接合约   │    │ 争议解决合约          │       │</span><br><span class="line">│  └──────────────┘    └──────────────────────┘       │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br><span class="line">                         ↕</span><br><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                 L2 执行与共识层                      │</span><br><span class="line">│  ┌──────────┐  ┌──────────┐  ┌──────────────┐       │</span><br><span class="line">│  │ op-geth  │◄─│ op-node  │◄─│ op-batcher   │       │</span><br><span class="line">│  └──────────┘  └──────────┘  └──────────────┘       │</span><br><span class="line">│       ↓             ↓                               │</span><br><span class="line">│  ┌──────────────┐  ┌─────────────────┐              │</span><br><span class="line">│  │ op-proposer  │  │  op-challenger  │              │</span><br><span class="line">│  └──────────────┘  └─────────────────┘              │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>关键设计原则：</strong></p><ul><li><strong>数据可用性</strong>：所有交易数据都发布到 L1，确保任何人都能重建 L2 状态</li><li><strong>模块化解耦</strong>：每个组件可以独立升级</li><li><strong>最小信任假设</strong>：只需假设”至少有一个诚实的验证者存在”</li></ul><h2 id="4-核心组件详解"><a href="#4-核心组件详解" class="headerlink" title="4. 核心组件详解"></a>4. 核心组件详解</h2><h3 id="4-1-op-geth：执行引擎"><a href="#4-1-op-geth：执行引擎" class="headerlink" title="4.1 op-geth：执行引擎"></a>4.1 op-geth：执行引擎</h3><p><strong>角色定位：</strong> L2 的”大脑”，负责执行交易和维护状态</p><p>op-geth 是基于以太坊官方 go-ethereum 客户端的定制版本，保持了 100% 的 EVM 兼容性。</p><p><strong>核心功能：</strong></p><ol><li><strong>交易执行</strong>：接收用户交易，在 EVM 中执行智能合约代码，计算新状态</li><li><strong>状态管理</strong>：维护完整的账户和合约状态树，使用 Archive 模式保存所有历史状态</li><li><strong>与 op-node 协作</strong>：通过 Engine API 接收区块生产指令，执行交易并返回结果</li></ol><p><strong>关键特性：</strong></p><p><strong>Gas 计费改进</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总费用 = L2 执行费 + L1 数据费</span><br></pre></td></tr></table></figure><ul><li><strong>L2 执行费</strong>：合约计算消耗（类似以太坊）</li><li><strong>L1 数据费</strong>：将交易数据发布到 L1 的成本（主要开销）</li></ul><p><strong>区块生产方式</strong></p><ul><li>不同于以太坊的 PoW&#x2F;PoS，op-geth 由 Sequencer 主导区块生产</li><li>支持固定的出块时间（如每 2 秒一个区块）</li></ul><h3 id="4-2-op-node：Rollup-共识协调者"><a href="#4-2-op-node：Rollup-共识协调者" class="headerlink" title="4.2 op-node：Rollup 共识协调者"></a>4.2 op-node：Rollup 共识协调者</h3><p><strong>角色定位：</strong> L2 的”协调员”，连接 L1 和 L2，负责共识逻辑</p><p>如果说 op-geth 是执行者，那么 op-node 就是指挥官。</p><p><strong>核心职责：</strong></p><p><strong>1. 区块派生（Block Derivation）</strong></p><p>这是 op-node 最核心的功能。它从 L1 上读取 Batcher 提交的交易批次，然后”派生”出 L2 区块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1 区块 → 扫描 Batcher 交易 → 提取批次数据 → 解压缩</span><br><span class="line">  → 解析交易列表 → 构建 L2 区块 → 发送给 op-geth 执行</span><br></pre></td></tr></table></figure><p><strong>为什么需要派生？</strong> 因为 L2 区块的权威来源是 L1 上的数据，而不是 Sequencer 的声明。即使 Sequencer 作恶或下线，任何人都可以通过 L1 数据重建完整的 L2 链。</p><p><strong>2. Sequencer 模式 vs Verifier 模式</strong></p><ul><li><strong>Sequencer 模式</strong>：作为主节点运行，接收交易、排序、生产区块</li><li><strong>Verifier 模式</strong>：作为从节点运行，完全依赖 L1 数据进行区块派生和验证</li></ul><p><strong>3. 三种区块状态</strong></p><p>op-node 维护着区块的三种不同状态：</p><table><thead><tr><th>状态</th><th>含义</th><th>确认时间</th><th>安全保障</th></tr></thead><tbody><tr><td><strong>Unsafe</strong></td><td>刚由 Sequencer 生产</td><td>2 秒</td><td>可能被重组</td></tr><tr><td><strong>Safe</strong></td><td>已提交到 L1 并确认</td><td>1-2 分钟</td><td>数据可用性保证</td></tr><tr><td><strong>Finalized</strong></td><td>状态根已确认且过挑战期</td><td>7 天</td><td>可用于 L1 提款</td></tr></tbody></table><h3 id="4-3-op-batcher：批量打包器"><a href="#4-3-op-batcher：批量打包器" class="headerlink" title="4.3 op-batcher：批量打包器"></a>4.3 op-batcher：批量打包器</h3><p><strong>角色定位：</strong> L2 到 L1 的”快递员”，负责将交易数据运送到主网</p><p>Batcher 是整个系统中持续运营成本最高的组件——它需要不断向 L1 发送交易。</p><p><strong>工作机制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L2 交易 → op-geth 执行 → op-node 区块 → op-batcher 收集</span><br><span class="line">  → 压缩打包 → 提交到 L1 → 验证者读取 → 重建 L2 状态</span><br></pre></td></tr></table></figure><p><strong>核心功能：</strong></p><p><strong>1. 交易收集与压缩</strong></p><ul><li>定期（如每 1 秒）从 op-node 拉取最新的 Unsafe 区块</li><li>使用 zlib&#x2F;brotli 压缩数据（压缩率 5-10x）</li><li>按照 Channel（通道）的概念组织数据</li></ul><p><strong>2. 批次提交方式</strong></p><p>有两种提交方式：</p><table><thead><tr><th>方式</th><th>特点</th><th>成本</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Calldata</strong></td><td>永久存储</td><td>高（每字节 16 gas）</td><td>需要长期数据可用性</td></tr><tr><td><strong>Blob (EIP-4844)</strong></td><td>保留 30 天</td><td>低（降低 90%）</td><td>标准运营（推荐）</td></tr></tbody></table><p><strong>3. 费用优化</strong></p><ul><li>监控 L1 Gas 价格波动，在低价时段批量提交</li><li>支持交易失败后自动重发</li><li>避免 nonce 冲突导致的交易卡顿</li></ul><h3 id="4-4-op-proposer：状态提议器"><a href="#4-4-op-proposer：状态提议器" class="headerlink" title="4.4 op-proposer：状态提议器"></a>4.4 op-proposer：状态提议器</h3><p><strong>角色定位：</strong> L2 到 L1 的”公证员”，定期提交状态根声明</p><p>Proposer 向以太坊主网”宣告”L2 的当前状态，这些声明在经过挑战期后成为最终确定的状态。</p><p><strong>核心功能：</strong></p><p><strong>1. 状态根提交</strong></p><p>什么是状态根？</p><ul><li>状态根是整个 L2 状态的”指纹”（Merkle Root）</li><li>它唯一确定了某个区块高度时所有账户和合约的状态</li></ul><p><strong>工作流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 从 op-node 获取 Safe 区块的状态根</span><br><span class="line">2. 调用 L1 的 DisputeGameFactory 合约创建提议</span><br><span class="line">3. 质押 Bond（如 0.08 ETH）作为诚实保证金</span><br><span class="line">4. 提议进入 7 天挑战期</span><br><span class="line">5. 无人挑战 → 提议被接受 → 取回 Bond</span><br><span class="line">6. 挑战成功 → 提议被拒绝 → Bond 被罚没</span><br></pre></td></tr></table></figure><p><strong>2. 提议间隔控制</strong></p><p>Proposer 不会每个区块都提交状态根（成本太高），而是每隔固定时间提交一次（如 15 分钟），平衡安全性和成本。</p><p><strong>3. 最终性推进</strong></p><p>只有经过挑战期的状态根才能用于：</p><ul><li>用户从 L2 提款到 L1</li><li>跨链消息的最终确认</li><li>资产桥的安全释放</li></ul><p><strong>经济模型：</strong></p><ul><li><strong>Bond 质押</strong>：每次提议需质押 0.08 ETH（可配置）</li><li><strong>L1 Gas 费</strong>：提交提议的交易费用</li><li><strong>诚实提议</strong>：7 天后取回 Bond（零成本）</li><li><strong>错误提议</strong>：失去全部 Bond（被 Challenger 夺取）</li></ul><h3 id="4-5-op-challenger：争议挑战器"><a href="#4-5-op-challenger：争议挑战器" class="headerlink" title="4.5 op-challenger：争议挑战器"></a>4.5 op-challenger：争议挑战器</h3><p><strong>角色定位：</strong> 系统的”安全卫士”，监督并挑战错误的状态提议</p><p>Challenger 是 OP Stack 安全模型的核心——它实现了”只需一个诚实节点”的信任假设。</p><p><strong>核心职责：</strong></p><p><strong>1. 持续监控</strong></p><ul><li>7x24 小时监听 L1 上所有新创建的争议游戏</li><li>从 op-node 获取本地计算的正确状态根</li><li>对比链上提议与本地状态，检测差异</li></ul><p><strong>2. 发起挑战</strong></p><p>当检测到错误提议时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 质押 Bond 创建挑战</span><br><span class="line">2. 参与多轮交互式欺诈证明游戏</span><br><span class="line">3. 最终提交单步证明证明 Proposer 错误</span><br><span class="line">4. 胜利后夺取 Proposer 的 Bond</span><br></pre></td></tr></table></figure><p><strong>3. Fault Proof Game（欺诈证明游戏）</strong></p><p>这是 OP Stack V2 的核心创新机制：</p><p><strong>游戏流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第 1 轮：二分查找开始</span><br><span class="line">  Challenger 质疑：区块 1000-1100 中某处有错误</span><br><span class="line">  → 要求 Proposer 证明区块 1050 的状态</span><br><span class="line"></span><br><span class="line">第 2-N 轮：持续二分</span><br><span class="line">  → 缩小范围：100 个区块 → 50 → 25 → ... → 1 个区块</span><br><span class="line">  → 继续缩小：1 个区块 → 单个交易 → 单个 EVM 指令</span><br><span class="line"></span><br><span class="line">最后一轮：单步证明</span><br><span class="line">  → 定位到单个 MIPS 指令</span><br><span class="line">  → Challenger 在 L1 上实际执行这条指令</span><br><span class="line">  → 证明 Proposer 声称的输出错误</span><br><span class="line">  → Challenger 胜利，夺取 Bond</span><br></pre></td></tr></table></figure><p><strong>CANNON 证明系统：</strong></p><ul><li>将 op-geth 和 op-node 编译为 MIPS 指令集</li><li>创建 MIPS 虚拟机的链上实现</li><li>在争议时，在 L1 上执行单个 MIPS 指令进行验证</li></ul><p><strong>为什么这套机制有效？</strong></p><p><strong>经济激励：</strong></p><ul><li>挑战成功 → 获得 Proposer 的 Bond</li><li>挑战失败 → 失去自己的 Bond</li><li>诚实参与是最优策略</li></ul><p><strong>1-of-N 诚实假设：</strong></p><ul><li>只需一个诚实 Challenger 存在即可保证安全</li><li>任何人都可以无需许可地运行 Challenger</li></ul><p><strong>谁应该运行 Challenger？</strong></p><ul><li>桥接服务提供商：保护管理的资金</li><li>大户投资者：保护大额 L2 资产</li><li>生态贡献者：为公共利益提供监督</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li><strong>OP Stack 是一个完整的 L2 建设工具包</strong>：包含执行、共识、数据发布、争议解决等所有模块</li><li><strong>采用 Optimistic Rollup 技术</strong>：通过”乐观假设”实现高性能，7 天挑战期保证安全</li><li><strong>1-of-N 安全假设</strong>：只需一个诚实 Challenger 即可保护全网</li><li><strong>性能提升显著</strong>：相比以太坊 L1，TPS 提升 10-100 倍，成本降低 90%+</li><li><strong>完全 EVM 兼容</strong>：现有 DApp 可无缝迁移</li></ul><p><strong>Hooray！OP Stack 介绍完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> OPStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— SPL TOKEN 简单合约</title>
      <link href="/2025/10/04/solana-spl-token/"/>
      <url>/2025/10/04/solana-spl-token/</url>
      
        <content type="html"><![CDATA[<p>本节实现了一个 Solana SPL Token 程序，包括链上智能合约和客户端调用代码。主要功能包括：</p><ul><li>创建新的 SPL Token</li><li>铸造代币到用户账户</li></ul><h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><h3 id="1-1-什么是-SPL-Token"><a href="#1-1-什么是-SPL-Token" class="headerlink" title="1.1 什么是 SPL Token"></a>1.1 什么是 SPL Token</h3><p>SPL Token 是 Solana 上的标准代币协议，类似于以太坊的 ERC-20。它定义了在 Solana 区块链上创建和管理可替代代币的规范。</p><h3 id="1-2-关键账户类型"><a href="#1-2-关键账户类型" class="headerlink" title="1.2 关键账户类型"></a>1.2 关键账户类型</h3><table><thead><tr><th>账户类型</th><th>所有者</th><th>用途</th><th>大小</th></tr></thead><tbody><tr><td>Mint Account</td><td>SPL Token Program</td><td>存储代币元数据（总供应量、小数位数、铸币权限等）</td><td>82 字节</td></tr><tr><td>Token Account</td><td>SPL Token Program</td><td>存储用户持有的特定代币余额</td><td>165 字节</td></tr><tr><td>Associated Token Account (ATA)</td><td>SPL Token Program</td><td>与用户钱包关联的标准代币账户</td><td>165 字节</td></tr></tbody></table><h3 id="1-3-核心程序"><a href="#1-3-核心程序" class="headerlink" title="1.3 核心程序"></a>1.3 核心程序</h3><ul><li><strong>SPL Token Program</strong>：管理代币铸造、转账等操作的核心程序</li><li><strong>Associated Token Account Program</strong>：管理 ATA 的创建和查询</li><li><strong>System Program</strong>：Solana 系统程序，用于创建账户和转账 SOL</li></ul><h2 id="2-链上程序实现"><a href="#2-链上程序实现" class="headerlink" title="2. 链上程序实现"></a>2. 链上程序实现</h2><h3 id="2-1-程序入口"><a href="#2-1-程序入口" class="headerlink" title="2.1 程序入口"></a>2.1 程序入口</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">process</span>(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    accounts: &amp;[AccountInfo],</span><br><span class="line">    instruction_data: &amp;[<span class="type">u8</span>],</span><br><span class="line">) <span class="punctuation">-&gt;</span> ProgramResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction</span> = TokenInstruction::<span class="title function_ invoke__">try_from_slice</span>(instruction_data)?;</span><br><span class="line">    <span class="keyword">match</span> instruction &#123;</span><br><span class="line">        TokenInstruction::CreateToken &#123; decimals &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">create_token</span>(accounts, decimals),</span><br><span class="line">        TokenInstruction::Mint &#123; amount &#125; =&gt; <span class="keyword">Self</span>::<span class="title function_ invoke__">mint</span>(accounts, amount),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>try_from_slice</code>：使用 Borsh 反序列化指令数据</li><li><code>match</code>：根据指令类型路由到不同的处理函数</li><li>支持两种指令：创建代币和铸造代币</li></ul><h3 id="2-2-创建代币流程"><a href="#2-2-创建代币流程" class="headerlink" title="2.2 创建代币流程"></a>2.2 创建代币流程</h3><h4 id="步骤一：账户准备"><a href="#步骤一：账户准备" class="headerlink" title="步骤一：账户准备"></a>步骤一：账户准备</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;        <span class="comment">// Mint 账户</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_authority</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;      <span class="comment">// 铸币权限</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;               <span class="comment">// 支付者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;         <span class="comment">// 租金系统变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;      <span class="comment">// 系统程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;       <span class="comment">// SPL Token 程序</span></span><br></pre></td></tr></table></figure><p>关键点：</p><ul><li><code>next_account_info</code>：按顺序获取账户信息</li><li>账户顺序必须与客户端传入的顺序一致</li><li>每个账户都有特定的用途和权限要求</li></ul><h4 id="步骤二：创建-Mint-账户"><a href="#步骤二：创建-Mint-账户" class="headerlink" title="步骤二：创建 Mint 账户"></a>步骤二：创建 Mint 账户</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    &amp;system_instruction::<span class="title function_ invoke__">create_account</span>(</span><br><span class="line">        payer.key,                                      <span class="comment">// 支付者</span></span><br><span class="line">        mint_account.key,                               <span class="comment">// 新账户地址</span></span><br><span class="line">        (Rent::<span class="title function_ invoke__">get</span>()?).<span class="title function_ invoke__">minimum_balance</span>(Mint::LEN),      <span class="comment">// 租金</span></span><br><span class="line">        Mint::LEN <span class="keyword">as</span> <span class="type">u64</span>,                               <span class="comment">// 账户大小</span></span><br><span class="line">        token_program.key,                              <span class="comment">// 所有者程序</span></span><br><span class="line">    ),</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>invoke</code>：跨程序调用（CPI），调用系统程序创建账户</li><li><code>minimum_balance(Mint::LEN)</code>：计算存储 Mint 数据所需的最低租金</li><li><code>Mint::LEN</code>：Mint 账户固定大小为 82 字节</li><li><code>token_program.key</code>：将账户所有权转给 SPL Token 程序</li></ul><p><strong>租金机制：</strong></p><p>Solana 要求账户保持最低余额以避免被垃圾回收。82 字节 Mint 账户约需 0.00144 SOL（具体金额取决于网络）。这个余额类似于押金，关闭账户时可以完全收回。</p><h4 id="步骤三：初始化-Mint"><a href="#步骤三：初始化-Mint" class="headerlink" title="步骤三：初始化 Mint"></a>步骤三：初始化 Mint</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ix</span> = <span class="title function_ invoke__">initialize_mint</span>(</span><br><span class="line">    &amp;spl_token::<span class="title function_ invoke__">id</span>(),           <span class="comment">// SPL Token 程序 ID</span></span><br><span class="line">    &amp;mint_account.key,          <span class="comment">// Mint 账户地址</span></span><br><span class="line">    &amp;mint_authority.key,        <span class="comment">// 铸币权限所有者</span></span><br><span class="line">    <span class="literal">None</span>,                       <span class="comment">// 冻结权限（可选）</span></span><br><span class="line">    decimals,                   <span class="comment">// 小数位数</span></span><br><span class="line">)?;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(</span><br><span class="line">    &amp;ix,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        mint_authority.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">    &amp;[],  <span class="comment">// 签名种子（此处为空）</span></span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>initialize_mint</code>：构造初始化 Mint 的指令</li><li><code>decimals</code>：代币小数位数（如 USDC 使用 6，表示 1 USDC &#x3D; 1,000,000 基础单位）</li><li><code>None</code>：不设置冻结权限（设置后可冻结用户账户）</li><li><code>invoke_signed</code>：使用签名调用（这里虽然传空数组，但保持接口一致性）</li></ul><p><strong>为什么分两步？</strong></p><ol><li>系统程序只负责创建账户并分配空间</li><li>SPL Token 程序负责初始化 Mint 的具体数据结构</li></ol><p>这种设计符合 Solana 的所有权模型：只有账户的所有者程序才能修改其数据。</p><h3 id="2-3-铸造代币流程"><a href="#2-3-铸造代币流程" class="headerlink" title="2.3 铸造代币流程"></a>2.3 铸造代币流程</h3><h4 id="步骤一：账户准备-1"><a href="#步骤一：账户准备-1" class="headerlink" title="步骤一：账户准备"></a>步骤一：账户准备</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts_iter</span> = &amp;<span class="keyword">mut</span> accounts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;              <span class="comment">// Mint 账户</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_account</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;  <span class="comment">// ATA</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent_sysvar</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;               <span class="comment">// 租金</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;                     <span class="comment">// 支付者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">system_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;            <span class="comment">// 系统程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;             <span class="comment">// Token 程序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">associated_token_program</span> = <span class="title function_ invoke__">next_account_info</span>(accounts_iter)?;  <span class="comment">// ATA 程序</span></span><br></pre></td></tr></table></figure><h4 id="步骤二：检查并创建-ATA"><a href="#步骤二：检查并创建-ATA" class="headerlink" title="步骤二：检查并创建 ATA"></a>步骤二：检查并创建 ATA</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> associated_token_account.<span class="title function_ invoke__">lamports</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    msg!(<span class="string">&quot;Creating associated token account...&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(</span><br><span class="line">        &amp;spl_associated_token_account::instruction::<span class="title function_ invoke__">create_associated_token_account</span>(</span><br><span class="line">            payer.key,           <span class="comment">// 支付者</span></span><br><span class="line">            payer.key,           <span class="comment">// ATA 所有者</span></span><br><span class="line">            mint_account.key,    <span class="comment">// 代币类型</span></span><br><span class="line">            token_program.key,   <span class="comment">// Token 程序</span></span><br><span class="line">        ),</span><br><span class="line">        &amp;[</span><br><span class="line">            payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            system_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            rent_sysvar.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            associated_token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        ],</span><br><span class="line">    )?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>lamports() == 0</code>：检查账户是否存在（未创建的账户余额为 0）</li><li>ATA 地址通过确定性算法生成：<code>derive([owner, token_program, mint])</code></li><li>首次铸造时自动创建，后续无需重复创建</li></ul><p><strong>ATA 的优势：</strong></p><ul><li>每个用户对每种代币只有一个标准地址</li><li>地址可预测，无需提前告知</li><li>简化钱包管理</li></ul><h4 id="步骤三：执行铸币"><a href="#步骤三：执行铸币" class="headerlink" title="步骤三：执行铸币"></a>步骤三：执行铸币</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">invoke</span>(</span><br><span class="line">    &amp;<span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">        token_program.key,                 <span class="comment">// Token 程序</span></span><br><span class="line">        mint_account.key,                  <span class="comment">// Mint 账户</span></span><br><span class="line">        associated_token_account.key,      <span class="comment">// 接收账户</span></span><br><span class="line">        payer.key,                         <span class="comment">// 铸币权限所有者</span></span><br><span class="line">        &amp;[payer.key],                      <span class="comment">// 签名者列表</span></span><br><span class="line">        amount,                            <span class="comment">// 铸造数量</span></span><br><span class="line">    )?,</span><br><span class="line">    &amp;[</span><br><span class="line">        mint_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        payer.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        associated_token_account.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        token_program.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">    ],</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>mint_to</code>：SPL Token 程序的铸币指令</li><li><code>payer.key</code>：必须是 Mint 的 mint_authority</li><li><code>amount</code>：最小单位数量（需要考虑 decimals）</li></ul><p><strong>权限验证：</strong></p><p>SPL Token 程序会验证 <code>payer</code> 是否为 <code>mint_authority</code>。只有拥有铸币权限的账户才能铸造新代币。</p><h2 id="3-客户端实现"><a href="#3-客户端实现" class="headerlink" title="3. 客户端实现"></a>3. 客户端实现</h2><h3 id="3-1-指令定义"><a href="#3-1-指令定义" class="headerlink" title="3.1 指令定义"></a>3.1 指令定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(BorshSerialize, BorshDeserialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">TokenInstruction</span> &#123;</span><br><span class="line">    CreateToken &#123; decimals: <span class="type">u8</span> &#125;,</span><br><span class="line">    Mint &#123; amount: <span class="type">u64</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li>枚举类型定义两种指令</li><li><code>BorshSerialize/BorshDeserialize</code>：实现 Borsh 序列化</li><li>必须与链上程序的定义完全一致</li></ul><h3 id="3-2-创建代币"><a href="#3-2-创建代币" class="headerlink" title="3.2 创建代币"></a>3.2 创建代币</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">rpc_client</span> = RpcClient::<span class="title function_ invoke__">new</span>(<span class="string">&quot;http://127.0.0.1:8899&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">payer</span> = <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/home/sol/.config/solana/wallet.json&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">program_id</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;4KKcAuZrm8y7wxoVa4PpR8YQqx96bSSuD6bdVsYmvNWE&quot;</span>)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mint_account</span> = Keypair::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>RpcClient</code>：连接到本地测试网（也可连接 devnet、mainnet）</li><li><code>read_keypair_file</code>：从文件加载钱包私钥</li><li><code>Keypair::new()</code>：生成新的 Mint 账户密钥对</li></ul><h4 id="构建指令数据"><a href="#构建指令数据" class="headerlink" title="构建指令数据"></a>构建指令数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">instruction_data</span> = borsh::<span class="title function_ invoke__">to_vec</span>(&amp;TokenInstruction::CreateToken &#123; decimals &#125;)?;</span><br></pre></td></tr></table></figure><p><strong>序列化过程：</strong></p><ol><li>创建 <code>CreateToken</code> 指令实例</li><li>Borsh 序列化为字节数组</li><li>字节数组会被传递给链上程序</li></ol><h4 id="配置账户元数据"><a href="#配置账户元数据" class="headerlink" title="配置账户元数据"></a>配置账户元数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),          <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(*mint_authority, <span class="literal">false</span>),      <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">false</span>),       <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),   <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>), <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),      <span class="comment">// 只读</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>AccountMeta 详解：</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>用途</th></tr></thead><tbody><tr><td><code>new(pubkey, is_signer)</code></td><td>可写账户</td><td>需要修改数据或余额的账户</td></tr><tr><td><code>new_readonly(pubkey, is_signer)</code></td><td>只读账户</td><td>只读取数据的账户</td></tr></tbody></table><p>**重要提示：**账户顺序必须与链上程序 <code>next_account_info</code> 的顺序完全一致！</p><h4 id="构建和发送交易"><a href="#构建和发送交易" class="headerlink" title="构建和发送交易"></a>构建和发送交易</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">token_instruction</span> = Instruction &#123;</span><br><span class="line">    program_id: *program_id,</span><br><span class="line">    accounts,</span><br><span class="line">    data: instruction_data,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">latest_blockhash</span> = rpc_client.<span class="title function_ invoke__">get_latest_blockhash</span>()?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],                  <span class="comment">// 指令列表</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),                 <span class="comment">// 手续费支付者</span></span><br><span class="line">    &amp;[payer, mint_account],                <span class="comment">// 签名者列表</span></span><br><span class="line">    latest_blockhash,                      <span class="comment">// 最新区块哈希</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">signature</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong></p><ul><li><code>get_latest_blockhash()</code>：获取最新区块哈希防止重放攻击</li><li>双重签名：<code>payer</code> 支付手续费，<code>mint_account</code> 授权创建</li><li><code>send_and_confirm_transaction</code>：发送并等待确认</li></ul><h3 id="3-3-铸造代币"><a href="#3-3-铸造代币" class="headerlink" title="3.3 铸造代币"></a>3.3 铸造代币</h3><h4 id="计算-ATA-地址"><a href="#计算-ATA-地址" class="headerlink" title="计算 ATA 地址"></a>计算 ATA 地址</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ata</span> = <span class="title function_ invoke__">get_associated_token_address</span>(</span><br><span class="line">    &amp;payer.<span class="title function_ invoke__">pubkey</span>(),</span><br><span class="line">    &amp;mint_account.<span class="title function_ invoke__">pubkey</span>(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>确定性推导：</strong></p><ul><li>基于 owner 和 mint 确定性计算</li><li>无需提前创建，地址可预测</li><li>公式：<code>findProgramAddress([owner, TOKEN_PROGRAM_ID, mint], ASSOCIATED_TOKEN_PROGRAM_ID)</code></li></ul><h4 id="配置账户元数据-1"><a href="#配置账户元数据-1" class="headerlink" title="配置账户元数据"></a>配置账户元数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">accounts</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(mint_account.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),              <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(ata, <span class="literal">false</span>),                               <span class="comment">// 可写</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(sysvar::rent::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),       <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new</span>(payer.<span class="title function_ invoke__">pubkey</span>(), <span class="literal">true</span>),                     <span class="comment">// 可写 + 签名</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(system_program::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),     <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_token::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>),          <span class="comment">// 只读</span></span><br><span class="line">    AccountMeta::<span class="title function_ invoke__">new_readonly</span>(spl_associated_token_account::<span class="title function_ invoke__">id</span>(), <span class="literal">false</span>), <span class="comment">// 只读</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>权限说明：</strong></p><ul><li>Mint 账户可写：需要更新 supply 字段</li><li>ATA 可写：需要更新代币余额</li><li>Payer 可写：需要支付 ATA 创建费用（如果尚未创建）</li></ul><h4 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tx</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">    &amp;[token_instruction],</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;payer.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">    &amp;[payer, mint_account],  <span class="comment">// Mint 需要签名验证铸币权限</span></span><br><span class="line">    latest_blockhash,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">signature</span> = rpc_client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;tx)?;</span><br></pre></td></tr></table></figure><h2 id="4-完整工作流程"><a href="#4-完整工作流程" class="headerlink" title="4. 完整工作流程"></a>4. 完整工作流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">客户端                              Solana 网络                          链上程序</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |-------- CreateToken 交易 -----------&gt;|                                    |</span><br><span class="line">  |                                      |---------- 调用 process() ---------&gt;|</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |                                      |           create_token()           |</span><br><span class="line">  |                                      |        1. 创建 Mint 账户            |</span><br><span class="line">  |                                      |        2. 初始化 Mint 数据          |</span><br><span class="line">  |                                      |&lt;---------- 返回成功 ----------------|</span><br><span class="line">  |&lt;--------- 交易确认 ------------------|                                     |</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |---------- Mint 交易 ----------------&gt;|                                    |</span><br><span class="line">  |                                      |---------- 调用 process() ---------&gt;|</span><br><span class="line">  |                                      |                                    |</span><br><span class="line">  |                                      |             mint()                 |</span><br><span class="line">  |                                      |        1. 检查/创建 ATA            |</span><br><span class="line">  |                                      |        2. 铸造代币到 ATA           |</span><br><span class="line">  |                                      |&lt;---------- 返回成功 ---------------|</span><br><span class="line">  |&lt;--------- 交易确认 ------------------|                                    |</span><br></pre></td></tr></table></figure><h2 id="5-核心知识点"><a href="#5-核心知识点" class="headerlink" title="5. 核心知识点"></a>5. 核心知识点</h2><h3 id="5-1-CPI（跨程序调用）"><a href="#5-1-CPI（跨程序调用）" class="headerlink" title="5.1 CPI（跨程序调用）"></a>5.1 CPI（跨程序调用）</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="title function_ invoke__">invoke</span>(&amp;instruction, &amp;accounts)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 PDA 签名调用</span></span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(&amp;instruction, &amp;accounts, &amp;[&amp;seeds])?;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><table><thead><tr><th>调用方式</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td><code>invoke</code></td><td>调用其他程序的公开功能</td><td>调用 System Program 创建账户</td></tr><tr><td><code>invoke_signed</code></td><td>程序代表 PDA 签名</td><td>PDA 作为铸币权限</td></tr></tbody></table><h3 id="5-2-账户所有权模型"><a href="#5-2-账户所有权模型" class="headerlink" title="5.2 账户所有权模型"></a>5.2 账户所有权模型</h3><table><thead><tr><th>账户类型</th><th>所有者</th><th>可修改数据</th></tr></thead><tbody><tr><td>Mint Account</td><td>SPL Token Program</td><td>SPL Token Program</td></tr><tr><td>Token Account</td><td>SPL Token Program</td><td>SPL Token Program</td></tr><tr><td>Wallet</td><td>System Program</td><td>System Program</td></tr><tr><td>PDA</td><td>自定义程序</td><td>自定义程序</td></tr></tbody></table><p><strong>核心原则：</strong> 只有账户的所有者程序才能修改账户数据</p><h3 id="5-3-交易签名规则"><a href="#5-3-交易签名规则" class="headerlink" title="5.3 交易签名规则"></a>5.3 交易签名规则</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;[payer, mint_account]</span><br></pre></td></tr></table></figure><p><strong>签名者列表规则：</strong></p><ul><li>所有标记为 <code>is_signer: true</code> 的账户都需要签名</li><li>手续费支付者（payer）必须签名</li></ul><h3 id="5-4-Decimals-设计原则"><a href="#5-4-Decimals-设计原则" class="headerlink" title="5.4 Decimals 设计原则"></a>5.4 Decimals 设计原则</h3><table><thead><tr><th>代币类型</th><th>decimals</th><th>示例</th><th>1 代币 &#x3D; ? 基础单位</th></tr></thead><tbody><tr><td>稳定币</td><td>6</td><td>USDC, USDT</td><td>1,000,000</td></tr><tr><td>治理代币</td><td>9</td><td>SOL</td><td>1,000,000,000</td></tr><tr><td>NFT</td><td>0</td><td>不可分割</td><td>1</td></tr></tbody></table><h2 id="6-实战技巧"><a href="#6-实战技巧" class="headerlink" title="6. 实战技巧"></a>6. 实战技巧</h2><h3 id="6-1-调试日志"><a href="#6-1-调试日志" class="headerlink" title="6.1 调试日志"></a>6.1 调试日志</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg!(<span class="string">&quot;Creating mint account...&quot;</span>);</span><br><span class="line">msg!(<span class="string">&quot;Mint: &#123;&#125;&quot;</span>, mint_account.key);</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana logs</span><br></pre></td></tr></table></figure><h3 id="6-2-账户大小计算"><a href="#6-2-账户大小计算" class="headerlink" title="6.2 账户大小计算"></a>6.2 账户大小计算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mint 账户：82 字节</span></span><br><span class="line"><span class="comment">// Token 账户：165 字节</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rent</span> = Rent::<span class="title function_ invoke__">get</span>()?.<span class="title function_ invoke__">minimum_balance</span>(size);</span><br></pre></td></tr></table></figure><h3 id="6-3-权限管理最佳实践"><a href="#6-3-权限管理最佳实践" class="headerlink" title="6.3 权限管理最佳实践"></a>6.3 权限管理最佳实践</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时设置 mint_authority</span></span><br><span class="line"><span class="title function_ invoke__">initialize_mint</span>(..., &amp;mint_authority.key, <span class="literal">None</span>, decimals)?;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 铸造完成后可撤销权限（不可逆）</span></span><br><span class="line"><span class="title function_ invoke__">set_authority</span>(..., <span class="literal">None</span>, AuthorityType::MintTokens)?;</span><br></pre></td></tr></table></figure><h3 id="6-4-错误处理"><a href="#6-4-错误处理" class="headerlink" title="6.4 错误处理"></a>6.4 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">invoke</span>(...)?;  <span class="comment">// ? 操作符传播错误</span></span><br></pre></td></tr></table></figure><p><strong>常见错误：</strong></p><table><thead><tr><th>错误类型</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td><code>AccountNotFound</code></td><td>账户不存在</td><td>检查账户地址是否正确</td></tr><tr><td><code>InsufficientFunds</code></td><td>余额不足</td><td>确保账户有足够的 SOL</td></tr><tr><td><code>InvalidAccountData</code></td><td>数据格式错误</td><td>检查序列化&#x2F;反序列化逻辑</td></tr><tr><td><code>MissingRequiredSignature</code></td><td>缺少必要签名</td><td>检查签名者列表</td></tr></tbody></table><h2 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7. 常见问题"></a>7. 常见问题</h2><p><strong>Q1: 为什么需要租金？</strong></p><p>A: Solana 通过租金机制防止状态膨胀，账户需要保持最低余额。但这更像是押金，关闭账户时可以完全收回。</p><p><strong>Q2: ATA 地址会冲突吗？</strong></p><p>A: 不会冲突，ATA 通过 <code>[owner, mint]</code> 确定性生成，每个组合唯一。</p><p><strong>Q3: 可以修改 decimals 吗？</strong></p><p>A: 不可以，Mint 初始化后 decimals 不可更改。</p><p><strong>Q4: 如何转移铸币权限？</strong></p><p>A: 使用 <code>set_authority</code> 指令修改 mint_authority。</p><p><strong>Q5: 代币可以销毁吗？</strong></p><p>A: 可以，使用 <code>burn</code> 指令销毁持有的代币。</p><p><strong>Q6: 为什么要分两步创建账户？</strong></p><p>A: 遵循 Solana 的所有权模型。System Program 创建账户并分配空间，然后将所有权转给 Token Program，最后由 Token Program 初始化具体数据。</p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><ul><li><strong>账户是核心</strong>：Mint Account 和 Token Account 是 SPL Token 的基础</li><li><strong>所有权很重要</strong>：只有所有者程序可以修改账户数据</li><li><strong>CPI 是关键</strong>：通过跨程序调用实现功能组合</li><li><strong>ATA 简化管理</strong>：确定性地址生成简化代币账户管理</li><li><strong>租金是押金</strong>：不是真正的费用，关闭账户时可以收回</li><li><strong>程序和数据分离</strong>：遵循 Solana 的账户模型设计</li></ul><p><strong>Hooray！SPL Token 开发学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— Token 基础</title>
      <link href="/2025/10/03/solana-token-basic/"/>
      <url>/2025/10/03/solana-token-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Token？"><a href="#什么是-Token？" class="headerlink" title="什么是 Token？"></a>什么是 Token？</h2><p>在 Solana 区块链上，<strong>Token</strong> 是一种数字资产，用于表示价值或所有权。这些 Token 可以代表各种类型的资产，如货币、股权、积分、NFT（非同质化代币）等。</p><h3 id="Token-的分类"><a href="#Token-的分类" class="headerlink" title="Token 的分类"></a>Token 的分类</h3><ul><li><strong>同质化代币（Fungible Tokens）</strong>：代表同类型和同价值的可互换和可分割资产（例如 USDC）</li><li><strong>非同质化代币（Non-Fungible Tokens, NFTs）</strong>：代表不可分割资产的所有权（例如艺术品）</li></ul><h2 id="SPL-Solana-Program-Library"><a href="#SPL-Solana-Program-Library" class="headerlink" title="SPL (Solana Program Library)"></a>SPL (Solana Program Library)</h2><p><strong>SPL</strong> 是一组用于在 Solana 区块链上构建去中心化应用程序的智能合约库。SPL 提供了多种标准和工具，使开发者能够更容易地创建和管理代币。</p><p>SPL 的核心组件包括：</p><ul><li><strong>Token Program（代币程序）</strong>：包含与网络上的代币交互的所有指令逻辑</li><li><strong>Mint Account（铸币账户）</strong>：代表一种特定类型的代币，并存储关于代币的全局元数据，如总供应量和铸造权限</li><li><strong>Token Account（代币账户）</strong>：跟踪特定地址拥有的特定类型代币的单位数量</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-Token-Program（代币程序）"><a href="#1-Token-Program（代币程序）" class="headerlink" title="1. Token Program（代币程序）"></a>1. Token Program（代币程序）</h3><p>Token Program 是 SPL 中最核心的部分，包含与网络上代币交互的所有指令逻辑。</p><p><strong>主要功能：</strong></p><ul><li>创建代币及初始化代币账户</li><li>在不同账户之间转移代币</li><li>授权和撤销授权</li><li>查询代币余额</li></ul><h3 id="2-Mint-Account（铸币账户）"><a href="#2-Mint-Account（铸币账户）" class="headerlink" title="2. Mint Account（铸币账户）"></a>2. Mint Account（铸币账户）</h3><p>Mint Account 是每个 SPL Token 的核心账户，负责代币的定义和管理。它包含了代币的全局属性，比如总供应量和小数位数。每个代币都由一个独立的 Mint Account 来表示。</p><p><strong>主要属性：</strong></p><ul><li><strong>Decimals（小数位数）</strong>：定义代币的最小单位，常见取值是 6 或 9</li><li><strong>Supply（供应量）</strong>：代币的当前总供应量</li><li><strong>Mint Authority（铸币权限）</strong>：有权创建新代币单位的账户地址</li><li><strong>Freeze Authority（冻结权限）</strong>：可以冻结或解冻代币账户的权限</li></ul><p><strong>主要功能：</strong></p><ul><li><strong>铸造代币</strong>：增加总供应量并分配给指定的 Token Account</li><li><strong>销毁代币</strong>：减少总供应量</li></ul><h4 id="创建-Mint-Account"><a href="#创建-Mint-Account" class="headerlink" title="创建 Mint Account"></a>创建 Mint Account</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-token</span><br><span class="line">Creating token 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F under program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line"></span><br><span class="line">Address:  75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">Decimals:  9</span><br><span class="line"></span><br><span class="line">Signature: 3R71oyLWt2MKi3EUHttpJg7XnWxyYHheBF7vShkc2n6aQhLn1GWCEzqjqvqARFKVCQqucm3sGxoXum4k1BWf413a</span><br></pre></td></tr></table></figure><h4 id="查看-Mint-Account-信息"><a href="#查看-Mint-Account-信息" class="headerlink" title="查看 Mint Account 信息"></a>查看 Mint Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line"></span><br><span class="line">SPL Token Mint</span><br><span class="line">  Address: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Supply: 0</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint authority: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  Freeze authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="3-Token-Account（代币账户）"><a href="#3-Token-Account（代币账户）" class="headerlink" title="3. Token Account（代币账户）"></a>3. Token Account（代币账户）</h3><p>Token Account 用于持有特定 SPL Token 的账户。每个用户或合约如果想要持有某种 SPL Token，必须有一个与该 Token 对应的 Token Account。每个 Token Account 只能对应一个特定的 Mint（代币类型），所以如果用户要持有多种代币，就需要为每种代币分别创建一个 Token Account</p><p><strong>主要属性：</strong></p><ul><li><strong>Balance（余额）</strong>：账户中持有的代币数量</li><li><strong>Owner（账户拥有者）</strong>：控制该账户的用户或合约地址</li><li><strong>Mint（关联铸币账户）</strong>：该账户与哪个 Mint Account 相关联</li><li><strong>Delegation（代理账户）</strong>：被授权可以代表账户所有者转移代币的地址</li><li><strong>State（状态）</strong>：账户是否处于冻结状态</li></ul><p><strong>主要功能：</strong></p><ul><li>接收和发送代币</li><li>代理权限管理：可以设置 Delegation 来授权第三方管理该账户的代币</li></ul><h4 id="创建-Token-Account"><a href="#创建-Token-Account" class="headerlink" title="创建 Token Account"></a>创建 Token Account</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-account 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F /home/sol/.config/solana/wallet2.json</span><br><span class="line">Creating account 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">Signature: 3p6FztvPYgfzR2eBsKEFunTszbvsQgycXgwn8wNe1rBDdzDtP3jp4Z7XWgL91FbXTPGssy9bNdEiVPCqmkdHZX82</span><br></pre></td></tr></table></figure><h4 id="查看-Token-Account-信息"><a href="#查看-Token-Account-信息" class="headerlink" title="查看 Token Account 信息"></a>查看 Token Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">SPL Token Account</span><br><span class="line">  Address: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz  (Aux*)</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Balance: 100</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Owner: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  State: Initialized</span><br><span class="line">  Delegation: (not <span class="built_in">set</span>)</span><br><span class="line">  Close authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Associated-Token-Account（关联代币账户，ATA）"><a href="#4-Associated-Token-Account（关联代币账户，ATA）" class="headerlink" title="4. Associated Token Account（关联代币账户，ATA）"></a>4. Associated Token Account（关联代币账户，ATA）</h3><p>ATA 是一种由钱包地址和 Mint 通过特定规则派生出的标准化 Token Account 地址，每个钱包和某个代币的 Mint 至多对应一个 ATA。</p><p><strong>特点：</strong></p><ul><li><strong>唯一性</strong>：每个钱包地址只能有一个和某个 Mint 关联的 ATA</li><li><strong>自动生成</strong>：Solana 提供了工具来自动生成 ATA，开发者不需要手动管理账户</li><li><strong>简化管理</strong>：自动处理钱包地址与代币账户之间的关联</li></ul><h4 id="创建-ATA"><a href="#创建-ATA" class="headerlink" title="创建 ATA"></a>创建 ATA</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token create-account 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">Creating account DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">Signature: 388vYjLh9HVNYNeWcsa44zvdWgALHVTXC3dqHJbntpJN5P41Poj6G9zGHPPz2q1fysFAxRqPWKww2NUZKVwasoE6</span><br></pre></td></tr></table></figure><h4 id="查看-Associated-Token-Account-信息"><a href="#查看-Associated-Token-Account-信息" class="headerlink" title="查看 Associated Token Account 信息"></a>查看 Associated Token Account 信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token account-info --address DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">SPL Token Account</span><br><span class="line">  Address: DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line">  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA</span><br><span class="line">  Balance: 100</span><br><span class="line">  Decimals: 9</span><br><span class="line">  Mint: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Owner: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span><br><span class="line">  State: Initialized</span><br><span class="line">  Delegation: (not <span class="built_in">set</span>)</span><br><span class="line">  Close authority: (not <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h2 id="铸造代币操作"><a href="#铸造代币操作" class="headerlink" title="铸造代币操作"></a>铸造代币操作</h2><h3 id="铸造到-ATA-账户"><a href="#铸造到-ATA-账户" class="headerlink" title="铸造到 ATA 账户"></a>铸造到 ATA 账户</h3><p>Mint Account 会自动关联到当前钱包的 ATA 账户，无需指定接收账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token mint 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F 100</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Recipient: DHvRpFVRXySnAhq5T3Y3nSHVpGS22NRX4gcWGXzTUxLL</span><br><span class="line"></span><br><span class="line">Signature: 32wtkcw2Xjv1Y1rADNuzCDPE6XtJhRTk3oxusPXMFRqKX6WhaU6PNZE3i3Uj6hDcYkfLvarFbki1HoQFHyqP6Wfk</span><br></pre></td></tr></table></figure><h3 id="铸造到指定-Token-Account"><a href="#铸造到指定-Token-Account" class="headerlink" title="铸造到指定 Token Account"></a>铸造到指定 Token Account</h3><p>给普通 Token Account 铸造时，需要通过 <code>--</code> 指定目标账户地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sol@Sunshine:~$ spl-token mint 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F 100  -- 65bUqQKj4Axew8Z7KpXGodFowdXb</span><br><span class="line">WBE4ne8ocUZMoKmz</span><br><span class="line">Minting 100 tokens</span><br><span class="line">  Token: 75nCeiHP6AcHcKiVr24JKxSWTPu9k4fX5Teem3pGAC8F</span><br><span class="line">  Recipient: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span><br><span class="line"></span><br><span class="line">Signature: 5BWCTCSo2BxqkKWQwsgY7KRr3d1an2KGw4taa2Nao45jnE1sDfsA9EpgwYmTxoLBUp2x5pStJxp7JhKGZas3hbLM</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Solana 的 Token 系统通过 SPL Token Program 提供了完整的代币管理功能。理解以下三个核心概念是使用 Solana 代币的基础：</p><ol><li><strong>Mint Account（铸币账户）</strong>：定义代币类型和全局属性，如供应量、小数位数、铸币权限等</li><li><strong>Token Account（代币账户）</strong>：持有特定代币的账户，记录余额和所有权</li><li><strong>Associated Token Account（关联代币账户）</strong>：标准化的代币账户，自动与钱包地址绑定，每个钱包和某个 Mint 仅对应一个 ATA</li></ol><p>这套系统支持创建各种类型的数字资产，从可替代代币（如 USDC）到不可替代代币（NFT），为 Solana 生态系统提供了强大而灵活的基础设施。</p><p><strong>Hooray！Solana Token 基础完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— 账户模型与简单交互</title>
      <link href="/2025/10/02/solana-account-model/"/>
      <url>/2025/10/02/solana-account-model/</url>
      
        <content type="html"><![CDATA[<p>在 Solana 中，所有数据都存储在称为”账户”（Accounts）的结构中。可以将 Solana 上的数据视为一个公共数据库，其中有一个名为”Accounts”的表，表中的每一条记录就是一个”账户”。</p><h2 id="1-核心要点"><a href="#1-核心要点" class="headerlink" title="1. 核心要点"></a>1. 核心要点</h2><ul><li><strong>存储容量</strong>：账户最多可以存储 10MiB 的数据，可以是可执行的程序代码或程序状态</li><li><strong>租金押金</strong>：账户需要按比例缴纳租金押金（以 lamports 计，即 SOL 的最小单位），押金金额与存储的数据量成正比，<strong>关闭账户时可以完全收回</strong></li><li><strong>所有权机制</strong>：每个账户都有一个程序所有者。只有拥有该账户的程序才能修改其数据或扣除其 lamport 余额，但任何人都可以增加余额</li><li>特殊账户类型<ul><li>Sysvar 账户：存储网络集群状态的特殊账户</li><li>Program 账户：存储智能合约的可执行代码</li><li>Data 账户：由程序创建用于存储和管理程序状态</li></ul></li></ul><h2 id="2-账户结构"><a href="#2-账户结构" class="headerlink" title="2. 账户结构"></a>2. 账户结构</h2><h3 id="2-1-账户地址"><a href="#2-1-账户地址" class="headerlink" title="2.1 账户地址"></a>2.1 账户地址</h3><p>每个 Solana 账户都有一个唯一的 <strong>32 字节地址</strong>，通常显示为 base58 编码的字符串（例如：<code>14grJpemFaf88c8tiVb77W7TYg2W3ir6pfkKz3YjhhZ5</code>）。</p><p>账户与其地址之间的关系类似于键值对，其中地址是用于定位账户链上数据的键。账户地址充当”Accounts”表中每个条目的”唯一标识符”。</p><p><strong>地址生成方式：</strong></p><ol><li><strong>Ed25519 公钥地址</strong>（最常见）<ul><li>大多数 Solana 账户使用 Ed25519 公钥作为其地址</li></ul></li><li><strong>程序派生地址（PDA）</strong><ul><li>可以从程序 ID 和可选输入（种子）确定性地派生的特殊地址</li><li>PDA 是一种特殊的地址类型，不需要私钥就可以使用</li></ul></li></ol><h3 id="2-2-账户类型定义"><a href="#2-2-账户类型定义" class="headerlink" title="2.2 账户类型定义"></a>2.2 账户类型定义</h3><p>所有 Solana 账户都具有相同的基础结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> lamports: <span class="type">u64</span>,<span class="comment">// 账户中的 lamports 余额</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,<span class="comment">// 账户中存储的数据</span></span><br><span class="line">    <span class="keyword">pub</span> owner: Pubkey,<span class="comment">// 拥有此账户的程序。如果可执行，则为加载此账户的程序</span></span><br><span class="line">    <span class="keyword">pub</span> executable: <span class="type">bool</span>,<span class="comment">// 此账户的数据是否包含已加载的程序（现在为只读）</span></span><br><span class="line">    <span class="keyword">pub</span> rent_epoch: Epoch,<span class="comment">// 此账户下次需要支付租金的 epoch（已弃用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-字段详解"><a href="#2-3-字段详解" class="headerlink" title="2.3 字段详解"></a>2.3 字段详解</h3><h4 id="Lamports-字段"><a href="#Lamports-字段" class="headerlink" title="Lamports 字段"></a>Lamports 字段</h4><p>账户的余额（以 lamports 为单位，<strong>1 SOL &#x3D; 10 亿 lamports</strong>）。</p><p><strong>重要特性：</strong></p><ul><li>账户必须保持最低 lamport 余额，该余额与存储的数据量成正比（称为”租金”）</li><li>关闭账户时可以完全收回存储在账户中的 lamport 余额</li></ul><h4 id="Data-字段"><a href="#Data-字段" class="headerlink" title="Data 字段"></a>Data 字段</h4><p>存储账户任意数据的字节数组，也称为”账户数据”。</p><p><strong>不同账户类型的 data 内容：</strong></p><ul><li>对于程序账户：包含可执行程序代码本身或存储可执行代码的另一个账户的地址</li><li>对于非可执行账户：通常存储要读取的状态数据</li></ul><p><strong>读取账户数据的步骤：</strong></p><ol><li>使用地址（公钥）获取账户</li><li>将账户的 data 字段从原始字节反序列化为适当的数据结构（由拥有该账户的程序定义）</li></ol><h4 id="Owner-字段"><a href="#Owner-字段" class="headerlink" title="Owner 字段"></a>Owner 字段</h4><p>拥有此账户的程序 ID（公钥）。</p><p><strong>所有权规则：</strong></p><ul><li>只有所有者程序才能更改账户的数据或扣除其 lamports 余额</li><li>程序中定义的指令决定了账户的数据和 lamports 余额如何被更改</li></ul><h4 id="Executable-字段"><a href="#Executable-字段" class="headerlink" title="Executable 字段"></a>Executable 字段</h4><p>指示账户是否为可执行程序：</p><ul><li><code>true</code>：账户是可执行的 Solana 程序</li><li><code>false</code>：账户是存储状态的数据账户</li></ul><p>对于可执行账户，<code>owner</code> 字段包含加载器程序的程序 ID。加载器程序是负责加载和管理可执行程序账户的内置程序。</p><h4 id="Rent-Epoch-字段"><a href="#Rent-Epoch-字段" class="headerlink" title="Rent Epoch 字段"></a>Rent Epoch 字段</h4><p>**注意：**这是一个已弃用的遗留字段，不再使用。最初用于跟踪账户何时需要支付租金以维护其网络数据，此租金收取机制已被废弃。</p><h2 id="3-租金机制"><a href="#3-租金机制" class="headerlink" title="3. 租金机制"></a>3. 租金机制</h2><p>要在链上存储数据，账户必须保持与存储数据量（字节）成正比的 lamport（SOL）余额。这个余额称为”租金”，但它更像是<strong>押金</strong>，因为关闭账户时可以收回全部金额。</p><p><strong>注意：</strong> “租金”一词来自已弃用的机制，该机制会定期从低于租金阈值的账户中扣除 lamports。此机制已不再活跃。</p><h2 id="4-程序所有权"><a href="#4-程序所有权" class="headerlink" title="4. 程序所有权"></a>4. 程序所有权</h2><p>在 Solana 上，”智能合约”被称为”程序”。程序所有权是 Solana 账户模型的关键部分。</p><h3 id="4-1-所有者权限"><a href="#4-1-所有者权限" class="headerlink" title="4.1 所有者权限"></a>4.1 所有者权限</h3><p>只有所有者程序可以：</p><ul><li>更改账户的 <code>data</code> 字段</li><li>从账户余额中扣除 lamports</li></ul><p>每个程序定义存储在账户 <code>data</code> 字段中的数据结构。程序的指令决定了如何更改这些数据和账户的 <code>lamports</code> 余额。</p><h3 id="4-2-System-Program（系统程序）"><a href="#4-2-System-Program（系统程序）" class="headerlink" title="4.2 System Program（系统程序）"></a>4.2 System Program（系统程序）</h3><p>默认情况下，<strong>所有新账户都归 System Program 所有</strong>。</p><p><strong>System Program 的关键功能：</strong></p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>空间分配</td><td>为新账户分配存储空间</td></tr><tr><td>分配程序所有权</td><td>将账户所有权转移给其他程序</td></tr><tr><td>转账 SOL</td><td>在账户之间转移 lamports</td></tr></tbody></table><p><strong>System Account（系统账户）：</strong></p><ul><li>Solana 上的所有”钱包”账户都是由 System Program 拥有的”系统账户”</li><li>这些账户中的 lamport 余额显示钱包拥有的 SOL 数量</li><li><strong>只有系统账户可以支付交易费用</strong></li><li>当首次向新地址发送 SOL 时，会在该地址自动创建一个由 System Program 拥有的账户</li><li>新创建的系统账户的 owner 字段显示为 System Program 地址：<code>11111111111111111111111111111111</code></li></ul><h2 id="5-特殊账户类型"><a href="#5-特殊账户类型" class="headerlink" title="5. 特殊账户类型"></a>5. 特殊账户类型</h2><h3 id="5-1-Sysvar-Accounts（系统变量账户）"><a href="#5-1-Sysvar-Accounts（系统变量账户）" class="headerlink" title="5.1 Sysvar Accounts（系统变量账户）"></a>5.1 Sysvar Accounts（系统变量账户）</h3><p>Sysvar 账户是位于预定义地址的特殊账户，提供对集群状态数据的访问。这些账户会动态更新网络集群的相关数据。</p><p>例如，可以通过 Sysvar Clock 账户获取当前的集群时间信息，这些账户的数据可以被获取并反序列化为相应的数据结构。</p><h3 id="5-2-Program-Account（程序账户）"><a href="#5-2-Program-Account（程序账户）" class="headerlink" title="5.2 Program Account（程序账户）"></a>5.2 Program Account（程序账户）</h3><p>部署 Solana 程序会创建一个可执行的程序账户，用于存储程序的可执行代码。程序账户由加载器程序（Loader Program）拥有。</p><p><strong>关键特点：</strong></p><ul><li>程序账户可以简单地视为程序本身</li><li>调用程序的指令时，需要指定程序账户的地址（通常称为”Program ID”）</li><li>程序账户的 <code>executable</code> 字段设置为 <code>true</code></li></ul><p><strong>程序部署方式：</strong></p><ol><li><strong>Loader-v3 之前的版本</strong>：<ul><li>可执行代码直接存储在程序账户中</li></ul></li><li><strong>Loader-v3</strong>（当前默认）：<ul><li>可执行代码存储在单独的”程序数据账户”（Program Data Account）中</li><li>程序账户只是指向该数据账户</li><li>Solana CLI 默认使用最新的加载器版本</li></ul></li></ol><h3 id="5-3-Buffer-Account（缓冲区账户）"><a href="#5-3-Buffer-Account（缓冲区账户）" class="headerlink" title="5.3 Buffer Account（缓冲区账户）"></a>5.3 Buffer Account（缓冲区账户）</h3><p>Loader-v3 有一种特殊的账户类型，用于在部署或升级期间临时暂存程序的上传。在 Loader-v4 中，仍然有缓冲区，但它们只是普通的程序账户。</p><h3 id="5-4-Program-Data-Account（程序数据账户）"><a href="#5-4-Program-Data-Account（程序数据账户）" class="headerlink" title="5.4 Program Data Account（程序数据账户）"></a>5.4 Program Data Account（程序数据账户）</h3><p>Loader-v3 工作方式与其他 BPF 加载器程序不同：</p><ul><li>程序账户只包含程序数据账户的地址</li><li>程序数据账户存储实际的可执行代码</li></ul><p><strong>注意：</strong> 不要将程序数据账户与程序的数据账户（Data Account）混淆。</p><h3 id="5-5-Data-Account（数据账户）"><a href="#5-5-Data-Account（数据账户）" class="headerlink" title="5.5 Data Account（数据账户）"></a>5.5 Data Account（数据账户）</h3><p>在 Solana 上，程序的可执行代码与程序的状态存储在<strong>不同的账户</strong>中。这类似于操作系统通常为程序及其数据使用单独文件的方式。</p><p>为了维护状态，程序定义指令来创建它们拥有的独立账户。每个账户都有自己唯一的地址，可以存储程序定义的任意数据。</p><p><strong>重要提示：</strong> 只有 System Program 可以创建新账户。System Program 创建账户后，可以将新账户的所有权分配给另一个程序。</p><p><strong>创建数据账户的两步过程：</strong></p><ol><li><strong>调用 System Program</strong>：创建账户，然后将所有权转移给自定义程序</li><li><strong>调用自定义程序</strong>：初始化账户数据（按程序指令定义）</li></ol><p><strong>示例：创建 Token Mint 账户</strong></p><ul><li>首先调用 System Program 创建账户并分配空间</li><li>然后调用 Token Program 初始化 mint 账户的数据</li><li>需要计算租金豁免所需的最低余额</li><li>完成后账户由 Token Program 拥有并存储 mint 的相关数据</li></ul><h2 id="6-账户交互实战"><a href="#6-账户交互实战" class="headerlink" title="6. 账户交互实战"></a>6. 账户交互实战</h2><h3 id="6-1-环境准备"><a href="#6-1-环境准备" class="headerlink" title="6.1 环境准备"></a>6.1 环境准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动本地验证器</span></span><br><span class="line">solana-test-validator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到本地网络</span></span><br><span class="line">solana config <span class="built_in">set</span> -ul</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地钱包账户</span></span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet1.json</span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet2.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认钱包</span></span><br><span class="line">solana config <span class="built_in">set</span> --keypair ~/.config/solana/wallet1.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求空投</span></span><br><span class="line">solana airdrop 10</span><br></pre></td></tr></table></figure><h3 id="6-2-项目设置"><a href="#6-2-项目设置" class="headerlink" title="6.2 项目设置"></a>6.2 项目设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">cargo new account-interaction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加依赖库</span></span><br><span class="line">cargo add solana_client</span><br><span class="line">cargo add solana_sdk</span><br><span class="line">cargo add solana_program</span><br></pre></td></tr></table></figure><h3 id="6-3-请求空投与查询余额"><a href="#6-3-请求空投与查询余额" class="headerlink" title="6.3 请求空投与查询余额"></a>6.3 请求空投与查询余额</h3><p>通过这个示例，你可以学习如何：</p><ul><li>连接到 Solana 网络</li><li>请求空投到指定账户</li><li>查询账户余额</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::pubkey::Pubkey;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wallet1: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span></span><br><span class="line"><span class="comment">// Wallet2: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建 Solana 客户端连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_url</span> = <span class="string">&quot;http://127.0.0.1:8899&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = RpcClient::<span class="title function_ invoke__">new</span>(rpc_url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户公钥</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_pubkey</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid public key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 SOL = 10 亿 lamports</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amount</span> = <span class="number">1_000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求空投</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">request_airdrop</span>(&amp;account_pubkey, amount) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(signature) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;空投成功! 签名: &#123;&#125;&quot;</span>, signature),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;空投失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询账户余额</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;account_pubkey) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;账户余额: &#123;&#125; lamports&quot;</span>, balance);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;账户余额: &#123;&#125; SOL&quot;</span>, balance <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1_000_000_000.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;获取余额失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-转账交易"><a href="#6-4-转账交易" class="headerlink" title="6.4 转账交易"></a>6.4 转账交易</h3><p>这个示例演示了 Solana 账户之间的转账流程：</p><ul><li>加载发送方密钥对</li><li>创建转账指令</li><li>构建、签名并发送交易</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> solana_client::rpc_client::RpcClient;</span><br><span class="line"><span class="keyword">use</span> solana_sdk::&#123;</span><br><span class="line">    pubkey::Pubkey,</span><br><span class="line">    signature::&#123;Signer, read_keypair_file&#125;,</span><br><span class="line">    system_instruction,</span><br><span class="line">    transaction::Transaction,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wallet1: 8BG3BQmLhCsayYUGinVyUMzfni7CM1WiVApqZmGaJbjW</span></span><br><span class="line"><span class="comment">// Wallet2: 65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建 Solana 客户端连接</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rpc_url</span> = <span class="string">&quot;http://127.0.0.1:8899&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span> = RpcClient::<span class="title function_ invoke__">new</span>(rpc_url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载发送方密钥对</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sender</span> =</span><br><span class="line">        <span class="title function_ invoke__">read_keypair_file</span>(<span class="string">&quot;/home/sol/.config/solana/wallet1.json&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取密钥文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收方公钥</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver_pubkey</span> = Pubkey::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;65bUqQKj4Axew8Z7KpXGodFowdXbWBE4ne8ocUZMoKmz&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid public key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账金额：1 SOL</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">amount</span> = <span class="number">1_000_000_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建转账指令</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transfer_instruction</span> =</span><br><span class="line">        system_instruction::<span class="title function_ invoke__">transfer</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>(), &amp;receiver_pubkey, amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最新区块哈希</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">recent_blockhash</span> = client.<span class="title function_ invoke__">get_latest_blockhash</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法获取最新区块哈希&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并签名交易</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transaction</span> = Transaction::<span class="title function_ invoke__">new_signed_with_payer</span>(</span><br><span class="line">        &amp;[transfer_instruction],</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(&amp;sender.<span class="title function_ invoke__">pubkey</span>()),</span><br><span class="line">        &amp;[&amp;sender],</span><br><span class="line">        recent_blockhash,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送并确认交易</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">send_and_confirm_transaction</span>(&amp;transaction) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(signature) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;转账成功! 签名: &#123;&#125;&quot;</span>, signature),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;转账失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询接收方余额</span></span><br><span class="line">    <span class="keyword">match</span> client.<span class="title function_ invoke__">get_balance</span>(&amp;receiver_pubkey) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(balance) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;接收方账户余额: &#123;&#125; lamports&quot;</span>, balance);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;接收方账户余额: &#123;&#125; SOL&quot;</span>, balance <span class="keyword">as</span> <span class="type">f64</span> / <span class="number">1_000_000_000.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;获取余额失败: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ol><li><strong>账户是 Solana 的基础存储单元</strong>：所有数据都存储在账户中</li><li><strong>账户具有统一的结构</strong>：所有账户共享相同的基础字段</li><li><strong>所有权是关键</strong>：只有所有者程序可以修改账户数据</li><li><strong>租金是可恢复的押金</strong>：不是真正的费用，关闭账户时可以收回</li><li><strong>程序和数据分离</strong>：可执行代码和状态数据存储在不同的账户中</li><li><strong>System Program 是账户的创建者</strong>：所有新账户都由 System Program 创建</li></ol><p><strong>Hooray！Solana 账户模型学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solana —— 环境搭建与基础命令</title>
      <link href="/2025/10/01/solana-install-and-cli/"/>
      <url>/2025/10/01/solana-install-and-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    pkg-config \</span><br><span class="line">    libudev-dev llvm libclang-dev \</span><br><span class="line">    protobuf-compiler libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Solana 开发组件</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSfL https://solana-install.solana.workers.dev | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">rustc --version &amp;&amp; solana --version &amp;&amp; anchor --version &amp;&amp; node --version &amp;&amp; yarn --version</span><br></pre></td></tr></table></figure><h2 id="2-Solana-CLI-基础"><a href="#2-Solana-CLI-基础" class="headerlink" title="2. Solana CLI 基础"></a>2. Solana CLI 基础</h2><h3 id="2-1-网络配置"><a href="#2-1-网络配置" class="headerlink" title="2.1 网络配置"></a>2.1 网络配置</h3><h4 id="查看当前配置"><a href="#查看当前配置" class="headerlink" title="查看当前配置"></a>查看当前配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br></pre></td></tr></table></figure><h4 id="切换网络"><a href="#切换网络" class="headerlink" title="切换网络"></a>切换网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solana config <span class="built_in">set</span> --url mainnet-beta    <span class="comment"># 主网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url devnet          <span class="comment"># 开发网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url testnet         <span class="comment"># 测试网</span></span><br><span class="line">solana config <span class="built_in">set</span> --url localhost       <span class="comment"># 本地网络</span></span><br></pre></td></tr></table></figure><h3 id="2-2-钱包管理"><a href="#2-2-钱包管理" class="headerlink" title="2.2 钱包管理"></a>2.2 钱包管理</h3><h4 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成新钱包（保存到默认路径）</span></span><br><span class="line">solana-keygen new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成新钱包到指定路径</span></span><br><span class="line">solana-keygen new --outfile ~/.config/solana/wallet.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从助记词恢复钱包</span></span><br><span class="line">solana-keygen recover --outfile ~/.config/solana/wallet.json --force</span><br></pre></td></tr></table></figure><h4 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置默认钱包</span></span><br><span class="line">solana config <span class="built_in">set</span> --keypair ~/.config/solana/wallet.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前钱包地址</span></span><br><span class="line">solana address</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看钱包公钥</span></span><br><span class="line">solana-keygen pubkey ~/.config/solana/wallet.json</span><br></pre></td></tr></table></figure><h3 id="2-3-账户操作"><a href="#2-3-账户操作" class="headerlink" title="2.3 账户操作"></a>2.3 账户操作</h3><h4 id="余额和转账"><a href="#余额和转账" class="headerlink" title="余额和转账"></a>余额和转账</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看余额</span></span><br><span class="line">solana balance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定地址余额</span></span><br><span class="line">solana balance &lt;ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求测试币（仅限 devnet/testnet）</span></span><br><span class="line">solana airdrop 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转账 SOL</span></span><br><span class="line">solana transfer &lt;RECIPIENT_ADDRESS&gt; &lt;AMOUNT&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带备注转账</span></span><br><span class="line">solana transfer &lt;RECIPIENT_ADDRESS&gt; &lt;AMOUNT&gt; --with-memo <span class="string">&quot;转账备注&quot;</span></span><br></pre></td></tr></table></figure><h4 id="账户信息查询"><a href="#账户信息查询" class="headerlink" title="账户信息查询"></a>账户信息查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看账户详细信息</span></span><br><span class="line">solana account &lt;ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账户数据（以 JSON 格式）</span></span><br><span class="line">solana account &lt;ADDRESS&gt; --output json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账户租金状态</span></span><br><span class="line">solana rent 16<span class="comment"># Output: Rent-exempt minimum: 0.00100224 SOL</span></span><br><span class="line">                        <span class="comment"># 表示一个 16 字节大小的账户需要至少 0.00100224 SOL 的余额才能成为租金豁免账户</span></span><br></pre></td></tr></table></figure><h3 id="2-4-交易和日志"><a href="#2-4-交易和日志" class="headerlink" title="2.4 交易和日志"></a>2.4 交易和日志</h3><h4 id="交易操作"><a href="#交易操作" class="headerlink" title="交易操作"></a>交易操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看交易详情</span></span><br><span class="line">solana transaction &lt;SIGNATURE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认交易状态</span></span><br><span class="line">solana confirm &lt;SIGNATURE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最近交易</span></span><br><span class="line">solana transaction-history &lt;ADDRESS&gt; --<span class="built_in">limit</span> 10</span><br></pre></td></tr></table></figure><h4 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时查看程序日志</span></span><br><span class="line">solana logs &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有交易日志</span></span><br><span class="line">solana logs --all</span><br></pre></td></tr></table></figure><h3 id="2-5-网络和验证节点"><a href="#2-5-网络和验证节点" class="headerlink" title="2.5 网络和验证节点"></a>2.5 网络和验证节点</h3><h4 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看集群版本</span></span><br><span class="line">solana cluster-version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络状态</span></span><br><span class="line">solana cluster-date</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看区块产出情况</span></span><br><span class="line">solana block-production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看区块高度</span></span><br><span class="line">solana block-height</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看验证节点列表</span></span><br><span class="line">solana validators</span><br></pre></td></tr></table></figure><h3 id="2-6-本地测试链"><a href="#2-6-本地测试链" class="headerlink" title="2.6 本地测试链"></a>2.6 本地测试链</h3><h4 id="启动和管理"><a href="#启动和管理" class="headerlink" title="启动和管理"></a>启动和管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动本地验证节点</span></span><br><span class="line">solana-test-validator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">solana-test-validator --detach</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置本地链数据</span></span><br><span class="line">solana-test-validator --reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口</span></span><br><span class="line">solana-test-validator --rpc-port 8899 --ws-port 8900</span><br></pre></td></tr></table></figure><h4 id="预加载程序和账户"><a href="#预加载程序和账户" class="headerlink" title="预加载程序和账户"></a>预加载程序和账户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆主网账户到本地</span></span><br><span class="line">solana-test-validator --<span class="built_in">clone</span> &lt;ACCOUNT_ADDRESS&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载程序</span></span><br><span class="line">solana-test-validator --bpf-program &lt;PROGRAM_ID&gt; &lt;PROGRAM_PATH&gt;</span><br></pre></td></tr></table></figure><h3 id="2-7-智能合约操作"><a href="#2-7-智能合约操作" class="headerlink" title="2.7 智能合约操作"></a>2.7 智能合约操作</h3><h4 id="程序部署"><a href="#程序部署" class="headerlink" title="程序部署"></a>程序部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署程序</span></span><br><span class="line">solana program deploy &lt;PROGRAM_FILE.so&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到指定程序 ID</span></span><br><span class="line">solana program deploy &lt;PROGRAM_FILE.so&gt; --program-id &lt;PROGRAM_KEYPAIR&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级程序</span></span><br><span class="line">solana program deploy &lt;NEW_PROGRAM_FILE.so&gt; --program-id &lt;EXISTING_PROGRAM_ID&gt;</span><br></pre></td></tr></table></figure><h4 id="程序管理"><a href="#程序管理" class="headerlink" title="程序管理"></a>程序管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看程序信息</span></span><br><span class="line">solana program show &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出程序</span></span><br><span class="line">solana program dump &lt;PROGRAM_ID&gt; &lt;OUTPUT_FILE&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭程序（回收租金）</span></span><br><span class="line">solana program close &lt;PROGRAM_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置程序升级权限</span></span><br><span class="line">solana program set-upgrade-authority &lt;PROGRAM_ID&gt; --new-upgrade-authority &lt;NEW_AUTHORITY&gt;</span><br></pre></td></tr></table></figure><h2 id="3-Anchor-基础"><a href="#3-Anchor-基础" class="headerlink" title="3. Anchor 基础"></a>3. Anchor 基础</h2><h3 id="3-1-项目管理"><a href="#3-1-项目管理" class="headerlink" title="3.1 项目管理"></a>3.1 项目管理</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新项目</span></span><br><span class="line">anchor init &lt;project-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模板创建: 创建一个包含多个程序的 Anchor 项目结构</span></span><br><span class="line">anchor init &lt;project-name&gt; --template multiple</span><br></pre></td></tr></table></figure><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project-name/</span><br><span class="line">├── Anchor.toml        # Anchor 项目配置文件，包含程序 ID、网络配置、项目名称等</span><br><span class="line">├── Cargo.toml         # Rust 项目依赖配置文件，用于智能合约编译</span><br><span class="line">├── app                # 前端应用目录，存放与 Solana 交互的前端代码</span><br><span class="line">├── migrations         # 部署脚本目录</span><br><span class="line">│   └── deploy.ts      # 部署合约到指定网络的 TypeScript 脚本</span><br><span class="line">├── package.json       # JavaScript/TypeScript 项目依赖和脚本配置</span><br><span class="line">├── programs           # 智能合约代码目录</span><br><span class="line">│   └── firewords      # 具体智能合约子目录</span><br><span class="line">├── target             # Rust 编译输出目录</span><br><span class="line">│   └── deploy         # 编译后的程序文件，用于部署</span><br><span class="line">├── tests              # 测试文件目录</span><br><span class="line">│   └── firewords.ts   # 针对 firewords 合约的测试脚本</span><br><span class="line">├── tsconfig.json      # TypeScript 编译配置</span><br><span class="line">└── yarn.lock          # 锁定 JavaScript/TypeScript 依赖版本，确保一致性</span><br></pre></td></tr></table></figure><h3 id="3-2-开发流程"><a href="#3-2-开发流程" class="headerlink" title="3.2 开发流程"></a>3.2 开发流程</h3><h4 id="编译、部署和测试"><a href="#编译、部署和测试" class="headerlink" title="编译、部署和测试"></a>编译、部署和测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译项目</span></span><br><span class="line">anchor build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到当前网络</span></span><br><span class="line">anchor deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">anchor <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试（跳过构建）</span></span><br><span class="line">anchor <span class="built_in">test</span> --skip-build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行特定测试</span></span><br><span class="line">anchor <span class="built_in">test</span> --grep <span class="string">&quot;test_name&quot;</span></span><br></pre></td></tr></table></figure><h4 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成程序密钥对</span></span><br><span class="line">anchor keys list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步程序 ID</span></span><br><span class="line">anchor keys <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p><strong>Hooray！Solana 开发环境准备就绪！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 生命周期</title>
      <link href="/2025/09/30/rust-lifetimes/"/>
      <url>/2025/09/30/rust-lifetimes/</url>
      
        <content type="html"><![CDATA[<p>生命周期（Lifetime）是 Rust 中确保引用有效性的机制。每个引用都有生命周期，即引用保持有效的作用域。大多数情况下生命周期是隐式推断的，但在某些情况下需要显式标注。</p><h2 id="1-生命周期的作用"><a href="#1-生命周期的作用" class="headerlink" title="1. 生命周期的作用"></a>1. 生命周期的作用</h2><h3 id="1-1-防止悬垂引用"><a href="#1-1-防止悬垂引用" class="headerlink" title="1.1 防止悬垂引用"></a>1.1 防止悬垂引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;  <span class="comment">// ❌ 错误：x 的生命周期太短</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会阻止这段代码，因为 <code>x</code> 在使用 <code>r</code> 之前就被销毁了。</p><h3 id="1-2-借用检查器"><a href="#1-2-借用检查器" class="headerlink" title="1.2 借用检查器"></a>1.2 借用检查器</h3><p>Rust 的借用检查器比较引用的生命周期，确保所有引用都是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// --------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//         |</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;           <span class="comment">// --+-- &#x27;b|</span></span><br><span class="line">                          <span class="comment">//   |     |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//   |     |</span></span><br><span class="line">                          <span class="comment">// --+     |</span></span><br><span class="line">&#125;                         <span class="comment">// --------+</span></span><br></pre></td></tr></table></figure><h2 id="2-函数中的生命周期标注"><a href="#2-函数中的生命周期标注" class="headerlink" title="2. 函数中的生命周期标注"></a>2. 函数中的生命周期标注</h2><h3 id="2-1-为什么需要标注"><a href="#2-1-为什么需要标注" class="headerlink" title="2.1 为什么需要标注"></a>2.1 为什么需要标注</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;  <span class="comment">// ❌ 缺少生命周期标注</span></span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器无法确定返回的引用是 <code>x</code> 还是 <code>y</code>，因此无法判断返回引用的生命周期。</p><h3 id="2-2-生命周期标注语法"><a href="#2-2-生命周期标注语法" class="headerlink" title="2.2 生命周期标注语法"></a>2.2 生命周期标注语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>生命周期参数名称：</p><ul><li>以 <code>&#39;</code> 开头</li><li>通常使用小写字母</li><li><code>&#39;a</code> 是最常用的名称</li></ul><h3 id="2-3-函数签名中的生命周期"><a href="#2-3-函数签名中的生命周期" class="headerlink" title="2.3 函数签名中的生命周期"></a>2.3 函数签名中的生命周期</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含义：</strong> 返回值的生命周期与参数中较短的生命周期相同。</p><h3 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);  <span class="comment">// ✅ 有效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);  <span class="comment">// ❌ 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结构体中的生命周期"><a href="#3-结构体中的生命周期" class="headerlink" title="3. 结构体中的生命周期"></a>3. 结构体中的生命周期</h2><h3 id="3-1-定义包含引用的结构体"><a href="#3-1-定义包含引用的结构体" class="headerlink" title="3.1 定义包含引用的结构体"></a>3.1 定义包含引用的结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含义：</strong> <code>ImportantExcerpt</code> 实例的生命周期不能超过 <code>part</code> 字段引用的数据。</p><h2 id="4-生命周期省略规则"><a href="#4-生命周期省略规则" class="headerlink" title="4. 生命周期省略规则"></a>4. 生命周期省略规则</h2><p>编译器使用三条规则自动推断生命周期：</p><ol><li><p><strong>每个引用参数都有自己的生命周期</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果只有一个输入生命周期，赋予所有输出生命周期</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果是方法且有多个输入生命周期，其中之一是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期赋予所有输出生命周期</strong></p></li></ol><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要标注</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要标注</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-方法中的生命周期"><a href="#5-方法中的生命周期" class="headerlink" title="5. 方法中的生命周期"></a>5. 方法中的生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-静态生命周期"><a href="#6-静态生命周期" class="headerlink" title="6. 静态生命周期"></a>6. 静态生命周期</h2><p><code>&#39;static</code> 表示引用在整个程序期间都有效：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong> 字符串字面量、全局变量。</p><p><strong>警告：</strong> 不要滥用 <code>&#39;static</code>，大多数情况下问题在于尝试创建悬垂引用。</p><h2 id="7-泛型、Trait-和生命周期结合"><a href="#7-泛型、Trait-和生命周期结合" class="headerlink" title="7. 泛型、Trait 和生命周期结合"></a>7. 泛型、Trait 和生命周期结合</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>生命周期标注</strong>：描述引用之间的关系，不改变实际生命周期</li><li><strong>借用检查器</strong>：确保所有引用在使用时都是有效的</li><li><strong>省略规则</strong>：大多数情况下编译器可以自动推断</li><li><strong>结构体生命周期</strong>：包含引用的结构体需要标注生命周期</li><li><strong>‘static</strong>：整个程序期间有效的引用</li></ul><p>生命周期是 Rust 确保内存安全的重要机制，虽然初学时可能感到困惑，但理解后能帮助我们编写更安全的代码。</p><p><strong>Hooray！生命周期学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 特征</title>
      <link href="/2025/09/29/rust-traits/"/>
      <url>/2025/09/29/rust-traits/</url>
      
        <content type="html"><![CDATA[<p>Trait 定义了类型可以共享的行为。可以使用 trait 以抽象的方式定义共享行为，使用 trait 约束指定泛型类型必须具有特定行为。</p><p><strong>注意：</strong> Trait 类似其他语言中的接口（interface），但有一些区别。</p><h2 id="1-定义-Trait"><a href="#1-定义-Trait" class="headerlink" title="1. 定义 Trait"></a>1. 定义 Trait</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trait 使用 <code>trait</code> 关键字定义，方法签名以分号结尾。</p><h3 id="1-2-多个方法"><a href="#1-2-多个方法" class="headerlink" title="1.2 多个方法"></a>1.2 多个方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-实现-Trait"><a href="#2-实现-Trait" class="headerlink" title="2. 实现 Trait"></a>2. 实现 Trait</h2><h3 id="2-1-为类型实现-trait"><a href="#2-1-为类型实现-trait" class="headerlink" title="2.1 为类型实现 trait"></a>2.1 为类型实现 trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-为另一个类型实现"><a href="#2-2-为另一个类型实现" class="headerlink" title="2.2 为另一个类型实现"></a>2.2 为另一个类型实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用-trait"><a href="#2-3-使用-trait" class="headerlink" title="2.3 使用 trait"></a>2.3 使用 trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-默认实现"><a href="#3-默认实现" class="headerlink" title="3. 默认实现"></a>3. 默认实现</h2><h3 id="3-1-提供默认行为"><a href="#3-1-提供默认行为" class="headerlink" title="3.1 提供默认行为"></a>3.1 提供默认行为</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用默认实现"><a href="#3-2-使用默认实现" class="headerlink" title="3.2 使用默认实现"></a>3.2 使用默认实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;  <span class="comment">// 使用默认实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best...&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New article: &#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>());  <span class="comment">// (Read more...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-默认实现调用其他方法"><a href="#3-3-默认实现调用其他方法" class="headerlink" title="3.3 默认实现调用其他方法"></a>3.3 默认实现调用其他方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Trait-作为参数"><a href="#4-Trait-作为参数" class="headerlink" title="4. Trait 作为参数"></a>4. Trait 作为参数</h2><h3 id="4-1-impl-Trait-语法"><a href="#4-1-impl-Trait-语法" class="headerlink" title="4.1 impl Trait 语法"></a>4.1 impl Trait 语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Trait-Bound-语法"><a href="#4-2-Trait-Bound-语法" class="headerlink" title="4.2 Trait Bound 语法"></a>4.2 Trait Bound 语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-多个-trait-约束"><a href="#4-3-多个-trait-约束" class="headerlink" title="4.3 多个 trait 约束"></a>4.3 多个 trait 约束</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用 trait bound</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-where-子句"><a href="#4-4-where-子句" class="headerlink" title="4.4 where 子句"></a>4.4 where 子句</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-返回实现-Trait-的类型"><a href="#5-返回实现-Trait-的类型" class="headerlink" title="5. 返回实现 Trait 的类型"></a>5. 返回实现 Trait 的类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong> 只能返回单一类型，不能根据条件返回不同类型。</p><h2 id="6-孤儿规则"><a href="#6-孤儿规则" class="headerlink" title="6. 孤儿规则"></a>6. 孤儿规则</h2><p>只有当 trait 或类型至少有一个是在当前 crate 中定义的，才能为该类型实现 trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 可以：Summary 在当前 crate 定义</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不行：Display 和 Vec 都在标准库中</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="7-使用-Trait-Bound-有条件地实现方法"><a href="#7-使用-Trait-Bound-有条件地实现方法" class="headerlink" title="7. 使用 Trait Bound 有条件地实现方法"></a>7. 使用 Trait Bound 有条件地实现方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Blanket-Implementations"><a href="#8-Blanket-Implementations" class="headerlink" title="8. Blanket Implementations"></a>8. Blanket Implementations</h2><p>为所有满足特定 trait bound 的类型实现 trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// ToString 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着任何实现了 <code>Display</code> 的类型都自动实现了 <code>ToString</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>定义 trait</strong>：使用 <code>trait</code> 关键字定义共享行为</li><li><strong>实现 trait</strong>：使用 <code>impl Trait for Type</code> 语法</li><li><strong>默认实现</strong>：可以在 trait 中提供默认方法实现</li><li><strong>trait 参数</strong>：使用 <code>impl Trait</code> 或 trait bound 语法</li><li><strong>孤儿规则</strong>：保证 trait 实现的一致性</li></ul><p>Trait 是 Rust 实现多态和代码复用的核心机制，配合泛型可以编写灵活且类型安全的代码。</p><p><strong>Hooray！特征学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 泛型</title>
      <link href="/2025/09/28/rust-generic-types/"/>
      <url>/2025/09/28/rust-generic-types/</url>
      
        <content type="html"><![CDATA[<p>泛型允许我们用抽象的类型参数替代具体类型，从而编写可复用的代码。Rust 在编译时会进行<strong>单态化（Monomorphization）</strong>，将泛型代码转换为具体类型的代码，因此使用泛型不会带来运行时性能损失。</p><h2 id="1-泛型函数"><a href="#1-泛型函数" class="headerlink" title="1. 泛型函数"></a>1. 泛型函数</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码无法编译，因为 <code>T</code> 没有实现比较操作符。需要添加 trait 约束。</p><h3 id="1-2-带-trait-约束的泛型函数"><a href="#1-2-带-trait-约束的泛型函数" class="headerlink" title="1.2 带 trait 约束的泛型函数"></a>1.2 带 trait 约束的泛型函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-多个泛型参数"><a href="#1-3-多个泛型参数" class="headerlink" title="1.3 多个泛型参数"></a>1.3 多个泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_two_things</span>&lt;T, U&gt;(x: T, y: U) &#123;</span><br><span class="line">    <span class="comment">// 使用不同类型的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-泛型结构体"><a href="#2-泛型结构体" class="headerlink" title="2. 泛型结构体"></a>2. 泛型结构体</h2><h3 id="2-1-单一泛型参数"><a href="#2-1-单一泛型参数" class="headerlink" title="2.1 单一泛型参数"></a>2.1 单一泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>x</code> 和 <code>y</code> 必须是相同类型。</p><h3 id="2-2-多个泛型参数"><a href="#2-2-多个泛型参数" class="headerlink" title="2.2 多个泛型参数"></a>2.2 多个泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;  <span class="comment">// x 是 i32, y 是 f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-泛型枚举"><a href="#3-泛型枚举" class="headerlink" title="3. 泛型枚举"></a>3. 泛型枚举</h2><h3 id="3-1-Option-枚举"><a href="#3-1-Option-枚举" class="headerlink" title="3.1 Option 枚举"></a>3.1 Option 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Result-枚举"><a href="#3-2-Result-枚举" class="headerlink" title="3.2 Result 枚举"></a>3.2 Result 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个枚举是 Rust 标准库中最常用的泛型枚举。</p><h2 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h2><h3 id="4-1-为泛型结构体实现方法"><a href="#4-1-为泛型结构体实现方法" class="headerlink" title="4.1 为泛型结构体实现方法"></a>4.1 为泛型结构体实现方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 需要在 <code>impl</code> 后声明 <code>&lt;T&gt;</code>，表示为泛型类型 <code>Point&lt;T&gt;</code> 实现方法。</p><h3 id="4-2-为特定类型实现方法"><a href="#4-2-为特定类型实现方法" class="headerlink" title="4.2 为特定类型实现方法"></a>4.2 为特定类型实现方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只对 <code>Point&lt;f32&gt;</code> 有效。</p><h3 id="4-3-方法中的额外泛型参数"><a href="#4-3-方法中的额外泛型参数" class="headerlink" title="4.3 方法中的额外泛型参数"></a>4.3 方法中的额外泛型参数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);  <span class="comment">// 5, c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-泛型的性能"><a href="#5-泛型的性能" class="headerlink" title="5. 泛型的性能"></a>5. 泛型的性能</h2><p>Rust 使用<strong>单态化</strong>在编译时将泛型代码展开为具体类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p>编译后实际生成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure><p><strong>优点：</strong> 运行时零成本抽象，性能等同于手写具体类型。</p><p><strong>缺点：</strong> 会增加编译时间和二进制文件大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>泛型函数</strong>：使用 <code>&lt;T&gt;</code> 定义类型参数，提高代码复用性</li><li><strong>泛型结构体&#x2F;枚举</strong>：可以存储任意类型的数据</li><li><strong>泛型方法</strong>：在 <code>impl&lt;T&gt;</code> 中声明类型参数</li><li><strong>零成本抽象</strong>：编译时单态化，运行时无性能损失</li></ul><p>泛型是 Rust 中实现代码复用和抽象的重要工具，配合 trait 约束可以实现强大的类型安全保证。</p><p><strong>Hooray！泛型学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 错误处理</title>
      <link href="/2025/09/27/rust-error-handling/"/>
      <url>/2025/09/27/rust-error-handling/</url>
      
        <content type="html"><![CDATA[<p>Rust 将错误分为两大类：<strong>可恢复错误</strong>和<strong>不可恢复错误</strong>。可恢复错误用 <code>Result&lt;T, E&gt;</code> 处理，不可恢复错误用 <code>panic!</code> 宏处理。Rust 没有异常机制，强制你在编译时就考虑错误处理。</p><h2 id="1-panic-——-不可恢复错误"><a href="#1-panic-——-不可恢复错误" class="headerlink" title="1. panic! —— 不可恢复错误"></a>1. panic! —— 不可恢复错误</h2><h3 id="1-1-触发-panic"><a href="#1-1-触发-panic" class="headerlink" title="1.1 触发 panic"></a>1.1 触发 panic</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会打印错误信息、清理栈并退出。</p><h3 id="1-2-panic-时的栈展开"><a href="#1-2-panic-时的栈展开" class="headerlink" title="1.2 panic 时的栈展开"></a>1.2 panic 时的栈展开</h3><p>默认情况下，panic 会展开栈并清理数据。可以在 <code>Cargo.toml</code> 中配置直接终止：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-panic-回溯"><a href="#1-3-panic-回溯" class="headerlink" title="1.3 panic 回溯"></a>1.3 panic 回溯</h3><p>设置环境变量查看详细回溯信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure><h2 id="2-Result-——-可恢复错误"><a href="#2-Result-——-可恢复错误" class="headerlink" title="2. Result —— 可恢复错误"></a>2. Result —— 可恢复错误</h2><h3 id="2-1-Result-枚举"><a href="#2-1-Result-枚举" class="headerlink" title="2.1 Result 枚举"></a>2.1 Result 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用-match-处理"><a href="#2-2-使用-match-处理" class="headerlink" title="2.2 使用 match 处理"></a>2.2 使用 match 处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-匹配不同错误类型"><a href="#2-3-匹配不同错误类型" class="headerlink" title="2.3 匹配不同错误类型"></a>2.3 匹配不同错误类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;创建文件失败: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, other_error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-使用闭包简化"><a href="#2-4-使用闭包简化" class="headerlink" title="2.4 使用闭包简化"></a>2.4 使用闭包简化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;创建文件失败: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;打开文件出错: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-unwrap-和-expect"><a href="#3-unwrap-和-expect" class="headerlink" title="3. unwrap 和 expect"></a>3. unwrap 和 expect</h2><h3 id="3-1-unwrap"><a href="#3-1-unwrap" class="headerlink" title="3.1 unwrap"></a>3.1 unwrap</h3><p><code>unwrap</code> 是 <code>match</code> 的快捷方式，成功返回值，失败则 <code>panic</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-expect"><a href="#3-2-expect" class="headerlink" title="3.2 expect"></a>3.2 expect</h3><p><code>expect</code> 类似 <code>unwrap</code>，但可以自定义错误信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法打开 hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>推荐：</strong> 生产代码中优先使用 <code>expect</code>，提供清晰的上下文信息。</p><h2 id="4-传播错误"><a href="#4-传播错误" class="headerlink" title="4. 传播错误"></a>4. 传播错误</h2><h3 id="4-1-返回-Result"><a href="#4-1-返回-Result" class="headerlink" title="4.1 返回 Result"></a>4.1 返回 Result</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用-运算符"><a href="#4-2-使用-运算符" class="headerlink" title="4.2 使用 ? 运算符"></a>4.2 使用 ? 运算符</h3><p><code>?</code> 运算符是传播错误的简写：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简洁版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-运算符用于-Option"><a href="#4-3-运算符用于-Option" class="headerlink" title="4.3 ? 运算符用于 Option"></a>4.3 ? 运算符用于 Option</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>?</code> 只能用在返回 <code>Result</code> 或 <code>Option</code> 的函数中。</p><h3 id="4-4-main-函数返回-Result"><a href="#4-4-main-函数返回-Result" class="headerlink" title="4.4 main 函数返回 Result"></a>4.4 main 函数返回 Result</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-何时使用-panic"><a href="#5-何时使用-panic" class="headerlink" title="5. 何时使用 panic!"></a>5. 何时使用 panic!</h2><h3 id="5-1-适合-panic-的场景"><a href="#5-1-适合-panic-的场景" class="headerlink" title="5.1 适合 panic 的场景"></a>5.1 适合 panic 的场景</h3><ul><li><strong>示例、原型代码</strong>：使用 <code>unwrap</code> 快速编写</li><li><strong>测试代码</strong>：测试失败应该 panic</li><li><strong>逻辑保证不会失败</strong>：编译器无法理解但你确定的情况</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;硬编码的 IP 地址应该有效&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-应该返回-Result-的场景"><a href="#5-2-应该返回-Result-的场景" class="headerlink" title="5.2 应该返回 Result 的场景"></a>5.2 应该返回 Result 的场景</h3><ul><li><strong>预期可能失败</strong>：如解析用户输入、网络请求</li><li><strong>调用者需要决定如何处理</strong>：错误处理策略由调用方决定</li></ul><h3 id="5-3-违反约定时-panic"><a href="#5-3-违反约定时-panic" class="headerlink" title="5.3 违反约定时 panic"></a>5.3 违反约定时 panic</h3><p>当代码接收到无效值时，应该 panic：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess 值必须在 1 到 100 之间，得到 &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-常用错误处理方法"><a href="#6-常用错误处理方法" class="headerlink" title="6. 常用错误处理方法"></a>6. 常用错误处理方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unwrap_or：提供默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unwrap_or_else：使用闭包计算默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or_else</span>(|_| <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unwrap_or_default：使用类型的默认值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="string">&quot;abc&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_or_default</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// and_then：链式操作</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">and_then</span>(|<span class="keyword">mut</span> file| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(contents)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>panic!</strong>：用于不可恢复的错误，程序无法继续执行</li><li><strong>Result&lt;T, E&gt;</strong>：用于可恢复的错误，允许调用者决定如何处理</li><li><strong>? 运算符</strong>：简化错误传播，使代码更简洁</li><li><strong>unwrap&#x2F;expect</strong>：快速原型开发，生产代码优先使用 <code>expect</code></li></ul><p>Rust 的错误处理系统强制你在编译时考虑错误情况，虽然初期可能觉得繁琐，但能显著提高代码的健壮性和可靠性。</p><p><strong>Hooray！错误处理学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 常见集合</title>
      <link href="/2025/09/26/rust-common-collections/"/>
      <url>/2025/09/26/rust-common-collections/</url>
      
        <content type="html"><![CDATA[<p>Rust 标准库包含了一些非常实用的数据结构，称为<strong>集合（Collections）</strong>。与普通数据类型不同，集合可以包含多个值，数据存储在<strong>堆</strong>上，大小可以在运行时动态变化。</p><p>本文介绍三种最常用的集合：<strong>Vector</strong>、<strong>String</strong> 和 <strong>HashMap</strong>。</p><h2 id="1-Vector（向量）"><a href="#1-Vector（向量）" class="headerlink" title="1. Vector（向量）"></a>1. Vector（向量）</h2><h3 id="1-1-创建和更新-Vector"><a href="#1-1-创建和更新-Vector" class="headerlink" title="1.1 创建和更新 Vector"></a>1.1 创建和更新 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空 Vector</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="1-2-读取元素"><a href="#1-2-读取元素" class="headerlink" title="1.2 读取元素"></a>1.2 读取元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：索引（越界会 panic）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：get 方法（返回 Option）</span></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;没有第三个元素&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-遍历-Vector"><a href="#1-3-遍历-Vector" class="headerlink" title="1.3 遍历 Vector"></a>1.3 遍历 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变遍历</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变遍历</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 不能在持有 Vector 元素的不可变引用时修改 Vector。</p><h3 id="1-4-存储多种类型"><a href="#1-4-存储多种类型" class="headerlink" title="1.4 存储多种类型"></a>1.4 存储多种类型</h3><p>使用枚举在 Vector 中存储不同类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="2-String（字符串）"><a href="#2-String（字符串）" class="headerlink" title="2. String（字符串）"></a>2. String（字符串）</h2><h3 id="2-1-创建-String"><a href="#2-1-创建-String" class="headerlink" title="2.1 创建 String"></a>2.1 创建 String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><h3 id="2-2-更新-String"><a href="#2-2-更新-String" class="headerlink" title="2.2 更新 String"></a>2.2 更新 String</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);  <span class="comment">// 追加字符串</span></span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);        <span class="comment">// 追加字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-拼接字符串"><a href="#2-3-拼接字符串" class="headerlink" title="2.3 拼接字符串"></a>2.3 拼接字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 + 运算符（会移动 s1）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 format! 宏（推荐）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure><h3 id="2-4-索引字符串"><a href="#2-4-索引字符串" class="headerlink" title="2.4 索引字符串"></a>2.4 索引字符串</h3><p>Rust <strong>不支持</strong>直接索引字符串：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];  <span class="comment">// ❌ 错误！</span></span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 字符串是 UTF-8 编码，一个字符可能占用多个字节。</p><h3 id="2-5-遍历字符串"><a href="#2-5-遍历字符串" class="headerlink" title="2.5 遍历字符串"></a>2.5 遍历字符串</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字节</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-HashMap（哈希映射）"><a href="#3-HashMap（哈希映射）" class="headerlink" title="3. HashMap（哈希映射）"></a>3. HashMap（哈希映射）</h2><h3 id="3-1-创建-HashMap"><a href="#3-1-创建-HashMap" class="headerlink" title="3.1 创建 HashMap"></a>3.1 创建 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>collect</code> 创建：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure><h3 id="3-2-访问值"><a href="#3-2-访问值" class="headerlink" title="3.2 访问值"></a>3.2 访问值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> scores.<span class="title function_ invoke__">get</span>(&amp;team_name) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(&amp;s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;分数: &#123;&#125;&quot;</span>, s),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;队伍不存在&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-遍历-HashMap"><a href="#3-3-遍历-HashMap" class="headerlink" title="3.3 遍历 HashMap"></a>3.3 遍历 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> HashMap 是<strong>无序的</strong>。</p><h3 id="3-4-更新-HashMap"><a href="#3-4-更新-HashMap" class="headerlink" title="3.4 更新 HashMap"></a>3.4 更新 HashMap</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆盖值</span></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在键不存在时插入</span></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于旧值更新</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-所有权"><a href="#3-5-所有权" class="headerlink" title="3.5 所有权"></a>3.5 所有权</h3><p>对于 <code>String</code> 等类型，插入 HashMap 后所有权会转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// field_name 和 field_value 在此处无效</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Vector</strong>：动态数组，适合存储同类型的列表数据</li><li><strong>String</strong>：UTF-8 编码的字符串，不支持索引但可遍历</li><li><strong>HashMap</strong>：键值对存储，提供快速查找能力</li></ul><p>掌握这三种集合的使用是编写 Rust 程序的基础。记住它们都存储在堆上，理解所有权规则对正确使用集合至关重要。</p><p><strong>Hooray！常见集合学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 枚举和模式匹配</title>
      <link href="/2025/09/25/rust-enums-and-pattern-matching/"/>
      <url>/2025/09/25/rust-enums-and-pattern-matching/</url>
      
        <content type="html"><![CDATA[<p>枚举（Enum）允许我们通过列举所有可能的变体来定义一个类型。与结构体类似，枚举也可以包含数据和方法，但更适合表示”多选一”的情况。</p><h2 id="1-定义和使用枚举"><a href="#1-定义和使用枚举" class="headerlink" title="1. 定义和使用枚举"></a>1. 定义和使用枚举</h2><h3 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a>1.1 基本定义</h3><p>使用 <code>enum</code> 关键字定义枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-枚举携带数据"><a href="#1-2-枚举携带数据" class="headerlink" title="1.2 枚举携带数据"></a>1.2 枚举携带数据</h3><p>枚举的每个变体可以关联不同类型和数量的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-多种数据形式"><a href="#1-3-多种数据形式" class="headerlink" title="1.3 多种数据形式"></a>1.3 多种数据形式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,                       <span class="comment">// 无关联数据</span></span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,   <span class="comment">// 具名字段</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),              <span class="comment">// 单个 String</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>), <span class="comment">// 三个 i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-枚举方法"><a href="#1-4-枚举方法" class="headerlink" title="1.4 枚举方法"></a>1.4 枚举方法</h3><p>可以使用 <code>impl</code> 为枚举定义方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Option-枚举"><a href="#2-Option-枚举" class="headerlink" title="2. Option 枚举"></a>2. Option 枚举</h2><p>Rust 没有空值（null），使用 <code>Option&lt;T&gt;</code> 表示值可能存在或不存在：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;文本&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 必须将 <code>Option&lt;T&gt;</code> 转换为 <code>T</code> 才能使用，这强制我们处理可能为空的情况。</p><h2 id="3-match-控制流"><a href="#3-match-控制流" class="headerlink" title="3. match 控制流"></a>3. match 控制流</h2><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-绑定值的模式"><a href="#3-2-绑定值的模式" class="headerlink" title="3.2 绑定值的模式"></a>3.2 绑定值的模式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-匹配-Option"><a href="#3-3-匹配-Option" class="headerlink" title="3.3 匹配 Option"></a>3.3 匹配 Option<T></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-穷尽性检查"><a href="#3-4-穷尽性检查" class="headerlink" title="3.4 穷尽性检查"></a>3.4 穷尽性检查</h3><p><strong>重要：</strong> match 必须覆盖所有可能的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译错误！缺少 None 分支</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-通配符"><a href="#3-5-通配符" class="headerlink" title="3.5 通配符 _"></a>3.5 通配符 <code>_</code></h3><p>使用 <code>_</code> 匹配剩余所有情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reroll</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>不执行任何操作时使用 <code>()</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-if-let-简洁控制流"><a href="#4-if-let-简洁控制流" class="headerlink" title="4. if let 简洁控制流"></a>4. if let 简洁控制流</h2><h3 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h3><p>当只关心一种匹配情况时，使用 <code>if let</code> 更简洁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 match</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;最大值: &#123;&#125;&quot;</span>, max),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 if let（更简洁）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;最大值: &#123;&#125;&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-配合-else-使用"><a href="#4-2-配合-else-使用" class="headerlink" title="4.2 配合 else 使用"></a>4.2 配合 else 使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;州的 25 美分硬币: &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-实战示例"><a href="#5-实战示例" class="headerlink" title="5. 实战示例"></a>5. 实战示例</h2><h3 id="5-1-消息处理"><a href="#5-1-消息处理" class="headerlink" title="5.1 消息处理"></a>5.1 消息处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello,</span><br><span class="line">    Goodbye,</span><br><span class="line">    <span class="title function_ invoke__">Body</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Wait</span>(<span class="type">String</span>, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_msg</span>(m: Message) &#123;</span><br><span class="line">    <span class="keyword">match</span> m &#123;</span><br><span class="line">        Message::Hello =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Hi&quot;</span>),</span><br><span class="line">        Message::Goodbye =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Bye&quot;</span>),</span><br><span class="line">        Message::<span class="title function_ invoke__">Body</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg),</span><br><span class="line">        Message::<span class="title function_ invoke__">Wait</span>(time, len) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;等待 &#123;&#125; &#123;&#125;&quot;</span>, len, time),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-状态机"><a href="#5-2-状态机" class="headerlink" title="5.2 状态机"></a>5.2 状态机</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    Idle,</span><br><span class="line">    Running,</span><br><span class="line">    Stopped,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Machine</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">start</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">            State::Idle =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line">                <span class="keyword">self</span>.state = State::Running;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;无法启动&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举与模式匹配是 Rust 中最强大的特性之一。通过合理使用，我们可以：</p><ul><li><strong>类型安全</strong>：编译时确保处理所有可能情况</li><li><strong>表达力强</strong>：不同变体可以携带不同类型数据</li><li><strong>消除空指针</strong>：通过 <code>Option&lt;T&gt;</code> 安全处理空值</li><li><strong>代码清晰</strong>：match 让逻辑分支一目了然</li></ul><p>掌握枚举和模式匹配，为后续学习 Result 错误处理、trait 等高级特性打下基础。</p><p><strong>Hooray！枚举和模式匹配学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 结构体</title>
      <link href="/2025/09/24/rust-structs/"/>
      <url>/2025/09/24/rust-structs/</url>
      
        <content type="html"><![CDATA[<p>结构体（Struct）和元组类似，都可以包含不同类型的数据。但与元组不同的是，结构体中的每个字段都有命名，因此更加清晰、灵活。我们不需要依赖数据的顺序来访问值，而是通过字段名来访问。</p><h2 id="1-定义和实例化结构体"><a href="#1-定义和实例化结构体" class="headerlink" title="1. 定义和实例化结构体"></a>1. 定义和实例化结构体</h2><h3 id="1-1-定义结构体"><a href="#1-1-定义结构体" class="headerlink" title="1.1 定义结构体"></a>1.1 定义结构体</h3><p>使用 <code>struct</code> 关键字定义结构体，在花括号中列出字段名称和类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要让某些结构体或字段在模块外可见，需要加 <code>pub</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,    <span class="comment">// 公有字段，模块外可访问</span></span><br><span class="line">    email: <span class="type">String</span>,           <span class="comment">// 私有字段，只能在当前模块访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建实例"><a href="#1-2-创建实例" class="headerlink" title="1.2 创建实例"></a>1.2 创建实例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 字段初始化时顺序不需要与定义顺序一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),  <span class="comment">// 顺序可以不同</span></span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-可变结构体"><a href="#1-3-可变结构体" class="headerlink" title="1.3 可变结构体"></a>1.3 可变结构体</h3><p>实例默认是不可变的，若要修改字段，需加上 <code>mut</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">    user1.sign_in_count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-简化结构体初始化"><a href="#2-简化结构体初始化" class="headerlink" title="2. 简化结构体初始化"></a>2. 简化结构体初始化</h2><p>在函数中返回结构体时，当变量名与字段名相同，可以省略字段名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,        <span class="comment">// 等价于 username: username</span></span><br><span class="line">        email,           <span class="comment">// 等价于 email: email</span></span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-基于已有实例创建新实例"><a href="#3-基于已有实例创建新实例" class="headerlink" title="3. 基于已有实例创建新实例"></a>3. 基于已有实例创建新实例</h2><h3 id="3-1-普通写法"><a href="#3-1-普通写法" class="headerlink" title="3.1 普通写法"></a>3.1 普通写法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,     <span class="comment">// String 没有实现 Copy，所有权被移动</span></span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-结构体更新语法"><a href="#3-2-结构体更新语法" class="headerlink" title="3.2 结构体更新语法"></a>3.2 结构体更新语法</h3><p>Rust 提供了 <code>..</code> 语法来复用字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意：</strong></p><ul><li><code>..user1</code> 必须写在最后</li><li>由于 <code>username</code> 是 <code>String</code> 类型（没有实现 <code>Copy</code>），所有权被转移到 <code>user2</code></li><li>创建 <code>user2</code> 后，<code>user1</code> 不能再作为整体使用</li><li><code>user1.active</code> 和 <code>user1.sign_in_count</code> 仍可使用，因为它们实现了 <code>Copy</code> trait</li></ul><h3 id="3-3-所有权友好的更新语法示例"><a href="#3-3-所有权友好的更新语法示例" class="headerlink" title="3.3 所有权友好的更新语法示例"></a>3.3 所有权友好的更新语法示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,  <span class="comment">// i32 实现了 Copy</span></span><br><span class="line">    y: <span class="type">i32</span>,  <span class="comment">// i32 实现了 Copy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="number">3</span>, ..p1 &#125;;  <span class="comment">// p1 仍然可用，因为所有字段都实现了 Copy</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);  <span class="comment">// 正常工作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元组结构体（Tuple-Struct）"><a href="#4-元组结构体（Tuple-Struct）" class="headerlink" title="4. 元组结构体（Tuple Struct）"></a>4. 元组结构体（Tuple Struct）</h2><p>如果只关心字段类型而不关心字段名，可以使用<strong>元组结构体</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引访问</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;红色分量: &#123;&#125;&quot;</span>, black.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 坐标: &#123;&#125;&quot;</span>, origin.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 虽然 <code>Color</code> 和 <code>Point</code> 的字段类型相同，但它们是不同的结构体类型，不能互相赋值。</p><h2 id="5-单元结构体（Unit-like-Struct）"><a href="#5-单元结构体（Unit-like-Struct）" class="headerlink" title="5. 单元结构体（Unit-like Struct）"></a>5. 单元结构体（Unit-like Struct）</h2><p>当结构体不需要任何字段，只关心类型行为时，可以使用<strong>单元结构体</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元结构体常用于实现 trait，但不需要存储数据的场景。</p><h2 id="6-嵌套结构体（Structs-内含-Structs）"><a href="#6-嵌套结构体（Structs-内含-Structs）" class="headerlink" title="6. 嵌套结构体（Structs 内含 Structs）"></a>6. 嵌套结构体（Structs 内含 Structs）</h2><p>结构体字段本身可以是另一个结构体类型，这样可以构造更复杂的数据模型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    street: <span class="type">String</span>,</span><br><span class="line">    zip_code: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    address: Address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = User &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john_doe&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;john@example.com&quot;</span>),</span><br><span class="line">        address: Address &#123;</span><br><span class="line">            city: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;北京&quot;</span>),</span><br><span class="line">            street: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;长安街1号&quot;</span>),</span><br><span class="line">            zip_code: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;100000&quot;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户城市: &#123;&#125;&quot;</span>, user.address.city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-调试结构体"><a href="#7-调试结构体" class="headerlink" title="7. 调试结构体"></a>7. 调试结构体</h2><p>默认情况下，<code>println!</code> 不能直接打印结构体。可以通过 <code>#[derive(Debug)]</code> 启用调试格式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);        <span class="comment">// 单行输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:#?&#125;&quot;</span>, rect1);       <span class="comment">// 更美观的多行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用 <code>dbg!</code> 宏进行调试，<code>dbg!</code> 会打印源码位置和表达式值，并返回该值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),  <span class="comment">// 会打印计算过程</span></span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);  <span class="comment">// 会打印整个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-访问结构体字段"><a href="#8-访问结构体字段" class="headerlink" title="8. 访问结构体字段"></a>8. 访问结构体字段</h2><p>使用点号语法访问结构体字段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字段</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;用户名: &#123;&#125;&quot;</span>, user1.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;邮箱: &#123;&#125;&quot;</span>, user1.email);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;活跃状态: &#123;&#125;&quot;</span>, user1.active);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改字段（需要 mut）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user2@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user2.active = <span class="literal">true</span>;</span><br><span class="line">    user2.sign_in_count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-方法与关联函数"><a href="#9-方法与关联函数" class="headerlink" title="9. 方法与关联函数"></a>9. 方法与关联函数</h2><h3 id="9-1-方法基础"><a href="#9-1-方法基础" class="headerlink" title="9.1 方法基础"></a>9.1 方法基础</h3><p><strong>方法（method）</strong> 与函数类似，但有以下特点：</p><ul><li>定义在 <code>impl</code> 块中</li><li>第一个参数必须是 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code></li><li>通过实例调用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;self: 借用实例，不获取所有权</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;mut self: 可变借用，可以修改实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set_width</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, width: <span class="type">u32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self: 获取所有权，方法调用后实例不可再用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">destroy</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;销毁矩形 &#123;&#125;x&#123;&#125;&quot;</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带其他参数的方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;面积: &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    rect1.<span class="title function_ invoke__">set_width</span>(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">20</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 能容纳 rect2: &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-关联函数（Associated-Functions）"><a href="#9-2-关联函数（Associated-Functions）" class="headerlink" title="9.2 关联函数（Associated Functions）"></a>9.2 关联函数（Associated Functions）</h3><p>关联函数不以 <code>self</code> 作为第一个参数，通常用作构造器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数，通常用作构造器</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建正方形的便捷函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">new</span>(<span class="number">10</span>, <span class="number">20</span>);      <span class="comment">// 使用 :: 语法调用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-多个-impl-块"><a href="#9-3-多个-impl-块" class="headerlink" title="9.3 多个 impl 块"></a>9.3 多个 impl 块</h3><p>一个结构体可以有多个 <code>impl</code> 块，这在组织代码或条件编译时很有用。：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">perimeter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="number">2</span> * (<span class="keyword">self</span>.width + <span class="keyword">self</span>.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构体是 Rust 中组织相关数据的强大工具。通过合理使用结构体，我们可以：</p><ol><li><strong>清晰地组织数据</strong>：通过命名字段让代码更易读</li><li><strong>确保类型安全</strong>：不同的结构体是不同的类型</li><li><strong>封装行为</strong>：通过方法将数据和操作结合在一起</li><li><strong>利用所有权系统</strong>：确保内存安全和并发安全</li></ol><p>掌握结构体的使用是学好 Rust 的重要一步，它为后续学习 trait、泛型等高级特性奠定了基础。</p><p><strong>Hooray！结构体学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 所有权</title>
      <link href="/2025/09/23/rust-ownership/"/>
      <url>/2025/09/23/rust-ownership/</url>
      
        <content type="html"><![CDATA[<p>Rust 最独特的特性之一就是 <strong>所有权（Ownership）</strong>，它让 Rust 在没有垃圾回收器（GC）的情况下仍能保证内存安全。理解所有权的工作原理非常重要。</p><h2 id="1-所有权的基本概念"><a href="#1-所有权的基本概念" class="headerlink" title="1. 所有权的基本概念"></a>1. 所有权的基本概念</h2><p>所有权是一组规则，用来控制 Rust 如何管理内存。所有程序都需要管理运行时如何使用内存。常见的几种方式：</p><ul><li><strong>垃圾回收（GC）</strong>：例如 Java、Go，自动跟踪和清理不再使用的内存。</li><li><strong>手动管理</strong>：例如 C++，程序员必须显式分配和释放内存。</li><li><strong>所有权机制</strong>：Rust 使用所有权系统，在编译期检查规则，不影响运行时性能。</li></ul><h3 id="所有权规则（简要）"><a href="#所有权规则（简要）" class="headerlink" title="所有权规则（简要）"></a>所有权规则（简要）</h3><ol><li>每个值都有一个所有者（owner）。</li><li>对于不实现 <code>Copy</code> 的类型（如 <code>String</code>），同一时间只能有一个所有者（即移动语义）。</li><li>当所有者离开作用域时，值会被自动丢弃，内存释放。</li></ol><p><strong>注意</strong>：对于实现了 <code>Copy</code> trait 的简单类型（如整型、浮点、布尔、字符，以及不含堆数据的元组），赋值会复制 <code>Copy</code>，而不是 <code>Move</code>。</p><hr><h2 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2. 变量的作用域"></a>2. 变量的作用域</h2><p>变量的生命周期与作用域相关：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;                      <span class="comment">// s 在此处无效，还未声明</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s 从这里开始有效</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 s</span></span><br><span class="line">    &#125;                      <span class="comment">// 作用域结束，s 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-String-类型"><a href="#3-String-类型" class="headerlink" title="3. String 类型"></a>3. String 类型</h2><p>字符串字面量（如 <code>&quot;hello&quot;</code>）被硬编码到程序中，<strong>不可变</strong>。如果需要可变或运行时获取的字符串，可以使用 <code>String</code>，它在堆上分配内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// 在 String 后追加文本</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// 输出 &quot;hello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-内存与分配"><a href="#4-内存与分配" class="headerlink" title="4. 内存与分配"></a>4. 内存与分配</h2><p><code>String</code> 的工作流程：</p><ol><li>在调用 <code>String::from</code> 或其它分配时，向堆请求内存。</li><li>当变量超出作用域时，Rust 自动调用 <code>drop</code>，释放该内存。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 有效</span></span><br><span class="line">    &#125; <span class="comment">// s 超出作用域，自动调用 drop，内存释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Move-与-Clone"><a href="#5-Move-与-Clone" class="headerlink" title="5. Move 与 Clone"></a>5. Move 与 Clone</h2><h3 id="Move（移动语义）"><a href="#Move（移动语义）" class="headerlink" title="Move（移动语义）"></a>Move（移动语义）</h3><p>对于不实现 <code>Copy</code> 的类型，赋值或传参会发生 <strong>move</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 的所有权被移到 s2，s1 不再有效</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;s1&#125;&quot;); // 编译错误：s1 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计是为了防止出现 <strong>二次释放（double free）</strong> 的安全问题（两个变量同时指向同一堆内存，且各自尝试释放）。</p><h3 id="Clone（深拷贝）"><a href="#Clone（深拷贝）" class="headerlink" title="Clone（深拷贝）"></a>Clone（深拷贝）</h3><p>如果需要真正复制堆上的数据，使用 <code>clone()</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 深拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Copy（栈上数据的自动复制）"><a href="#Copy（栈上数据的自动复制）" class="headerlink" title="Copy（栈上数据的自动复制）"></a>Copy（栈上数据的自动复制）</h3><p>实现了 <code>Copy</code> 的类型在赋值时会按位复制（不会发生 Move），例如：整数、浮点、布尔、字符，以及不包含堆数据的元组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">// x 被 Copy，所以仍然可用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;, y = &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数传值与返回值"><a href="#6-函数传值与返回值" class="headerlink" title="6. 函数传值与返回值"></a>6. 函数传值与返回值</h2><h3 id="传参时的所有权行为"><a href="#传参时的所有权行为" class="headerlink" title="传参时的所有权行为"></a>传参时的所有权行为</h3><p>将值传给函数时也会发生 Move 或 Copy：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值被 move 到函数，s 在这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域（i32 实现了 Copy）</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 被 Copy，依然可用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入函数作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// some_string 离开作用域，drop 被调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// some_integer 离开作用域，无需特殊处理</span></span><br></pre></td></tr></table></figure><p>如果你在 <code>takes_ownership(s);</code> 之后再使用 <code>s</code>，会编译错误，因为 s 的所有权已被移动。</p><h3 id="返回值也会移动所有权"><a href="#返回值也会移动所有权" class="headerlink" title="返回值也会移动所有权"></a>返回值也会移动所有权</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 返回一个 String，所有权转给 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被 move 到函数里，函数再返回所有权给 s3</span></span><br><span class="line">&#125; <span class="comment">// s3 被 drop，s2 已被 move，不再有效，s1 被 drop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>);</span><br><span class="line">    some_string <span class="comment">// 返回所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    a_string <span class="comment">// 返回所有权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果不想在函数间频繁移动所有权，通常可以使用引用（借用）。</p><hr><h2 id="7-引用与借用（References-Borrowing）"><a href="#7-引用与借用（References-Borrowing）" class="headerlink" title="7. 引用与借用（References &amp; Borrowing）"></a>7. 引用与借用（References &amp; Borrowing）</h2><p>引用是指向数据的指针，但<strong>不拥有</strong>数据：</p><h3 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1); <span class="comment">// 将 s1 的不可变借用传入函数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// s 是引用，不会影响所有权，也不会在此处释放 s1</span></span><br></pre></td></tr></table></figure><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>默认引用是不可变的。若要修改被借用的数据，使用可变引用 <code>&amp;mut</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可变引用的限制</strong>：在任一给定时间，对某个值<strong>最多只能有一个可变引用</strong>。这避免了并发写入导致的数据竞争。数据竞争会被以下三种行为触发：</p><ul><li><p>两个或多个指针同时访问同一块内存。</p></li><li><p>至少有一个指针正在写入数据。</p></li><li><p>访问没有任何同步机制保护。</p></li></ul><p><strong>错误示例：多个可变引用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure><p><strong>通过作用域解决</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 离开作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ✅ 可以</span></span><br></pre></td></tr></table></figure><p><strong>不可变引用与可变引用不能同时存在</strong>：如果有不可变引用仍在使用，则不能创建可变引用；但如果不可变引用的作用域结束且不再使用，就可以随后创建可变引用。</p><p>示例如下：</p><p><strong>可变引用与不可变引用冲突</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure><p><strong>合理利用作用域</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>); <span class="comment">// r1 和 r2 的使用在这里结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 现在可以创建可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-悬垂引用（Dangling-References）"><a href="#8-悬垂引用（Dangling-References）" class="headerlink" title="8. 悬垂引用（Dangling References）"></a>8. 悬垂引用（Dangling References）</h2><p>悬垂引用是指引用指向的值已被释放，但引用仍被使用。Rust 的所有权系统和借用规则在编译期防止了悬垂引用。</p><p><strong>错误示例（编译失败）</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// ❌ 返回引用到一个局部变量，s 离开作用域后被 drop，引用悬空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：返回值的所有权（而不是引用），或确保引用指向的值在调用者作用域内保持有效：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s <span class="comment">// 返回所有权，安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-切片（Slice）"><a href="#9-切片（Slice）" class="headerlink" title="9. 切片（Slice）"></a>9. 切片（Slice）</h2><p>切片是对集合（如字符串、数组）中连续元素的引用，<strong>不取得所有权</strong>。</p><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;hello&#125;, &#123;world&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写与尾部省略：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice1</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice2</span> = &amp;s[..<span class="number">2</span>];   <span class="comment">// 等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice3</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice4</span> = &amp;s[<span class="number">3</span>..];   <span class="comment">// 等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">all2</span> = &amp;s[..];      <span class="comment">// 等效</span></span><br></pre></td></tr></table></figure><h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>所有权是 Rust 的核心机制，用以在<strong>编译期</strong>保证内存安全。</li><li>了解 <code>Move</code>、<code>Clone</code>、<code>Copy</code> 的区别有助于写出高效且无内存错误的代码。</li><li>引用（借用）允许临时使用数据而不转移所有权，且借用规则在编译期防止数据竞争和悬垂引用。</li><li>切片提供对集合部分的安全引用，不会取得所有权。</li></ul><p><strong>Hooray！所有权学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 流程控制</title>
      <link href="/2025/09/22/rust-control-flows/"/>
      <url>/2025/09/22/rust-control-flows/</url>
      
        <content type="html"><![CDATA[<h2 id="1-条件分支"><a href="#1-条件分支" class="headerlink" title="1. 条件分支"></a>1. 条件分支</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><ul><li>Rust 不会像 Ruby、JavaScript 等语言一样自动将非布尔值转换为布尔值。</li><li><strong>条件必须是布尔类型</strong>，否则会编译错误。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 这段代码会编译报错，因为整数 3 不能当作布尔值</span></span><br><span class="line">    <span class="keyword">if</span> number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number was three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if</code> 是一个 <strong>表达式</strong>（Expression），有返回值，可以赋值给变量。</li><li>注意：所有分支必须返回 <strong>同一类型</strong> 的值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if 表达式的结果赋值给 number</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="else-if-表达式"><a href="#else-if-表达式" class="headerlink" title="else if 表达式"></a>else if 表达式</h3><ul><li>Rust 会依次检查 <code>if</code> 条件，执行第一个为 <code>true</code> 的分支。</li><li>一旦匹配成功，后续的条件不会再检查。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 如果 <code>else if</code> 太多，代码会变得复杂，此时可以用 <strong>模式匹配（Pattern Matching）</strong> 来简化。</p><hr><h2 id="2-循环控制"><a href="#2-循环控制" class="headerlink" title="2. 循环控制"></a>2. 循环控制</h2><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><ul><li><code>loop</code> 关键字表示无限循环，除非遇到 <code>break</code> 才会停止。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>break</code> 后面可以带返回值，作为 <code>loop</code> 表达式的结果。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>循环标签</strong>：用于在多层循环中跳出外层循环。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出当前循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>; <span class="comment">// 跳出外层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><ul><li><code>while</code> 更适合用在基于条件判断的循环。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>while</code> 遍历数组：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 缺点：数组大小若更改，可能导致 <strong>数组越界</strong>。</p><hr><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><ul><li><code>for</code> 更简洁、安全，不会发生数组越界。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hooray！流程控制学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 数据类型和函数</title>
      <link href="/2025/09/21/rust-datatype-and-functions/"/>
      <url>/2025/09/21/rust-datatype-and-functions/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型（Data-Type）"><a href="#数据类型（Data-Type）" class="headerlink" title="数据类型（Data Type）"></a>数据类型（Data Type）</h2><p>Rust 是一门静态编译语言，必须在编译时知道所有变量的类型，所以声明时需要标注数据类型。</p><h3 id="1-标量类型（Scalar-Type）"><a href="#1-标量类型（Scalar-Type）" class="headerlink" title="1. 标量类型（Scalar Type）"></a>1. 标量类型（Scalar Type）</h3><p>Rust 有四种主要标量类型：整数、浮点数、布尔值和字符。</p><h4 id="1-1-整数类型（Integer）"><a href="#1-1-整数类型（Integer）" class="headerlink" title="1.1 整数类型（Integer）"></a>1.1 整数类型（Integer）</h4><table><thead><tr><th>Length</th><th>Signed (有符号类型)</th><th>Unsigned (无符号类型)</th></tr></thead><tbody><tr><td>8-bit</td><td>i8 (-128 to 127)</td><td>u8 (0 to 255)</td></tr><tr><td>16-bit</td><td>i16 (-32,768 to 32,767)</td><td>u16 (0 to 65,535)</td></tr><tr><td>32-bit</td><td>i32 (-2^31 to 2^31-1)</td><td>u32 (0 to 2^32-1)</td></tr><tr><td>64-bit</td><td>i64 (-2^63 to 2^63-1)</td><td>u64 (0 to 2^64-1)</td></tr><tr><td>128-bit</td><td>i128 (-2^127 to 2^127-1)</td><td>u128 (0 to 2^128-1)</td></tr><tr><td>arch（依架构而定）</td><td>isize</td><td>usize</td></tr></tbody></table><ul><li><code>isize</code> 和 <code>usize</code> 的大小取决于运行程序的计算机架构：<ul><li>64 位系统 → 64 位</li><li>32 位系统 → 32 位</li></ul></li></ul><p>⚠️ 注意：如果声明变量的值超过数据类型的范围会导致 <strong>整数溢出（Integer Overflow）</strong>。</p><h4 id="1-2-浮点数类型（Floating-Point-Type）"><a href="#1-2-浮点数类型（Floating-Point-Type）" class="headerlink" title="1.2 浮点数类型（Floating-Point Type）"></a>1.2 浮点数类型（Floating-Point Type）</h4><p>Rust 中浮点数类型有两种：<code>f32</code> 和 <code>f64</code>。默认是 <code>f64</code>。</p><p>在现代 CPU 上，<code>f64</code> 的速度和 <code>f32</code> 基本相同，但精度更高。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>;      <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-布尔类型（Boolean-Type）"><a href="#1-3-布尔类型（Boolean-Type）" class="headerlink" title="1.3 布尔类型（Boolean Type）"></a>1.3 布尔类型（Boolean Type）</h4><p>布尔值有两个可能的值：<code>true</code> 和 <code>false</code>，大小为 1 个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// 显式类型标注</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;就这样吧&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-字符类型（Char-Type）"><a href="#1-4-字符类型（Char-Type）" class="headerlink" title="1.4 字符类型（Char Type）"></a>1.4 字符类型（Char Type）</h4><ul><li>Rust 中用 <code>&#39;&#39;</code> 来指定 <code>char</code> 类型的字符</li><li>用 <code>&quot;&quot;</code> 来指定字符串 <code>string</code></li><li><code>char</code> 占用 <strong>4 个字节</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-复合类型（Compound-Type）"><a href="#2-复合类型（Compound-Type）" class="headerlink" title="2. 复合类型（Compound Type）"></a>2. 复合类型（Compound Type）</h3><p>Rust 有两种复合类型：<strong>元组（Tuple）</strong> 和 <strong>数组（Array）</strong>。</p><h4 id="2-1-元组（Tuple-Type）"><a href="#2-1-元组（Tuple-Type）" class="headerlink" title="2.1 元组（Tuple Type）"></a>2.1 元组（Tuple Type）</h4><ul><li>元组可以存放不同类型的值</li><li>长度固定，声明后不可改变</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取元组的值有两种方式：</p><ul><li><p><strong>解构（Destructuring）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>索引（Index）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = tup.<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>⚠️ 没有任何值的元组叫 <strong>unit 类型</strong>，写作 <code>()</code>。</p><hr><h4 id="2-2-数组（Array-Type）"><a href="#2-2-数组（Array-Type）" class="headerlink" title="2.2 数组（Array Type）"></a>2.2 数组（Array Type）</h4><ul><li>所有元素必须是相同类型</li><li>长度固定，存放在 <strong>栈</strong> 上</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 中的数组具有固定长度，这点与其它语言不同，其它编程语言中数组是可变长度，与 Rust 中的 vector 类似。当你想将数据分配在栈上而不是堆或者你想确保始终有固定数量的元素时，数组非常有用，比如一年的月数是固定的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">months</span> = [</span><br><span class="line">    <span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>,</span><br><span class="line">    <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>指定数组类型与长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>指定初始值和长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// 等同于 [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure><p>数组是连续存放在栈上的有序结构，可以通过索引访问。Rust 的索引下标从 <strong>0</strong> 开始。</p><ul><li><p>访问数组元素</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];  <span class="comment">// 访问数组中第一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>]; <span class="comment">// 访问数组中第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组下标越界</p><p>如果下标不在 <code>[0, Length-1]</code> 范围内：</p><ul><li>编译阶段：直接报 <strong>panic</strong> 警告</li><li>运行阶段：无法提前知道输入，越界时会 <strong>立即终止程序</strong>，而不是访问无效内存</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of the element at index &#123;index&#125; is: &#123;element&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ Rust 的安全特性：<strong>遇到越界立刻退出</strong>，避免无效内存访问。</p><hr><h2 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h2><p>函数由以下部分构成：</p><ul><li><code>fn</code> 关键字</li><li>函数名 <code>add</code></li><li>参数 <code>x, y</code> 和参数类型 <code>i32</code></li><li>函数体 <code>x + y</code></li><li>返回值类型 <code>i32</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><ul><li><p><strong>语句（Statements）</strong>：执行操作，但不返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ❌ 错误写法</span></span><br><span class="line">    <span class="comment">// 因为 let y = 6 是语句，没有返回值</span></span><br><span class="line">    <span class="comment">// 这是 Rust 的一个特性，如果是 C 或 Ruby，赋值操作会返回被赋的值 6</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>表达式（Expression）</strong>：计算并返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span>   <span class="comment">// 没有分号，表示表达式</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Hooray！数据类型和函数学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— 变量和可变性</title>
      <link href="/2025/09/20/rust-variables-and-mutability/"/>
      <url>/2025/09/20/rust-variables-and-mutability/</url>
      
        <content type="html"><![CDATA[<h2 id="1-可变与不可变变量"><a href="#1-可变与不可变变量" class="headerlink" title="1. 可变与不可变变量"></a>1. 可变与不可变变量</h2><ul><li><strong>不可变变量（Immutable）</strong>：Rust 中变量默认不可变，一旦绑定后值不能改变。</li><li><strong>可变变量（Mutable）</strong>：使用 <code>mut</code> 关键字，可以让变量的值在绑定后发生改变。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>; <span class="comment">// ✅ 可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// y = 11; // ❌ 错误：不可修改</span></span><br></pre></td></tr></table></figure><h2 id="2-常量（Constants）"><a href="#2-常量（Constants）" class="headerlink" title="2. 常量（Constants）"></a>2. 常量（Constants）</h2><ul><li>使用 <code>const</code> 关键字声明，始终不可变</li><li>常量名全部大写，单词之间用下划线分隔</li><li>常量必须在编译期已知，并且类型必须显式标注</li><li>与变量不同，常量不能用 <code>mut</code> 声明</li><li>常量可以在任意作用域定义，包括全局作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="3-遮蔽（Shadowing）"><a href="#3-遮蔽（Shadowing）" class="headerlink" title="3. 遮蔽（Shadowing）"></a>3. 遮蔽（Shadowing）</h2><p>使用 <code>let</code> 重复声明同名变量时，新变量会 <strong>遮蔽</strong> 旧变量。</p><ul><li><strong>在同一作用域内</strong>：旧绑定被完全隐藏，无法访问</li><li><strong>跨作用域时</strong>：内层遮蔽外层，内层作用域结束后外层绑定重新可见</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;  <span class="comment">// 新的 x 遮蔽旧的 x=5</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;  <span class="comment">// 仅在当前作用域生效，不会遮蔽前面的x = x + 1</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);<span class="comment">// 输出 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);<span class="comment">// 输出 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与 <code>mut</code> 的区别<ul><li><strong><code>mut</code></strong>：修改同一个变量的值。</li><li><strong>遮蔽</strong>：创建一个新的变量绑定，旧的绑定被隐藏，而且可以改变类型。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 mut：错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="comment">// spaces = spaces.len(); // ❌ 类型不匹配，&amp;str 不能赋值为 usize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用遮蔽：正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>(); <span class="comment">// ✅ 类型从 &amp;str → usize</span></span><br></pre></td></tr></table></figure><p><strong>Hooray！变量和可变性学习完成！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust —— Hello, World!</title>
      <link href="/2025/09/19/rust-hello-world/"/>
      <url>/2025/09/19/rust-hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p><strong>Rust</strong>是一门静态编译的语言，强调<strong>性能</strong>、<strong>类型安全</strong>、<strong>并发性</strong>。</p><h2 id="1-安装-Rust"><a href="#1-安装-Rust" class="headerlink" title="1. 安装 Rust"></a>1. 安装 Rust</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rust 安装</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载环境变量</span></span><br><span class="line">. <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">rustc --version</span><br></pre></td></tr></table></figure><p><strong>其他常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rust 更新</span></span><br><span class="line">rustup update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rust 卸载</span></span><br><span class="line">rustup self uninstall</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rust 离线文档</span></span><br><span class="line">rustup doc</span><br></pre></td></tr></table></figure><h2 id="2-VS-Code-插件拓展"><a href="#2-VS-Code-插件拓展" class="headerlink" title="2. VS Code 插件拓展"></a>2. VS Code 插件拓展</h2><ul><li><strong>rust-analyzer</strong> —— 代码补全与分析</li><li><strong>Dependi</strong> —— Cargo.toml 依赖管理助手</li><li><strong>Even Better TOML</strong> —— TOML 高亮与校验</li><li><strong>CodeLLDB</strong> —— Rust Debugger</li></ul><h2 id="3-Hello，World"><a href="#3-Hello，World" class="headerlink" title="3. Hello，World"></a>3. Hello，World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目目录</span></span><br><span class="line"><span class="built_in">mkdir</span> hello_world</span><br><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 main.rs</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./main.rs &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">rustc main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p><strong>执行后 Hello, world! 字符串应打印到终端</strong><br><img src="/images/Rust/hello-world.png"></p><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p>编译时报错 <code>linker &#39;cc&#39; not found</code>，说明系统缺少编译工具，安装即可：</p><p><img src="/images/Rust/linker-cc-err.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件包索引</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装构建工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential -y</span><br></pre></td></tr></table></figure><h2 id="4-Hello-Cargo"><a href="#4-Hello-Cargo" class="headerlink" title="4. Hello, Cargo"></a>4. Hello, Cargo</h2><p><strong>Cargo</strong> 是 Rust 的官方构建工具和包管理器，提供 <strong>项目管理、依赖管理、编译、测试</strong> 等功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化项目</span></span><br><span class="line">cargo new hello_cargo</span><br><span class="line"><span class="built_in">cd</span> hello_cargo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 src/main.rs</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ./src/main.rs &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println!(<span class="string">&quot;Hello, cargo!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建并运行（等价于 cargo build + 执行）</span></span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><p><strong>其他常用命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debug 构建</span></span><br><span class="line">cargo build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Release 构建</span></span><br><span class="line">cargo build —release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Cargo 版本</span></span><br><span class="line">cargo --version</span><br></pre></td></tr></table></figure><p><strong>Hooray! Rust 学习之旅，正式启程！！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Op Stack 组件日志管理</title>
      <link href="/2025/09/18/log-mgmt-part4/"/>
      <url>/2025/09/18/log-mgmt-part4/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Layer 2 节点的各项组件（如 <code>op-geth</code>、<code>op-node</code>、<code>op-batcher</code>、<code>op-proposer</code>）在运行过程中会产生大量日志数据。如果缺乏有效的日志管理策略，这些日志文件会持续增长，最终可能导致：</p><ul><li><strong>磁盘空间耗尽</strong>：影响节点正常运行，甚至导致服务中断</li><li><strong>查询效率低下</strong>：巨大的日志文件难以进行快速的问题定位和分析</li><li><strong>系统性能下降</strong>：持续的写操作会增加磁盘 I&#x2F;O 压力</li></ul><p>因此，选择一套稳定、高效的日志管理方案至关重要。</p><h2 id="一、传统-Logrotate-管理"><a href="#一、传统-Logrotate-管理" class="headerlink" title="一、传统 Logrotate 管理"></a>一、传统 Logrotate 管理</h2><h3 id="1-什么是-Logrotate？"><a href="#1-什么是-Logrotate？" class="headerlink" title="1. 什么是 Logrotate？"></a>1. 什么是 Logrotate？</h3><p><code>logrotate</code> 是 Linux 系统的经典日志管理工具，通过 cron 定时任务（通常每日执行）对日志文件进行轮转、压缩和清理，有效控制日志文件大小。</p><h3 id="2-Postrotate-服务重启方案"><a href="#2-Postrotate-服务重启方案" class="headerlink" title="2. Postrotate 服务重启方案"></a>2. Postrotate 服务重启方案</h3><p>这种方案在日志轮转后重启相关服务，确保服务能够正确处理新的日志文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/logrotate.d/layer2-services</span></span><br><span class="line">/home/eth/optimism/logs/*/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 30</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    create 644 root root</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    postrotate</span><br><span class="line">        systemctl reload-or-restart op-geth op-node op-batcher op-proposer &gt;/dev/null 2&gt;&amp;1 || <span class="literal">true</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优缺点分析</strong><ul><li><strong>优点</strong>：确保日志完整性，无数据丢失风险</li><li><strong>缺点</strong>：服务重启会触发区块重扫，严重影响同步效率，并可能导致新区块生成时间滞后</li></ul></li></ul><h3 id="3-copytruncate-复制并清空"><a href="#3-copytruncate-复制并清空" class="headerlink" title="3. copytruncate 复制并清空"></a>3. copytruncate 复制并清空</h3><p>此方案通过复制当前日志内容后清空原文件的方式，服务进程毫无感知，避免服务重启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/logrotate.d/layer2-services</span></span><br><span class="line">/home/eth/optimism/logs/*/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 30</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y-%m-%d</span><br><span class="line">    copytruncate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>优缺点分析</strong><ul><li><strong>优点</strong>：无需服务重启，保证连续性</li><li><strong>缺点</strong>：在复制和截断操作的毫秒级窗口期内可能丢失少量日志，并且会产生额外的磁盘 I&#x2F;O 开销。</li></ul></li></ul><h3 id="4-测试与验证"><a href="#4-测试与验证" class="headerlink" title="4. 测试与验证"></a>4. 测试与验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预览轮转效果（不实际执行）</span></span><br><span class="line"><span class="built_in">sudo</span> logrotate -d /etc/logrotate.d/layer2-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制执行一次轮转</span></span><br><span class="line"><span class="built_in">sudo</span> logrotate -f /etc/logrotate.d/layer2-services</span><br></pre></td></tr></table></figure><h2 id="二、现代化-Journald-管理"><a href="#二、现代化-Journald-管理" class="headerlink" title="二、现代化 Journald 管理"></a>二、现代化 Journald 管理</h2><h3 id="1-什么是-Journald"><a href="#1-什么是-Journald" class="headerlink" title="1. 什么是 Journald"></a>1. 什么是 Journald</h3><p><code>journald</code> 是 systemd 生态的原生日志管理服务，它将日志作为结构化的事件流处理，并由其自身负责存储、轮转和清理，可以避免服务中断和数据丢失。</p><h3 id="2-迁移步骤"><a href="#2-迁移步骤" class="headerlink" title="2. 迁移步骤"></a>2. 迁移步骤</h3><h4 id="2-1-修改-Systemd-Service-文件"><a href="#2-1-修改-Systemd-Service-文件" class="headerlink" title="2.1 修改 Systemd Service 文件"></a>2.1 修改 Systemd Service 文件</h4><p>迁移的核心是移除强制将日志输出到文件的配置，让日志流回归 <code>systemd</code> 的默认通道——<code>journald</code>。</p><p>以 <strong><code>op-geth.service</code></strong> 为例，需移除 <code>StandardOutput</code> 和 <code>StandardError</code>配置。</p><ul><li><strong>需移除的配置</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-geth/geth.log</span><br></pre></td></tr></table></figure><ul><li><strong>修改后的 <code>op-geth.service</code> 示例</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=OP-Geth Execution Client</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-geth_starter.sh</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="2-2-简化启动脚本"><a href="#2-2-简化启动脚本" class="headerlink" title="2.2 简化启动脚本"></a>2.2 简化启动脚本</h4><p>由于不再需要管理日志文件，可以移除相关的目录创建逻辑。</p><ul><li><strong>需移除的配置</strong>:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-geth&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br></pre></td></tr></table></figure><ul><li><strong>修改后的 <code>op-geth_starter.sh</code> 示例:</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting Geth node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：同样的修改需要应用到 <code>op-node</code>、<code>op-batcher</code>、<code>op-proposer</code> 等所有相关服务的 <code>.service</code> 文件和启动脚本中。</p><h4 id="2-3-清理旧配置并应用更改"><a href="#2-3-清理旧配置并应用更改" class="headerlink" title="2.3 清理旧配置并应用更改"></a>2.3 清理旧配置并应用更改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除旧的 logrotate 配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -f /etc/logrotate.d/layer2-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 systemd 配置</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务以应用更改</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h4 id="2-4-配置-Journald-存储限制"><a href="#2-4-配置-Journald-存储限制" class="headerlink" title="2.4 配置 Journald 存储限制"></a>2.4 配置 Journald 存储限制</h4><p>为防止日志无限增长，需要设置合理的存储上限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/journald.conf</span><br></pre></td></tr></table></figure><p>在 <code>[Journal]</code> 部分添加或修改：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Journal]</span></span><br><span class="line"><span class="attr">SystemMaxUse</span>=<span class="number">10</span>G</span><br></pre></td></tr></table></figure><ul><li><strong><code>SystemMaxUse=10G</code></strong>: 设置 journald 可使用的最大磁盘空间为 10GB。可以根据服务器磁盘大小调整此值（如 <code>5G</code>, <code>20G</code>）。</li></ul><p>保存文件后，重启 <code>journald</code> 服务使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-journald</span><br></pre></td></tr></table></figure><p>配置生效后，当日志总量将要超过设置的阈值时，<code>journald</code> 就会自动、静默地删除最旧的日志文件，为新日志腾出空间，确保日志大小始终保持在限制范围内。</p><p><strong>Hooray！Journald 配置成功！！！</strong></p><h2 id="三、日志管理常用命令"><a href="#三、日志管理常用命令" class="headerlink" title="三、日志管理常用命令"></a>三、日志管理常用命令</h2><p><strong>提示</strong>：在终端直接查看时，可以去掉 <code>--no-pager</code> 参数，以使用 <code>less</code> 分页器方便地上下滚动和搜索。导出文件时则需要加上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 op-geth 服务的实时日志</span></span><br><span class="line">journalctl -u op-geth.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看 op-geth 和 op-node 两个服务的混合日志</span></span><br><span class="line">journalctl -u op-geth.service -u op-node.service -f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 op-geth 过去两小时的日志</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;2 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 op-node 今天的所有日志</span></span><br><span class="line">journalctl -u op-node.service --since <span class="string">&quot;today&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定时间段的日志 (示例日期: 2025-09-19)</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;2025-09-19 15:00:00&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2025-09-19 17:00:00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出 op-geth 昨日的全部日志到根目录</span></span><br><span class="line">journalctl -u op-geth.service --since <span class="string">&quot;yesterday&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;today&quot;</span> --no-pager &gt; ~/op-geth_yesterday.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前 journald 日志占用空间</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 journald 当前的磁盘限额配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/systemd/journald.conf | grep SystemMaxUse</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 <code>Layer2</code> 节点这样需要高可用性和连续运行的关键服务，现代化的 <code>Journald</code> 管理方案显然更具优势，原因如下：</p><ul><li><strong>零服务中断</strong>：避免了 Logrotate 重启服务导致的区块重扫问题</li><li><strong>原生集成</strong>：与 Systemd 生态深度整合，管理更加统一</li><li><strong>结构化存储</strong>：支持更丰富的查询和过滤功能</li><li><strong>简化运维</strong>：无需复杂的轮转脚本，配置简单维护方便</li></ul><p>良好的日志管理是保障节点稳定运行、快速排查问题的基石，选择合适的方案能让维护工作事半功倍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> Journald </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Systemd 自动化管理 OP Stack 组件</title>
      <link href="/2025/09/17/systemd-auto-mgmt-part3/"/>
      <url>/2025/09/17/systemd-auto-mgmt-part3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在部署和运行 Optimism 的过程中，手动启动各个组件既繁琐又容易出错。本文将详细介绍如何使用 systemd 服务来自动化管理 OP Stack 的各个核心组件，包括 op-geth、op-node、op-batcher 和 op-proposer。</p><p>⚠️<strong>本文中的路径 <code>/home/eth/optimism/</code> 仅作示例，使用前请根据自己的部署目录修改</strong></p><h2 id="一、Why-Systemd？"><a href="#一、Why-Systemd？" class="headerlink" title="一、Why Systemd？"></a>一、Why Systemd？</h2><p>Systemd 是现代 Linux 发行版的标准初始化系统和服务管理器，它提供了以下优势：</p><ul><li><strong>自动重启</strong>：当服务异常退出时自动重启</li><li><strong>依赖管理</strong>：确保服务按正确顺序启动</li><li><strong>日志管理</strong>：集中管理服务日志</li><li><strong>开机自启</strong>：系统重启后自动启动服务</li></ul><h2 id="二、启动脚本"><a href="#二、启动脚本" class="headerlink" title="二、启动脚本"></a>二、启动脚本</h2><h3 id="2-1-创建脚本目录"><a href="#2-1-创建脚本目录" class="headerlink" title="2.1 创建脚本目录"></a>2.1 创建脚本目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/</span><br><span class="line"><span class="built_in">mkdir</span> -p scripts</span><br><span class="line"><span class="built_in">cd</span> scripts/</span><br></pre></td></tr></table></figure><h3 id="2-2-创建启动脚本"><a href="#2-2-创建启动脚本" class="headerlink" title="2.2 创建启动脚本"></a>2.2 创建启动脚本</h3><h4 id="OP-Geth-启动脚本"><a href="#OP-Geth-启动脚本" class="headerlink" title="OP-Geth 启动脚本"></a>OP-Geth 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-geth_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-geth&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting Geth node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Node-启动脚本"><a href="#OP-Node-启动脚本" class="headerlink" title="OP-Node 启动脚本"></a>OP-Node 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-node_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-node&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Node at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-node</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-node \</span><br><span class="line">        --l2=http://localhost:8551 \</span><br><span class="line">        --l2.jwt-secret=./jwt.txt \</span><br><span class="line">        --sequencer.enabled \</span><br><span class="line">        --sequencer.l1-confs=5 \</span><br><span class="line">        --verifier.l1-confs=4 \</span><br><span class="line">        --rollup.config=../.deployer/rollup.json \</span><br><span class="line">        --rpc.addr=0.0.0.0 \</span><br><span class="line">        --rpc.port=9545 \</span><br><span class="line">        --p2p.disable \</span><br><span class="line">        --rpc.enable-admin \</span><br><span class="line">        --p2p.sequencer.key=<span class="variable">$GS_SEQUENCER_PRIVATE_KEY</span> \</span><br><span class="line">        --l1=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">        --l1.rpckind=<span class="variable">$L1_RPC_KIND</span> \</span><br><span class="line">        --l1.beacon=<span class="variable">$L1_BEACON_URL</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Batcher-启动脚本"><a href="#OP-Batcher-启动脚本" class="headerlink" title="OP-Batcher 启动脚本"></a>OP-Batcher 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-batcher_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-batcher&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Batcher at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-batcher</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-batcher \</span><br><span class="line">        --l2-eth-rpc=http://localhost:8545 \</span><br><span class="line">        --rollup-rpc=http://localhost:9545 \</span><br><span class="line">        --poll-interval=1s \</span><br><span class="line">        --sub-safety-margin=6 \</span><br><span class="line">        --num-confirmations=1 \</span><br><span class="line">        --safe-abort-nonce-too-low-count=3 \</span><br><span class="line">        --resubmission-timeout=30s \</span><br><span class="line">        --rpc.addr=0.0.0.0 \</span><br><span class="line">        --rpc.port=8548 \</span><br><span class="line">        --rpc.enable-admin \</span><br><span class="line">        --max-channel-duration=25 \</span><br><span class="line">        --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">        --private-key=<span class="variable">$GS_BATCHER_PRIVATE_KEY</span></span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="OP-Proposer-启动脚本"><a href="#OP-Proposer-启动脚本" class="headerlink" title="OP-Proposer 启动脚本"></a>OP-Proposer 启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-proposer_starter.sh &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">LOG_DIR=<span class="string">&quot;/home/eth/optimism/logs/op-proposer&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$LOG_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting OP-Proposer at <span class="subst">$(date)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/eth/optimism/op-proposer</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /home/eth/optimism/.envrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> ./bin/op-proposer \</span><br><span class="line">    --poll-interval=12s \</span><br><span class="line">    --rpc.port=8560 \</span><br><span class="line">    --rollup-rpc=http://localhost:9545 \</span><br><span class="line">    --private-key=<span class="variable">$GS_PROPOSER_PRIVATE_KEY</span> \</span><br><span class="line">    --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-3-设置脚本权限"><a href="#2-3-设置脚本权限" class="headerlink" title="2.3 设置脚本权限"></a>2.3 设置脚本权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x op-geth_starter.sh op-node_starter.sh op-batcher_starter.sh  op-proposer_starter.sh</span><br></pre></td></tr></table></figure><h3 id="2-4-测试脚本"><a href="#2-4-测试脚本" class="headerlink" title="2.4 测试脚本"></a>2.4 测试脚本</h3><p>此时可以尝试启动一下脚本，检查脚本是否正常工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 L2 节点的 Geth</span></span><br><span class="line">./op-geth_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 OP Node</span></span><br><span class="line">./op-node_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Batcher</span></span><br><span class="line">./op-batcher_starter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Proposer</span></span><br><span class="line">./op-proposer_starter.sh</span><br></pre></td></tr></table></figure><h2 id="三、Systemd-服务文件"><a href="#三、Systemd-服务文件" class="headerlink" title="三、Systemd 服务文件"></a>三、Systemd 服务文件</h2><h3 id="3-1-创建服务文件目录"><a href="#3-1-创建服务文件目录" class="headerlink" title="3.1 创建服务文件目录"></a>3.1 创建服务文件目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/</span><br><span class="line"><span class="built_in">mkdir</span> -p service</span><br><span class="line"><span class="built_in">cd</span> service/</span><br></pre></td></tr></table></figure><h3 id="3-2-创建-Systemd-服务文件"><a href="#3-2-创建-Systemd-服务文件" class="headerlink" title="3.2 创建 Systemd 服务文件"></a>3.2 创建 Systemd 服务文件</h3><h4 id="OP-Geth-服务配置"><a href="#OP-Geth-服务配置" class="headerlink" title="OP-Geth 服务配置"></a>OP-Geth 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-geth.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Geth Execution Client</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-geth_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-geth/geth.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Node-服务配置"><a href="#OP-Node-服务配置" class="headerlink" title="OP-Node 服务配置"></a>OP-Node 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-node.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Node L2 Consensus Client</span><br><span class="line">After=network-online.target op-geth.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-geth.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-node_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-node/op-node.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-node/op-node.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Batcher-服务配置"><a href="#OP-Batcher-服务配置" class="headerlink" title="OP-Batcher 服务配置"></a>OP-Batcher 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ./op-batcher.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Batcher L2 Transaction Batcher</span><br><span class="line">After=network-online.target op-node.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-node.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-batcher_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-batcher/op-batcher.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-batcher/op-batcher.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="OP-Proposer-服务配置"><a href="#OP-Proposer-服务配置" class="headerlink" title="OP-Proposer 服务配置"></a>OP-Proposer 服务配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ./op-proposer.service &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=OP-Proposer L2 State Proposer</span><br><span class="line">After=network-online.target op-node.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=op-node.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/eth/optimism/scripts</span><br><span class="line">ExecStart=/home/eth/optimism/scripts/op-proposer_starter.sh</span><br><span class="line"></span><br><span class="line">StandardOutput=append:/home/eth/optimism/logs/op-proposer/op-proposer.log</span><br><span class="line">StandardError=append:/home/eth/optimism/logs/op-proposer/op-proposer.log</span><br><span class="line"></span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="服务依赖关系说明"><a href="#服务依赖关系说明" class="headerlink" title="服务依赖关系说明"></a>服务依赖关系说明</h4><p>服务启动的依赖顺序如下：</p><ol><li><strong>op-geth</strong>：基础执行客户端，必须首先启动</li><li><strong>op-node</strong>：依赖 op-geth 提供的 Engine API</li><li><strong>op-batcher</strong> 和 <strong>op-proposer</strong>：都依赖 op-node 提供的 Rollup RPC</li></ol><p>通过 <code>After</code> 和 <code>Requires</code> 指令，systemd 会自动处理这些依赖关系。</p><h3 id="3-3-安装服务文件"><a href="#3-3-安装服务文件" class="headerlink" title="3.3 安装服务文件"></a>3.3 安装服务文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符号链接</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -sf /home/eth/optimism/service/*.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载 systemd 配置</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查服务文件语法是否有误</span></span><br><span class="line"><span class="built_in">sudo</span> systemd-analyze verify /etc/systemd/system/<span class="variable">$&#123;service&#125;</span>.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><p><strong>启动成功状态应如下图所示：</strong><br><img src="/images/2025/layer2status.png"></p><p><strong>Hooray！Systemd 配置成功！！！</strong></p><h2 id="五、常见故障排查"><a href="#五、常见故障排查" class="headerlink" title="五、常见故障排查"></a>五、常见故障排查</h2><p><strong>日志管理</strong></p><blockquote><ul><li><p>OP-Geth: <code>/home/eth/optimism/logs/op-geth/geth.log</code></p></li><li><p>OP-Node: <code>/home/eth/optimism/logs/op-node/op-node.log</code></p></li><li><p>OP-Batcher: <code>/home/eth/optimism/logs/op-batcher/op-batcher.log</code></p></li><li><p>OP-Proposer: <code>/home/eth/optimism/logs/op-proposer/op-proposer.log</code></p></li></ul></blockquote><h3 id="5-1-code-exited-status-1-FAILURE"><a href="#5-1-code-exited-status-1-FAILURE" class="headerlink" title="5.1 code&#x3D;exited, status&#x3D;1&#x2F;FAILURE"></a>5.1 code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</h3><p>进入的 logs 的路径通过命令 <code>tail -n 50 YOUR_LOG_NAME</code> 查看服务的最近日志，使用 systemd 执行脚本时不会自动加载环境变量，如果脚本中使用了环境变量但没有正确加载，就会导致找不到相关变量而报错。</p><p><img src="/images/2025/addressnotfound.png"></p><p><strong>解决方案</strong>：确保启动脚本中正确配置环境变量加载语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/optimism/.envrc</span><br></pre></td></tr></table></figure><h3 id="5-2-code-exited-status-209-STDOUT"><a href="#5-2-code-exited-status-209-STDOUT" class="headerlink" title="5.2 code&#x3D;exited, status&#x3D;209&#x2F;STDOUT"></a>5.2 code&#x3D;exited, status&#x3D;209&#x2F;STDOUT</h3><p>通过命令 <code>sudo journalctl -u YOUR_SERVICE_NAME -n 50 --no-pager</code>查看服务的最近日志。服务启动时会检查配置的路径是否可访问或存在，需要检查配置的路径是否存在以及是否具有访问权限。</p><p><strong>排查步骤</strong>：</p><ol><li>检查 <code>WorkingDirectory</code> 路径是否存在</li><li>检查 <code>ExecStart</code> 指向的脚本文件是否存在且有执行权限</li><li>检查日志目录是否可写</li></ol><p><img src="/images/2025/209-stdout.png"></p><h3 id="5-3-其他常用调试命令示例"><a href="#5-3-其他常用调试命令示例" class="headerlink" title="5.3 其他常用调试命令示例"></a>5.3 其他常用调试命令示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看服务实时日志</span></span><br><span class="line"><span class="built_in">sudo</span> journalctl -u op-geth -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行组件实时日志</span></span><br><span class="line"><span class="built_in">tail</span> -f op-geth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop op-geth op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查所有服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl is-active op-geth op-node op-batcher op-proposer</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过使用 systemd 管理 OP Stack 组件，我们实现了：</p><ul><li><strong>自动化管理</strong>：服务自动启动、重启和监控</li><li><strong>依赖管理</strong>：确保服务按正确顺序启动</li><li><strong>日志集中管理</strong>：方便问题排查和监控</li><li><strong>生产环境就绪</strong>：满足生产环境的稳定性要求</li></ul><p>这种配置方式特别适合生产环境部署，能够显著减少手动维护工作量，提高系统的可靠性和稳定性。当遇到问题时，通过查看具体的错误代码和日志，能够快速定位和解决问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> Systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— Blockscout 部署指南</title>
      <link href="/2025/09/16/blockscout-deployment-part2/"/>
      <url>/2025/09/16/blockscout-deployment-part2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本指南详细介绍了如何为搭建的 Layer2 区块链网络部署 Blockscout 区块浏览器。Blockscout 是一个功能全面的开源区块链浏览器，专为以太坊虚拟机（EVM）兼容网络设计。它提供了直观的用户界面来查看交易、区块、合约和账户信息，是区块链项目不可或缺的基础设施组件。</p><h2 id="一、系统环境准备"><a href="#一、系统环境准备" class="headerlink" title="一、系统环境准备"></a>一、系统环境准备</h2><h3 id="1-1-安装软件依赖"><a href="#1-1-安装软件依赖" class="headerlink" title="1.1 安装软件依赖"></a>1.1 安装软件依赖</h3><p>打开 Ubuntu-24.04 子系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y curl wget git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译工具 / 构建</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y build-essential make g++ gcc automake libtool cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统库</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y libudev-dev libgmp-dev libgmp10 libssl-dev libncurses-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩 / 解压</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y zip unzip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y inotify-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 asdf</span></span><br><span class="line">go install github.com/asdf-vm/asdf/cmd/asdf@v0.18.0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/go/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 postgreSQL-17 数据库</span></span><br><span class="line">curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc|<span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/trusted.gpg.d/postgresql.gpg</span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo &quot;deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install postgresql-17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 rust</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 docker-compose</span></span><br><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure><h3 id="1-2-配置-asdf"><a href="#1-2-配置-asdf" class="headerlink" title="1.2 配置 asdf"></a>1.2 配置 asdf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Erlang、Elixir、Node.js 插件</span></span><br><span class="line">asdf plugin add erlang</span><br><span class="line">asdf plugin add elixir</span><br><span class="line">asdf plugin add nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 blockscout backend</span></span><br><span class="line">asdf install erlang 27.3.4</span><br><span class="line">asdf install elixir 1.17.3-otp-27</span><br><span class="line">asdf install nodejs 20.17.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于 blockscout frontend</span></span><br><span class="line">asdf install nodejs 22.11.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 asdf 环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.asdf/shims:<span class="variable">$HOME</span>/.asdf/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="1-3-配置-Postgres-数据库"><a href="#1-3-配置-Postgres-数据库" class="headerlink" title="1.3 配置 Postgres 数据库"></a>1.3 配置 Postgres 数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换数据库管理员</span></span><br><span class="line">su - postgres <span class="comment"># for Root</span></span><br><span class="line"><span class="built_in">sudo</span> -i -u postgres <span class="comment"># for user</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库用户</span></span><br><span class="line">createuser --interactive</span><br><span class="line"><span class="comment"># 输入角色名: YOUR_DBUSER_NAME</span></span><br><span class="line"><span class="comment"># 是否为超级用户? (y/n) y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">createdb blockscout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户密码</span></span><br><span class="line">psql</span><br><span class="line">ALTER USER YOUR_DBUSER_NAME WITH PASSWORD <span class="string">&#x27;YourSecurePassword&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE blockscout TO YOUR_DBUSER_NAME;</span><br><span class="line">\q</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart postgresql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据库设置是否成功</span></span><br><span class="line">su - YOUR_DBUSER_NAME <span class="comment"># for Root</span></span><br><span class="line"><span class="built_in">sudo</span> su - YOUR_DBUSER_NAME <span class="comment"># for user</span></span><br><span class="line">psql -d blockscout<span class="comment"># 如果能看到 blockscout=# 说明成功</span></span><br><span class="line">\q</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 psql 运行状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status postgresql</span><br></pre></td></tr></table></figure><h2 id="二、构建-Blockscout-Backend"><a href="#二、构建-Blockscout-Backend" class="headerlink" title="二、构建 Blockscout Backend"></a>二、构建 Blockscout Backend</h2><h3 id="2-1-克隆-Blockscout-Backend-仓库"><a href="#2-1-克隆-Blockscout-Backend-仓库" class="headerlink" title="2.1 克隆 Blockscout Backend 仓库"></a>2.1 克隆 Blockscout Backend 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 blockscout 工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> -p blockscout</span><br><span class="line"><span class="built_in">cd</span> blockscout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 blockscout backend 并切换到最新 release 分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/blockscout/blockscout.git backend</span><br><span class="line"><span class="built_in">cd</span> backend</span><br><span class="line">git checkout v9.1.0 -b v9.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Mix 依赖并编译</span></span><br><span class="line">mix <span class="keyword">do</span> deps.get, local.rebar --force, deps.compile, compile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据库生成新的 secret_key_base</span></span><br><span class="line">mix phx.gen.secret</span><br></pre></td></tr></table></figure><h3 id="2-2-编辑环境变量文件"><a href="#2-2-编辑环境变量文件" class="headerlink" title="2.2 编辑环境变量文件"></a>2.2 编辑环境变量文件</h3><p>创建 <code>env_vars.env</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano env_vars.env</span><br></pre></td></tr></table></figure><p>填写以下变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATABASE_URL=postgresql://YOUR_DBUSER_NAME:YourSecurePassword@localhost:5432/blockscout</span><br><span class="line"><span class="built_in">export</span> SECRET_KEY_BASE= <span class="comment"># generated by mix phx.gen.secret</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_VARIANT=geth</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_HTTP_URL=http://localhost:8545</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_WS_URL=ws://localhost:8546</span><br><span class="line"><span class="built_in">export</span> ETHEREUM_JSONRPC_TRACE_URL=http://localhost:8545</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> API_V2_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> PORT=4000</span><br><span class="line"><span class="built_in">export</span> MIX_ENV=prod</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CHAIN_ID=L2_CHAIN_ID</span><br><span class="line"><span class="built_in">export</span> L1_RPC=L1_RPC_URL</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> COIN=ETH</span><br><span class="line"><span class="built_in">export</span> COIN_NAME=<span class="string">&quot;Sepolia ETH&quot;</span></span><br><span class="line"><span class="built_in">export</span> COINGECKO_COIN_ID=ethereum</span><br><span class="line"><span class="built_in">export</span> DISPLAY_TOKEN_ICONS=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SC_VERIFIER_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SC_VERIFIER_URL=http://localhost:8082/</span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_VISUALIZE_SOL2UML_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_VISUALIZE_SOL2UML_URL=http://localhost:8081/</span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SIG_PROVIDER_ENABLED=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> MICROSERVICE_SIG_PROVIDER_URL=http://localhost:8083/</span><br></pre></td></tr></table></figure><p>加载环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> env_vars.env</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 postgresql 运行状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status postgresql</span><br><span class="line"><span class="comment"># 创建数据库并迁移</span></span><br><span class="line">mix <span class="keyword">do</span> ecto.create, ecto.migrate</span><br></pre></td></tr></table></figure><h3 id="2-3-安装-Blockscout-Backend-内置前端静态资源"><a href="#2-3-安装-Blockscout-Backend-内置前端静态资源" class="headerlink" title="2.3 安装 Blockscout Backend 内置前端静态资源"></a>2.3 安装 Blockscout Backend 内置前端静态资源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Node.js 依赖</span></span><br><span class="line"><span class="built_in">cd</span> apps/block_scout_web/assets</span><br><span class="line">npm install</span><br><span class="line">node_modules/webpack/bin/webpack.js --mode production</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">cd</span> apps/explorer</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译静态资源</span></span><br><span class="line"><span class="built_in">cd</span> ../block_scout_web/</span><br><span class="line">mix phx.digest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成自签名证书以启用 HTTPS（开发环境）：</span></span><br><span class="line">mix phx.gen.cert blockscout blockscout.local</span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><p>将 <code>blockscout</code> 和 <code>blockscout.local</code> 添加到 <code>/etc/hosts</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加以下行</span></span><br><span class="line">127.0.0.1 localhost blockscout blockscout.local</span><br><span class="line">::1 localhost blockscout blockscout.local</span><br></pre></td></tr></table></figure><h2 id="三、运行微服务"><a href="#三、运行微服务" class="headerlink" title="三、运行微服务"></a>三、运行微服务</h2><h3 id="3-1-修改-stats-yml"><a href="#3-1-修改-stats-yml" class="headerlink" title="3.1 修改 stats.yml"></a>3.1 修改 stats.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> docker-compose/services</span><br><span class="line">nano stats.yml</span><br></pre></td></tr></table></figure><p>将 <code>stats.yml</code> 文件的第 <strong>49</strong> 行改为自己的 <code>postgresql</code> 数据库，将 localhost 改为本机 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#STATS__BLOCKSCOUT_DB_URL=$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://blockscout:ceWb1MeLBEeOIfk65gU8EjF8@db:5432/blockscout&#125;</span></span><br><span class="line"></span><br><span class="line">STATS__BLOCKSCOUT_DB_URL=<span class="variable">$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://YOUR_DBUSER_NAME:YourSecurePassword@YourIPADDR:5432/blockscout&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-修改-user-ops-indexer-yml"><a href="#3-2-修改-user-ops-indexer-yml" class="headerlink" title="3.2 修改 user-ops-indexer.yml"></a>3.2 修改 user-ops-indexer.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano user-ops-indexer.yml</span><br></pre></td></tr></table></figure><p>修改 <code>user-ops-indexer.yml</code> 文件的第 <strong>15</strong> 和 <strong>16</strong> 行，替换自己的 <code>postgresql</code> 数据库和本机 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># USER_OPS_INDEXER__INDEXER__RPC_URL=$&#123;USER_OPS_INDEXER__INDEXER__RPC_URL:ws://host.docker.internal:8545/&#125;</span></span><br><span class="line"><span class="comment"># USER_OPS_INDEXER__DATABASE__CONNECT__URL=$&#123;USER_OPS_INDEXER__DATABASE__CONNECT__URL:postgresql://blockscout:ceWb1MeLBEeOIfk65gU8EjF8@db:5432/blockscout&#125;</span></span><br><span class="line"></span><br><span class="line">USER_OPS_INDEXER__INDEXER__RPC_URL=<span class="variable">$&#123;USER_OPS_INDEXER__INDEXER__RPC_URL:-ws://YourIPADDR:8546/&#125;</span></span><br><span class="line">STATS__BLOCKSCOUT_DB_URL=<span class="variable">$&#123;STATS__BLOCKSCOUT_DB_URL:postgresql://YOUR_DBUSER_NAME:YourSecurePassword@YourIPADDR:5432/blockscout&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-删除-explorer-conf-template"><a href="#3-3-删除-explorer-conf-template" class="headerlink" title="3.3 删除 explorer.conf.template"></a>3.3 删除 explorer.conf.template</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../proxy</span><br><span class="line"><span class="built_in">mv</span> explorer.conf.template explorer.conf.template.backup</span><br></pre></td></tr></table></figure><h3 id="3-4-修改-common-stats-yml"><a href="#3-4-修改-common-stats-yml" class="headerlink" title="3.4 修改 common-stats.yml"></a>3.4 修改 common-stats.yml</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../envs</span><br><span class="line">nano common-stats.env</span><br></pre></td></tr></table></figure><p>将 <code>common-stats.yml</code> 的第 <strong>29</strong> 行修改为自己的后端服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># STATS__BLOCKSCOUT_API_URL=http://host.docker.internal</span></span><br><span class="line">STATS__BLOCKSCOUT_API_URL=http://YourIPADDR:4000</span><br></pre></td></tr></table></figure><h3 id="3-5-启动内置微服务"><a href="#3-5-启动内置微服务" class="headerlink" title="3.5 启动内置微服务"></a>3.5 启动内置微服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">docker-compose -f microservices.yml up -d</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>此时如果 <code>layer2</code> 是启动状态，所有微服务都应该启动成功，如果失败查看 logs <code>docker logs ServiceName</code></p><p><img src="/images/2025/microservice.png" alt="microservice"></p><h3 id="3-6-启动后端服务"><a href="#3-6-启动后端服务" class="headerlink" title="3.6 启动后端服务"></a>3.6 启动后端服务</h3><p>返回 <code>blockscout-backend</code> 根目录并启动 Phoenix 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/blockscout/backend/</span><br><span class="line">mix phx.server</span><br></pre></td></tr></table></figure><p>后端应运行在 <code>http://localhost:4000</code>（或配置的域名）</p><p><img src="/images/2025/backend.png" alt="backend"></p><h2 id="四、构建-Blockscout-Frontend"><a href="#四、构建-Blockscout-Frontend" class="headerlink" title="四、构建 Blockscout Frontend"></a>四、构建 Blockscout Frontend</h2><h3 id="4-1-克隆-Blockscout-Frontend-仓库"><a href="#4-1-克隆-Blockscout-Frontend-仓库" class="headerlink" title="4.1 克隆 Blockscout Frontend 仓库"></a>4.1 克隆 Blockscout Frontend 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 blockscout frontend 并切换到最新 release 分支</span></span><br><span class="line"><span class="built_in">cd</span> ~/blockscout</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/blockscout/frontend.git frontend</span><br><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">git checkout v2.3.2 -b v2.3.2</span><br></pre></td></tr></table></figure><p>在 <code>frontend</code> 目录下新建 <code>.tool-versions</code> 文件并写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodejs 22.11.0</span><br></pre></td></tr></table></figure><h3 id="4-2-在-configs-envs-与根目录下分别创建-env-namepreset-和-env-文件"><a href="#4-2-在-configs-envs-与根目录下分别创建-env-namepreset-和-env-文件" class="headerlink" title="4.2 在 configs&#x2F;envs 与根目录下分别创建 .env.namepreset 和 .env 文件"></a>4.2 在 configs&#x2F;envs 与根目录下分别创建 .env.namepreset 和 .env 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用基础配置</span></span><br><span class="line">NEXT_PUBLIC_APP_HOST=localhost</span><br><span class="line">NEXT_PUBLIC_APP_PORT=3000</span><br><span class="line">NEXT_PUBLIC_APP_INSTANCE=localhost</span><br><span class="line">NEXT_PUBLIC_APP_ENV=development</span><br><span class="line"></span><br><span class="line">NEXT_PUBLIC_API_HOST=localhost</span><br><span class="line">NEXT_PUBLIC_API_PORT=4000</span><br><span class="line">NEXT_PUBLIC_API_PROTOCOL=http</span><br><span class="line">NEXT_PUBLIC_API_WEBSOCKET_PROTOCOL=<span class="string">&#x27;ws&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微服务配置</span></span><br><span class="line">NEXT_PUBLIC_STATS_API_HOST=http://localhost:8080</span><br><span class="line">NEXT_PUBLIC_VISUALIZE_API_HOST=http://localhost:8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首页内容配置</span></span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_CHARTS=[<span class="string">&#x27;daily_txs&#x27;</span>, <span class="string">&#x27;coin_price&#x27;</span>, <span class="string">&#x27;market_cap&#x27;</span>]</span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_HERO_BANNER_CONFIG=&#123;<span class="string">&quot;background&quot;</span>:[<span class="string">&quot;rgba(27, 74, 221, 1)&quot;</span>]&#125;</span><br><span class="line">NEXT_PUBLIC_HOMEPAGE_STATS=[<span class="string">&#x27;total_blocks&#x27;</span>,<span class="string">&#x27;average_block_time&#x27;</span>,<span class="string">&#x27;total_txs&#x27;</span>,<span class="string">&#x27;wallet_addresses&#x27;</span>,<span class="string">&#x27;gas_tracker&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广告配置</span></span><br><span class="line">NEXT_PUBLIC_AD_BANNER_PROVIDER=none</span><br><span class="line">NEXT_PUBLIC_AD_TEXT_PROVIDER=none</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区块链网络配置</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_NAME=<span class="string">&quot;YangFan&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_ID=L2_CHAIN_ID</span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_NAME=<span class="string">&quot;Sepolia ETH&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_SYMBOL=<span class="string">&quot;ETH&quot;</span></span><br><span class="line">NEXT_PUBLIC_NETWORK_CURRENCY_DECIMALS=18</span><br></pre></td></tr></table></figure><h3 id="4-3-启动前端服务"><a href="#4-3-启动前端服务" class="headerlink" title="4.3 启动前端服务"></a>4.3 启动前端服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装项目依赖并启动前端调试</span></span><br><span class="line">yarn install</span><br><span class="line">yarn dev:preset namepreset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试完成后启动服务</span></span><br><span class="line">yarn build</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>后端应运行在 <code>http://localhost:3000</code>（或配置的域名）</p><p><img src="/images/2025/frontend.png" alt="frontend"></p><p><strong>Hooray！Blockscout 部署成功！！！</strong></p><h2 id="五、故障排查"><a href="#五、故障排查" class="headerlink" title="五、故障排查"></a>五、故障排查</h2><h3 id="5-1-数据库最大连接数限制"><a href="#5-1-数据库最大连接数限制" class="headerlink" title="5.1 数据库最大连接数限制"></a>5.1 数据库最大连接数限制</h3><p><code>PostgreSQL</code> 的默认最大连接数（max_connections）通常为 <strong>100</strong>，Blockscout 后端和多个微服务会创建大量数据库连接，占用了所有可用连接槽。此时会遇到：<code>FATAL: sorry, too many clients already</code> 之类的错误，此时需要修改数据库默认最大连接数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postgresql/*/main/postgresql.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections = 500</span><br></pre></td></tr></table></figure><p>更改后需要重启 <code>PostgreSQL</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart postgresql</span><br></pre></td></tr></table></figure><h3 id="5-2-JavaScript-heap-out-of-memory"><a href="#5-2-JavaScript-heap-out-of-memory" class="headerlink" title="5.2 JavaScript heap out of memory"></a>5.2 JavaScript heap out of memory</h3><p><code>yarn build</code> 时可能会遇到 <code>JavaScript</code> 内存溢出，此时需要加载环境变量 <code>NODE_OPTIONS</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_OPTIONS=<span class="string">&quot;--max-old-space-size=4096&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-后端连接数据库失败"><a href="#5-3-后端连接数据库失败" class="headerlink" title="5.3 后端连接数据库失败"></a>5.3 后端连接数据库失败</h3><p>在用户名和密码都正确的前提下数据库连接失败，可能时因为 <code>PostgreSQL</code> 数据库的认证配置限制了密码认证方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postgresql/17/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>在 <code># IPv4 local connections:</code>下添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    all             all             0.0.0.0/0               scram-sha-256</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Blockscout 官方文档: <a href="https://docs.blockscout.com/setup/deployment/manual-deployment-guide">https://docs.blockscout.com/setup/deployment/manual-deployment-guide</a></li><li>前端仓库: <a href="https://github.com/blockscout/frontend">https://github.com/blockscout/frontend</a></li><li>后端仓库: <a href="https://github.com/blockscout/blockscout">https://github.com/blockscout/blockscout</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Blockscout </tag>
            
            <tag> Layer2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer2 —— OP Stack 部署指南</title>
      <link href="/2025/09/15/op-stack-deployment-part1/"/>
      <url>/2025/09/15/op-stack-deployment-part1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OP Stack 是 Optimism 开发的模块化区块链技术栈，允许开发者轻松创建自己的 Layer2 网络。本指南提供了在 Ubuntu 环境下从零开始搭建一个完整的 Layer2 网络，包括环境配置、合约部署、节点启动和基本操作验证。</p><h2 id="一、准备系统环境"><a href="#一、准备系统环境" class="headerlink" title="一、准备系统环境"></a>一、准备系统环境</h2><h3 id="1-1-安装-Ubuntu"><a href="#1-1-安装-Ubuntu" class="headerlink" title="1.1 安装 Ubuntu"></a>1.1 安装 Ubuntu</h3><p>打开 Windows PowerShell 终端</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用的 Ubuntu 发行版</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的 Ubuntu</span></span><br><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> Ubuntu<span class="literal">-24</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><h3 id="1-2-安装软件依赖"><a href="#1-2-安装软件依赖" class="headerlink" title="1.2 安装软件依赖"></a>1.2 安装软件依赖</h3><p>打开 Ubuntu-24.04 子系统（在安装 pnpm 和 mise 时，需修改自己环境变量加载的路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新系统</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y curl wget git build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 go</span></span><br><span class="line">wget https://go.dev/dl/go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local -xzf go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">rm</span> go1.25.0.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n# Go Language\nexport PATH=$PATH:/usr/local/go/bin&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 node.js</span></span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_22.x | <span class="built_in">sudo</span> -E bash -</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nodejs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 pnpm</span></span><br><span class="line">curl -fsSL https://get.pnpm.io/install.sh | sh</span><br><span class="line"><span class="built_in">source</span> /home/eth/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 foundry</span></span><br><span class="line">curl -L https://foundry.paradigm.xyz | bash</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">~/.foundry/bin/foundryup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 make</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 jq</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y jq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 direnv</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y direnv</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\n# Direnv hook\neval &quot;$(direnv hook bash)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 just</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br><span class="line">. <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span></span><br><span class="line">cargo install just</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 mise</span></span><br><span class="line">curl https://mise.run | sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;eval \&quot;\$(/home/eth/.local/bin/mise activate bash)\&quot;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="1-3-验证安装"><a href="#1-3-验证安装" class="headerlink" title="1.3 验证安装"></a>1.3 验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查所需软件依赖是否正确安装</span></span><br><span class="line">git --version<span class="comment"># git version 2.43.0</span></span><br><span class="line">go version        <span class="comment"># go version go1.25.0 linux/amd64</span></span><br><span class="line">node --version <span class="comment"># v22.19.0</span></span><br><span class="line">pnpm --version<span class="comment"># 10.16.1</span></span><br><span class="line">forge --version<span class="comment"># forge Version: 1.3.5-stable</span></span><br><span class="line">make --version<span class="comment"># GNU Make 4.3</span></span><br><span class="line">jq --version<span class="comment"># jq-1.7</span></span><br><span class="line">direnv --version<span class="comment"># 2.32.1</span></span><br><span class="line">rustc --version<span class="comment"># rustc 1.89.0 (29483883e 2025-08-04)</span></span><br><span class="line">just --version<span class="comment"># just 1.42.4</span></span><br><span class="line">mise --version<span class="comment"># 2025.9.10 linux-x64 (2025-09-13)</span></span><br></pre></td></tr></table></figure><h2 id="二、获取-Sepolia-测试网资源"><a href="#二、获取-Sepolia-测试网资源" class="headerlink" title="二、获取 Sepolia 测试网资源"></a>二、获取 Sepolia 测试网资源</h2><h3 id="2-1-获取-Sepolia-RPC-URL"><a href="#2-1-获取-Sepolia-RPC-URL" class="headerlink" title="2.1 获取 Sepolia RPC URL"></a>2.1 获取 Sepolia RPC URL</h3><p>从以下服务之一获取 Sepolia RPC URL:</p><ul><li><a href="https://www.alchemy.com/">Alchemy</a>（推荐）</li><li><a href="https://www.quicknode.com/">QuickNode</a></li><li><a href="https://zan.top/">ZAN</a></li></ul><h3 id="2-2-获取测试-ETH"><a href="#2-2-获取测试-ETH" class="headerlink" title="2.2 获取测试 ETH"></a>2.2 获取测试 ETH</h3><p>在以下链接中获取测试币 SepoliaETH。</p><ul><li><a href="https://console.optimism.io/faucet">Superchain Faucet</a></li><li><a href="https://cloud.google.com/application/web3/faucet/ethereum/sepolia">Google Ethereum Sepolia Faucet</a></li><li><a href="https://www.alchemy.com/faucets/ethereum-sepolia">Alchemy Ethereum Sepolia Faucet</a></li></ul><h2 id="三、构建-OP-Stack-组件"><a href="#三、构建-OP-Stack-组件" class="headerlink" title="三、构建 OP-Stack 组件"></a>三、构建 OP-Stack 组件</h2><h3 id="3-1-克隆-optimism-和-op-geth-仓库"><a href="#3-1-克隆-optimism-和-op-geth-仓库" class="headerlink" title="3.1 克隆 optimism 和 op-geth 仓库"></a>3.1 克隆 optimism 和 op-geth 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 optimism 并切换到最新 release 分支</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum-optimism/optimism.git</span><br><span class="line"><span class="built_in">cd</span> optimism</span><br><span class="line">git checkout v1.13.6 -b v1.13.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 op-geth 到 optimism 目录下并切换到最新 release 分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ethereum-optimism/op-geth.git</span><br><span class="line"><span class="built_in">cd</span> op-geth</span><br><span class="line">git checkout v1.101602.0 -b v1.101602.0</span><br></pre></td></tr></table></figure><h3 id="3-2-构建-op-geth，op-node，op-batcher，op-proposer"><a href="#3-2-构建-op-geth，op-node，op-batcher，op-proposer" class="headerlink" title="3.2 构建 op-geth，op-node，op-batcher，op-proposer"></a>3.2 构建 op-geth，op-node，op-batcher，op-proposer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-geth</span><br><span class="line">make geth</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">make op-node op-batcher op-proposer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查组件是否构建成功</span></span><br><span class="line">./op-geth/build/bin/geth --version</span><br><span class="line">./op-node/bin/op-node --version</span><br><span class="line">./op-batcher/bin/op-batcher --version</span><br><span class="line">./op-proposer/bin/op-proposer --version</span><br></pre></td></tr></table></figure><h2 id="四、配置环境变量"><a href="#四、配置环境变量" class="headerlink" title="四、配置环境变量"></a>四、配置环境变量</h2><h3 id="4-1-生成账户"><a href="#4-1-生成账户" class="headerlink" title="4.1 生成账户"></a>4.1 生成账户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism</span><br><span class="line">./packages/contracts-bedrock/scripts/getting-started/wallets.sh</span><br></pre></td></tr></table></figure><p>此命令会生成五个地址及其私钥：</p><ul><li><code>Admin</code>（管理员）</li><li><code>Batcher</code>（批处理者）</li><li><code>Proposer</code>（提议者）</li><li><code>Sequencer</code>（排序者）</li><li><code>Challenger</code>（挑战者）</li></ul><h3 id="4-2-编辑环境变量文件"><a href="#4-2-编辑环境变量文件" class="headerlink" title="4.2 编辑环境变量文件"></a>4.2 编辑环境变量文件</h3><p>创建<code>.envrc</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano .envrc</span><br></pre></td></tr></table></figure><p>填写以下变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Admin account</span></span><br><span class="line"><span class="built_in">export</span> GS_ADMIN_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_ADMIN_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Batcher account</span></span><br><span class="line"><span class="built_in">export</span> GS_BATCHER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_BATCHER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Proposer account</span></span><br><span class="line"><span class="built_in">export</span> GS_PROPOSER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_PROPOSER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sequencer account</span></span><br><span class="line"><span class="built_in">export</span> GS_SEQUENCER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_SEQUENCER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment"># Challenger account</span></span><br><span class="line"><span class="built_in">export</span> GS_CHALLENGER_ADDRESS=</span><br><span class="line"><span class="built_in">export</span> GS_CHALLENGER_PRIVATE_KEY=</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment">#            Layer1 RPC Configuration            #</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RPC URL for the L1 network to interact with</span></span><br><span class="line"><span class="built_in">export</span> L1_RPC_URL=</span><br><span class="line"><span class="built_in">export</span> L1_BEACON_URL=<span class="string">&quot;https://ethereum-sepolia-beacon-api.publicnode.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The kind of RPC provider, used to inform optimal transactions receipts</span></span><br><span class="line"><span class="comment"># fetching. Valid options: alchemy, quicknode, infura, parity, nethermind,</span></span><br><span class="line"><span class="comment"># debug_geth, erigon, basic, any.</span></span><br><span class="line"><span class="built_in">export</span> L1_RPC_KIND=</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment">#               Chain Configuration              #</span></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The unique chain ID of the Layer 1 network(e.g., Sepolia = 11155111)</span></span><br><span class="line"><span class="built_in">export</span> L1_CHAIN_ID=11155111</span><br><span class="line"><span class="comment"># The unique chain ID you assign to your Layer 2 network (custom value)</span></span><br><span class="line"><span class="built_in">export</span> L2_CHAIN_ID=</span><br><span class="line"><span class="comment"># The average block time of the Layer 1 network (in seconds)</span></span><br><span class="line"><span class="built_in">export</span> L1_BLOCK_TIME=12</span><br><span class="line"><span class="comment"># The block time you configure for your Layer 2 network (in seconds)</span></span><br><span class="line"><span class="built_in">export</span> L2_BLOCK_TIME=2</span><br></pre></td></tr></table></figure><p>保存文件(Ctrl+O, Enter, Ctrl+X)</p><h3 id="4-3-加载环境变量"><a href="#4-3-加载环境变量" class="headerlink" title="4.3 加载环境变量"></a>4.3 加载环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direnv allow</span><br></pre></td></tr></table></figure><p>验证环境变量是否加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 环境变量检查 ===&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_ADMIN_ADDRESS: <span class="variable">$GS_ADMIN_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_BATCHER_ADDRESS: <span class="variable">$GS_BATCHER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_PROPOSER_ADDRESS: <span class="variable">$GS_PROPOSER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_SEQUENCER_ADDRESS: <span class="variable">$GS_SEQUENCER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GS_CHALLENGER_ADDRESS: <span class="variable">$GS_CHALLENGER_ADDRESS</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_RPC_KIND: <span class="variable">$L1_RPC_KIND</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_RPC_URL: <span class="variable">$L1_RPC_URL</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_BEACON_URL: <span class="variable">$L1_BEACON_URL</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_CHAIN_ID: <span class="variable">$L1_CHAIN_ID</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L2_CHAIN_ID: <span class="variable">$L2_CHAIN_ID</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1_BLOCK_TIME: <span class="variable">$L1_BLOCK_TIME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L2_BLOCK_TIME: <span class="variable">$L2_BLOCK_TIME</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-为账户充值"><a href="#4-4-为账户充值" class="headerlink" title="4.4 为账户充值"></a>4.4 为账户充值</h3><p>为以下地址充值 SepoliaETH：</p><ul><li><code>Admin</code> — 0.5 SepoliaETH</li><li><code>Batcher</code> — 0.1 SepoliaETH</li><li><code>Proposer</code> — 0.2 SepoliaETH</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看账户余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_PROPOSER_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br></pre></td></tr></table></figure><h2 id="五、部署-L1-合约"><a href="#五、部署-L1-合约" class="headerlink" title="五、部署 L1 合约"></a>五、部署 L1 合约</h2><h3 id="5-1-获取-op-deployer"><a href="#5-1-获取-op-deployer" class="headerlink" title="5.1 获取 op-deployer"></a>5.1 获取 op-deployer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism</span><br><span class="line"><span class="built_in">mkdir</span> -p bin</span><br><span class="line">wget https://github.com/ethereum-optimism/optimism/releases/download/op-deployer%2Fv0.2.6/op-deployer-0.2.6-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">sudo</span> tar -C ./bin -xzf op-deployer-0.2.6-linux-amd64.tar.gz --strip-components=1</span><br><span class="line"><span class="built_in">rm</span> op-deployer-0.2.6-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否下载解压成功</span></span><br><span class="line">./bin/op-deployer --version</span><br></pre></td></tr></table></figure><h3 id="5-2-初始化-op-deployer-配置"><a href="#5-2-初始化-op-deployer-配置" class="headerlink" title="5.2 初始化 op-deployer 配置"></a>5.2 初始化 op-deployer 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.deployer</span><br><span class="line">./bin/op-deployer init --l1-chain-id <span class="variable">$L1_CHAIN_ID</span> --l2-chain-ids <span class="variable">$L2_CHAIN_ID</span> --workdir .deployer</span><br></pre></td></tr></table></figure><p>此命令会生成 <code>intend.json</code> 和 <code>state.json</code></p><h3 id="5-3-修改-intend-json-配置"><a href="#5-3-修改-intend-json-配置" class="headerlink" title="5.3 修改 intend.json 配置"></a>5.3 修改 intend.json 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano .deployer/intent.toml</span><br></pre></td></tr></table></figure><p>确保配置中包含以下内容并替换相应的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">configType = <span class="string">&quot;standard&quot;</span></span><br><span class="line">l1ChainID = 11155111</span><br><span class="line">opcmAddress = <span class="string">&quot;0x6b6f9129efb1b7a48f84e3b787333d1dca02ee34&quot;</span><span class="comment"># L1 上的 OP Chain Manager 合约地址</span></span><br><span class="line">fundDevAccounts = <span class="literal">false</span></span><br><span class="line">useInterop = <span class="literal">false</span></span><br><span class="line">l1ContractsLocator = <span class="string">&quot;tag://op-contracts/v2.2.0&quot;</span></span><br><span class="line">l2ContractsLocator = <span class="string">&quot;tag://op-contracts/v1.7.0-beta.1+l2-contracts&quot;</span></span><br><span class="line"></span><br><span class="line">[[chains]]</span><br><span class="line">  <span class="built_in">id</span> = <span class="string">&quot;0x00000000000000000000000000000000000000000000000000000000004f5da2&quot;</span><span class="comment"># L2_CHAIN_ID 的十六进制</span></span><br><span class="line">  baseFeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  l1FeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  sequencerFeeVaultRecipient = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">  eip1559DenominatorCanyon = 250</span><br><span class="line">  eip1559Denominator = 50</span><br><span class="line">  eip1559Elasticity = 6</span><br><span class="line">  [chains.roles]</span><br><span class="line">    l1ProxyAdminOwner = <span class="string">&quot;0x1eb2ffc903729a0f03966b917003800b145f56e2&quot;</span></span><br><span class="line">    l2ProxyAdminOwner = <span class="string">&quot;0x2fc3ffc903729a0f03966b917003800b145f67f3&quot;</span></span><br><span class="line">    systemConfigOwner = <span class="string">&quot;YOUR_ADMIN_ADDRESS&quot;</span></span><br><span class="line">    unsafeBlockSigner = <span class="string">&quot;YOUR_SEQUENCER_ADDRESS&quot;</span></span><br><span class="line">    batcher = <span class="string">&quot;YOUR_BATCHER_ADDRESS&quot;</span></span><br><span class="line">    proposer = <span class="string">&quot;YOUR_PROPOSER_ADDRESS&quot;</span></span><br><span class="line">    challenger = <span class="string">&quot;0xfd1d2e729ae8eee2e146c033bf4400fe75284301&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-部署-L1-合约"><a href="#5-4-部署-L1-合约" class="headerlink" title="5.4 部署 L1 合约"></a>5.4 部署 L1 合约</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询 L1 gas fee，判断 L1 RPC 是否连接成功</span></span><br><span class="line">cast gas-price --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署合约</span></span><br><span class="line">./bin/op-deployer apply --workdir .deployer --l1-rpc-url <span class="variable">$L1_RPC_URL</span> --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span></span><br></pre></td></tr></table></figure><h3 id="5-5-生成-L2-配置文件"><a href="#5-5-生成-L2-配置文件" class="headerlink" title="5.5 生成 L2 配置文件"></a>5.5 生成 L2 配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 genesis.json（用于 op-geth）</span></span><br><span class="line">./bin/op-deployer inspect genesis --workdir .deployer <span class="variable">$L2_CHAIN_ID</span> &gt; .deployer/genesis.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 rollup.json（用于 op-node）</span></span><br><span class="line">./bin/op-deployer inspect rollup --workdir .deployer <span class="variable">$L2_CHAIN_ID</span> &gt; .deployer/rollup.json</span><br></pre></td></tr></table></figure><h2 id="六、启动-Layer2"><a href="#六、启动-Layer2" class="headerlink" title="六、启动 Layer2"></a>六、启动 Layer2</h2><h3 id="6-1-初始化并启动-op-geth"><a href="#6-1-初始化并启动-op-geth" class="headerlink" title="6.1 初始化并启动 op-geth"></a>6.1 初始化并启动 op-geth</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 jwt 密钥用于 op-geth 与 op-node 通信</span></span><br><span class="line"><span class="built_in">cd</span> ~/optimism/op-geth</span><br><span class="line">openssl rand -hex 32 &gt; jwt.txt</span><br><span class="line"><span class="built_in">cp</span> jwt.txt ../op-node/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 op-geth</span></span><br><span class="line"><span class="built_in">mkdir</span> -p datadir</span><br><span class="line">build/bin/geth init --state.scheme=<span class="built_in">hash</span> --datadir=datadir ../.deployer/genesis.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 op-geth</span></span><br><span class="line">./build/bin/geth \</span><br><span class="line">--datadir ./datadir \</span><br><span class="line">--http \</span><br><span class="line">    --http.corsdomain=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --http.addr=0.0.0.0 \</span><br><span class="line">    --http.api=web3,debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --ws \</span><br><span class="line">    --ws.addr=0.0.0.0 \</span><br><span class="line">    --ws.port=8546 \</span><br><span class="line">    --ws.origins=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --ws.api=debug,eth,txpool,net,engine,miner \</span><br><span class="line">    --syncmode=full \</span><br><span class="line">    --gcmode=archive \</span><br><span class="line">    --nodiscover \</span><br><span class="line">    --maxpeers=0 \</span><br><span class="line">    --networkid=<span class="variable">$L2_CHAIN_ID</span> \</span><br><span class="line">    --authrpc.vhosts=<span class="string">&quot;*&quot;</span> \</span><br><span class="line">    --authrpc.addr=0.0.0.0 \</span><br><span class="line">    --authrpc.port=8551 \</span><br><span class="line">    --authrpc.jwtsecret=./jwt.txt \</span><br><span class="line">    --rollup.disabletxpoolgossip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="6-2-启动-op-node"><a href="#6-2-启动-op-node" class="headerlink" title="6.2 启动 op-node"></a>6.2 启动 op-node</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-node</span><br><span class="line"></span><br><span class="line">./bin/op-node \</span><br><span class="line">--l2=http://localhost:8551 \</span><br><span class="line">--l2.jwt-secret=./jwt.txt \</span><br><span class="line">--sequencer.enabled \</span><br><span class="line">--sequencer.l1-confs=5 \</span><br><span class="line">--verifier.l1-confs=4 \</span><br><span class="line">--rollup.config=../.deployer/rollup.json \</span><br><span class="line">--rpc.addr=0.0.0.0 \</span><br><span class="line">--rpc.port=9545 \</span><br><span class="line">--p2p.disable \</span><br><span class="line">--rpc.enable-admin \</span><br><span class="line">--p2p.sequencer.key=<span class="variable">$GS_SEQUENCER_PRIVATE_KEY</span> \</span><br><span class="line">--l1=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">--l1.rpckind=<span class="variable">$L1_RPC_KIND</span> \</span><br><span class="line">--l1.beacon=<span class="variable">$L1_BEACON_URL</span></span><br></pre></td></tr></table></figure><h3 id="6-3-启动-op-batcher"><a href="#6-3-启动-op-batcher" class="headerlink" title="6.3 启动 op-batcher"></a>6.3 启动 op-batcher</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/optimism/op-batcher</span><br><span class="line"></span><br><span class="line">./bin/op-batcher \</span><br><span class="line">--l2-eth-rpc=http://localhost:8545 \</span><br><span class="line">--rollup-rpc=http://localhost:9545 \</span><br><span class="line">--poll-interval=1s \</span><br><span class="line">--sub-safety-margin=6 \</span><br><span class="line">--num-confirmations=1 \</span><br><span class="line">--safe-abort-nonce-too-low-count=3 \</span><br><span class="line">--resubmission-timeout=30s \</span><br><span class="line">--rpc.addr=0.0.0.0 \</span><br><span class="line">--rpc.port=8548 \</span><br><span class="line">--rpc.enable-admin \</span><br><span class="line">--max-channel-duration=25 \</span><br><span class="line">--l1-eth-rpc=<span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">--private-key=<span class="variable">$GS_BATCHER_PRIVATE_KEY</span></span><br></pre></td></tr></table></figure><h3 id="6-4-启动-op-proposer"><a href="#6-4-启动-op-proposer" class="headerlink" title="6.4 启动 op-proposer"></a>6.4 启动 op-proposer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 op-proposer 配置变量（也可加到 .envrc 里面）</span></span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_WAIT_NODE_SYNC=<span class="literal">true</span></span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_PROPOSAL_INTERVAL=15m</span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_GAME_FACTORY_ADDRESS=$(<span class="built_in">cat</span> ~/.deployer/state.json | jq -r <span class="string">&#x27;.opChainDeployments[0].disputeGameFactoryProxyAddress&#x27;</span>)</span><br><span class="line"><span class="built_in">export</span> OP_PROPOSER_GAME_TYPE=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/optimism/op-proposer</span><br><span class="line"></span><br><span class="line">./bin/op-proposer \</span><br><span class="line">  --poll-interval=12s \</span><br><span class="line">  --rpc.port=8560 \</span><br><span class="line">  --rollup-rpc=http://localhost:9545 \</span><br><span class="line">  --private-key=<span class="variable">$GS_PROPOSER_PRIVATE_KEY</span> \</span><br><span class="line">  --l1-eth-rpc=<span class="variable">$L1_RPC_URL</span></span><br></pre></td></tr></table></figure><h2 id="七、验证部署"><a href="#七、验证部署" class="headerlink" title="七、验证部署"></a>七、验证部署</h2><h3 id="7-1-检查-L2-链状态"><a href="#7-1-检查-L2-链状态" class="headerlink" title="7.1 检查 L2 链状态"></a>7.1 检查 L2 链状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  --data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_blockNumber&quot;,&quot;params&quot;:[],&quot;id&quot;:1&#125;&#x27;</span> \</span><br><span class="line">  <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="7-2-连接钱包到-Layer2"><a href="#7-2-连接钱包到-Layer2" class="headerlink" title="7.2 连接钱包到 Layer2"></a>7.2 连接钱包到 Layer2</h3><p>在 MetaMask 中添加自定义网络：</p><ul><li>网络名称：OP Stack Rollup</li><li>RPC URL：<a href="http://localhost:8545/">http://localhost:8545</a></li><li>链 ID：L2_CHAIN_ID</li><li>符号：ETH</li></ul><h3 id="7-3-将-SepoliaETH-发送到-Bridge-合约"><a href="#7-3-将-SepoliaETH-发送到-Bridge-合约" class="headerlink" title="7.3 将 SepoliaETH 发送到 Bridge 合约"></a>7.3 将 SepoliaETH 发送到 Bridge 合约</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 L1StandardBridge 地址</span></span><br><span class="line">L1StandardBridge=$(<span class="built_in">cat</span> ~/optimism/.deployer/state.json | jq -r <span class="string">&#x27;.opChainDeployments[0].l1StandardBridgeProxyAddress&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;L1StandardBridge 地址: <span class="variable">$L1StandardBridge</span>&quot;</span></span><br></pre></td></tr></table></figure><p>通过 Metamask 向你的 <strong>桥接地址</strong> 发送(0.0001 SepoliaETH)，发送成功后大约需要 5 分钟才能在 Layer2 上看到 ETH.</p><p><strong>Hooray！Op Stack 部署成功！！！</strong></p><h2 id="八、基本转账-CLI-操作实例"><a href="#八、基本转账-CLI-操作实例" class="headerlink" title="八、基本转账 CLI 操作实例"></a>八、基本转账 CLI 操作实例</h2><h3 id="8-1-从-L1-的-Admin-桥接到-L2-的-admin"><a href="#8-1-从-L1-的-Admin-桥接到-L2-的-admin" class="headerlink" title="8.1 从 L1 的 Admin 桥接到 L2 的 admin"></a>8.1 从 L1 的 Admin 桥接到 L2 的 admin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cast send <span class="variable">$L1StandardBridge</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.0001ether \</span><br><span class="line">  <span class="string">&quot;depositETH(uint32,bytes)&quot;</span> \</span><br><span class="line">  200000 \</span><br><span class="line">  <span class="string">&quot;0x&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L1 和 L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="8-2-从-L1-的-Admin-桥接到-L2-的-Batcher"><a href="#8-2-从-L1-的-Admin-桥接到-L2-的-Batcher" class="headerlink" title="8.2 从 L1 的 Admin 桥接到 L2 的 Batcher"></a>8.2 从 L1 的 Admin 桥接到 L2 的 Batcher</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cast send <span class="variable">$L1StandardBridge</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L1_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_ADMIN_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.0001ether \</span><br><span class="line">  <span class="string">&quot;depositETHTo(address,uint32,bytes)&quot;</span> \</span><br><span class="line">  <span class="variable">$GS_BATCHER_ADDRESS</span> \</span><br><span class="line">  200000 \</span><br><span class="line">  <span class="string">&quot;0x&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L1 和 Batcher L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L1_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure><h3 id="8-3-L2-转账"><a href="#8-3-L2-转账" class="headerlink" title="8.3 L2 转账"></a>8.3 L2 转账</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L2 从 Batcher 转账到 Admin</span></span><br><span class="line">cast send <span class="variable">$GS_ADMIN_ADDRESS</span> \</span><br><span class="line">  --rpc-url <span class="variable">$L2_RPC_URL</span> \</span><br><span class="line">  --private-key <span class="variable">$GS_BATCHER_PRIVATE_KEY</span> \</span><br><span class="line">  --value 0.00001ether</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Admin L2 和 Batcher L2 的余额</span></span><br><span class="line">cast balance <span class="variable">$GS_ADMIN_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br><span class="line">cast balance <span class="variable">$GS_BATCHER_ADDRESS</span> --rpc-url <span class="variable">$L2_RPC_URL</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Layer2 </tag>
            
            <tag> OPStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢练勤修，别急放松 | 道家武术馆一月清修</title>
      <link href="/2025/02/22/taichi-28/"/>
      <url>/2025/02/22/taichi-28/</url>
      
        <content type="html"><![CDATA[<p>一月上旬读了三本书 ——《36 万遍感恩的奇迹》、《清醒地活》、《内在工程》，这三本书中都有部分篇幅讲述了阴阳哲学，让我对道家文化产生了浓厚兴趣，再次看到之前觉得平平无奇的太极图的第一反应竟然是 —— <em>It is fascinating</em>，刚好今年也有学习太极和养生的计划，然后就报名了武当山道家传统武术馆的养生班，开启了一个月的清修生活。</p><img src="/images/2025/slow_is_fast.jpg" width="70%" alt="Slow is Fast" style="display: block; margin: 0 auto;"><hr><h2 id="武馆日常"><a href="#武馆日常" class="headerlink" title="武馆日常"></a>武馆日常</h2><ul><li>早上 <strong>6:30</strong> 到练功堂共修五行气功</li><li>上午 <strong>9:00</strong> 和下午 <strong>15:00</strong> 的武术课是教练带同学们一起练习大约一小时的基本功<br>（包含柔韧性、耐力、平衡性、协调性、爆发力的训练。这一部分我超级喜欢，有开心快乐的蹦蹦跳跳环节）</li><li>之后到各自教练的带练区域学习或复习自己的功法</li><li>傍晚 <strong>18:30</strong> 有一个小时的静坐课，教练会带大家做几组静态拉伸然后开启禅修模式</li></ul><p>武馆日常伙食清淡，素食者友好，我感觉在武馆待了一个月体表脂肪都厚了一点点。<br>住宿我选的是舒适单人间，我觉得环境很舒适很方便而且下午的时候我的房间可以晒到大太阳，洒进房间的阳光让人心情舒畅~</p><img src="/images/2025/standing.jpg" width="60%" alt="站桩" style="display: block; margin: 0 auto;"><hr><h2 id="阅读与体悟"><a href="#阅读与体悟" class="headerlink" title="阅读与体悟"></a>阅读与体悟</h2><p>在武馆清修期间阅读了五本书，其中两本和武馆修习很搭特别推荐：</p><ul><li>《The Inner Game of Tennis》（中文版是《身心合一的奇迹力量》，武志红老师推荐）和这本书中提及的《箭术与禅心》</li></ul><p>在平日练功的时候我会让自己的大脑安静下来，让自己的注意力放松，不去过度尝试努力，而是有觉知地卸掉多余紧张的力，相信自己的身体并让其自然流动，并在攻与防的招式转换中体验势的变化。</p><p>在这个过程中好像对“消融的自我”也有了一些体悟：</p><ul><li>太极养我的同时我也在养太极</li><li>我在执剑的时候剑也同时在执我</li><li>消融的自我是客与主的转换，在这一瞬似乎都彼此融合，也就再没有区分的需要了</li></ul><img src="/images/2025/daodejing.jpg" width="70%" alt="Dao De Jing" style="display: block; margin: 0 auto;"><hr><h2 id="休息日体验"><a href="#休息日体验" class="headerlink" title="休息日体验"></a>休息日体验</h2><p>除了武馆的修习之外，休息日和结识的伙伴一起解锁了许多体验：</p><ul><li>除夕日从南岩徒步上金顶抽签，刚好抽到的签和这次清修的初心相关，特别喜欢——阴阳道和<br> （如果抽的签不太满意就再抽，出来玩开心最重要）</li></ul><img src="/images/2025/cat.jpg" width="55%" alt="Cat" style="display: block; margin: 0 auto;"><ul><li>去购买修道风练功服</li><li>去体验道家按摩</li><li>去打卡步行街素食餐厅</li><li>去看《武当一梦》和烟花无人机秀等等</li><li>本周三还参加了武馆汇演，刚好是清修最后一天，就算是毕业典礼了</li></ul><img src="/images/2025/dream_of_wudang.jpg" width="70%" alt="One Dream at Wudang" style="display: block; margin: 0 auto;"><hr><h2 id="感恩与前行"><a href="#感恩与前行" class="headerlink" title="感恩与前行"></a>感恩与前行</h2><p>很感恩，很开心，很幸运能够遇见那么多很好的伙伴。<br>分别之际虽有不舍，但大家表达的更多是感谢和祝福，而我也会带着这份感恩的心念继续往前走走~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神圣的静默 | 武夷山东山禅林十日内观</title>
      <link href="/2024/12/12/vipassana/"/>
      <url>/2024/12/12/vipassana/</url>
      
        <content type="html"><![CDATA[<p>在山上度过了十天禁言、与外界信息隔离的出家生活，从观呼吸开始以慈悲观结束。去之前从没想过内观禅修那么难，难在深入敏锐地专注，难在全然平等地接受。</p><hr><h2 id="关于做"><a href="#关于做" class="headerlink" title="关于做"></a>关于做</h2><p><strong>‘The doers are the major thinkers’</strong> ——这是禅修期间每天都会反反复复浮现在脑海中的一句话，然后在第十天的时候脑海浮现了一个中文翻译，感觉还挺贴切——</p><p><strong>“那些真正付出行动去实践他所思所想的人才是真正的思想家”</strong></p><p>现在回想以前很多时候大概是知道该怎么做的，但是由于内心不够强大，在意他人看法，对确定性的过度偏好再加上周围遇到的人事物，经常陷入自我怀疑和自我否定的状态，这种状态反反复复，消耗了本就不多的心力，淹没了本就微弱的心声，导致无法行动。</p><p>可是当我从广泛的阅读中越来越多地感受到，无论是像苏格拉底、庄子、尼采、黑塞这样的智慧先哲，还是像佛陀、克里希那穆提、葛印卡、萨古茹这样的无私古茹，亦或是像芒格、乔布斯、段永平、纳瓦尔这样的当代名人等等，这些自己内心所尊敬的灵魂或榜样在一生中大部分时间都在践行那些基本的价值观和准则。</p><p>当感受到这点后，自己这颗惶恐不安、迷茫无措、心猿意马的心也慢慢变得更平稳、更清晰、更坚定，向前踏出的脚步也多了几分笃定。</p><p>而当我不再仅仅满足于知识上的理解，而是更多地专注于经验上的理解时，根本性的改变也随之自然而然地发生。</p><hr><h2 id="关于真"><a href="#关于真" class="headerlink" title="关于真"></a>关于真</h2><p>今年的某天我突然意识到我和父母和谐的关系存在泡沫之中，这种虚假的和谐是以无意识地接受那些习以为常的违背自身感受的隐性要求为代价。</p><p>这种长期无意识地接受，这种假只会产生无尽的无意识的否定、扭曲、压抑、控制，这种假永远不会带来真正的了解、真正的尊重、真正的关心、真正的责任。</p><p><strong>假无法带来真正的爱，而真正的爱不会带来伤害。</strong></p><p>当意识到这点后，那些曾经以为已经修复的原生家庭创伤又开始频繁地让我陷入愤怒或悲伤式的情绪闪回，时常让我暴躁不安。</p><p>但这次我决定接受这份创伤就是我的一部分这个事实，不再去否定、合理化、压抑或是试图去原谅，只是全然平等地接受，我决心拥抱完整的自己。</p><p>于是我用内观这把手术刀更深地剖析自己的内心，没有恐惧，没有犹豫。因为我很幸运，我找到了心底那处一直缺失的力量。</p><p>当愤怒像熔岩般喷薄而出时，自我保护和自我支持的意愿便会更加强烈；当悲伤像海浪般呼啸而来时，自我同情和自我关怀的心意便会愈发柔软；当愤怒与悲伤彼此碰撞消融，爱就再次开始流动。</p><hr><h2 id="关于自我"><a href="#关于自我" class="headerlink" title="关于自我"></a>关于自我</h2><p>之前一直有听到说我们这一代比较自我，不健康的自我。可是在意尊重自己的感受真的是一种错误吗？</p><p>当我在学习爱自己的道路上越往前走，我越能深刻理解爱的四要素：</p><ul><li><strong>了解</strong></li><li><strong>尊重</strong></li><li><strong>关心</strong></li><li><strong>责任</strong></li></ul><p>都同等重要并相辅相成。</p><p>如果不能尊重自己的感受，则会产生对自己的否定和压抑，而被压抑的感受则会进入潜意识深层难以根除。</p><p>但是后来我突然明白，那些动机是要求别人违背自己感受以满足自己需求，或是只想周围都围着自己转的人，才是不健康的自我，或是说我执。</p><p>健康的自我需要修炼平等心，如果内心有过多的贪爱，必然会有过多的嗔恨，便会带来我执的痛苦。</p><p>而只有健康的自我或是消融的自我，才更有可能发展出创造性倾向的能力。</p><hr><h2 id="关于变化"><a href="#关于变化" class="headerlink" title="关于变化"></a>关于变化</h2><p>此处引用今年阅读《芒格之道》时直接刻在我心底的一句话——</p><p><strong>“变化总在发生，不去主动迎接进步的变化，就会等到退步的变化。”</strong></p><p>无常，无常，无常，既然不确定性是常态，那就与不确定性共舞，继续往前走走~</p><hr><p>培养觉知，练习感恩<br>持续精进，坚定决心！</p><p><img src="/images/2024/vipassana.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25 Today, Halfway to 50 🤭</title>
      <link href="/2024/01/15/happy-birthday/"/>
      <url>/2024/01/15/happy-birthday/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2024/happy_birthday.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Dialogue with Myself</title>
      <link href="/2023/12/31/2023/"/>
      <url>/2023/12/31/2023/</url>
      
        <content type="html"><![CDATA[<div align="center"><p><strong>2023 年的每一个月、每一周都有一点点不一样</strong><br>某一天，我做了一个小小的改变，从那之后，<strong>每一天</strong>也随之焕然一新<br>因为在喜欢我的人里，多了一位很重要的人 —— <strong>我自己</strong></p><p><em>Just a little change can make all the difference.</em></p><hr><p>当我决定喜欢我自己<br>我开始记录下我每天做得不错的地方<br>以及那些让我开心的事情</p><p>某一天，在日常记录中，我恍然大悟 ——<br>噢，原来这就是 <strong>「具体」</strong></p><hr><p>当内耗与模糊渐渐消散<br>当我开始拥抱所有的感受<br>当我的状态变得越来越好时<br>某一天，我突然明白了《当我开始真正爱自己》这首诗中<br>“<strong>「真正」</strong>”这一词的含义</p><p>那一刻，我知道自己也真正<br>习得了喜欢与爱的能力<br>当然现在还不够有力<br>仍在积蓄力量中~</p><hr><h3 id="✨-My-Vision-for-2024"><a href="#✨-My-Vision-for-2024" class="headerlink" title="✨ My Vision for 2024"></a>✨ My Vision for 2024</h3><p><strong>继续践行长期主义</strong><br><strong>每过完一天，要努力比早上醒来时更聪明一点点</strong><br><strong>培养理性 · 保持好奇 · 珍惜日常</strong> 🌻</p><img src="/images/2023/hello_2024.jpg" width="85%" alt="hello, 2024"></div>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortunate to Cross Paths</title>
      <link href="/2023/12/17/fortunate_to_cross_paths/"/>
      <url>/2023/12/17/fortunate_to_cross_paths/</url>
      
        <content type="html"><![CDATA[<div align="center"><p>原来每段相遇都有一份恩情<br>回望今年走过的路，徒过的步<br>不知不觉大家已经认识这么久了<br>感谢相遇，感谢一路同行 🔆</p></div><img src="/images/2023/companions.jpg" width="85%" alt="companions">]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于人来人往中，不惧离索</title>
      <link href="/2022/12/31/2022/"/>
      <url>/2022/12/31/2022/</url>
      
        <content type="html"><![CDATA[<p>生命是一个淡淡的悲伤的过程，我们要不断地和过去告别，和很多事物告别</p><p>既然现实就是为了分别而相遇，那希望在今后的日子里，能够勇敢去爱，在所有的相遇中不断朝着＂最佳分别＂而努力，直到生命的最后一天</p><p>也希望未来的自己，内心能如水一般，变得更柔软、更包容、更平静~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flow </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
