<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Let it flow~</title>
  
  
  <link href="https://faniyang.github.io/atom.xml" rel="self"/>
  
  <link href="https://faniyang.github.io/"/>
  <updated>2025-10-10T14:29:47.180Z</updated>
  <id>https://faniyang.github.io/</id>
  
  <author>
    <name>Faniyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Raydium Swap —— Config</title>
    <link href="https://faniyang.github.io/2025/10/11/raydium-swap-config/"/>
    <id>https://faniyang.github.io/2025/10/11/raydium-swap-config/</id>
    <published>2025-10-11T13:21:00.000Z</published>
    <updated>2025-10-10T14:29:47.180Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Raydium Swap 系统中，&lt;strong&gt;Config&lt;/strong&gt; 是全局配置中心，用于统一管理费率参数、权限开关和资金接收地址，是各个流动性池运行的基础控制单元。&lt;/p&gt;
&lt;h2 id=&quot;合约代码&quot;&gt;&lt;a href=&quot;#合约代码&quot;</summary>
        
      
    
    
    
    
    <category term="Solana" scheme="https://faniyang.github.io/tags/Solana/"/>
    
    <category term="Raydium Swap" scheme="https://faniyang.github.io/tags/Raydium-Swap/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 并发</title>
    <link href="https://faniyang.github.io/2025/10/10/rust-concurrency/"/>
    <id>https://faniyang.github.io/2025/10/10/rust-concurrency/</id>
    <published>2025-10-10T13:30:44.000Z</published>
    <updated>2025-10-08T03:34:45.968Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;安全高效地处理并发编程是 Rust 的主要目标之一。&lt;strong&gt;并发编程&lt;/strong&gt;（concurrent programming）是指程序的不同部分独立执行，而&lt;strong&gt;并行编程&lt;/strong&gt;（parallel</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 智能指针</title>
    <link href="https://faniyang.github.io/2025/10/09/rust-smart-pointers/"/>
    <id>https://faniyang.github.io/2025/10/09/rust-smart-pointers/</id>
    <published>2025-10-09T13:27:12.000Z</published>
    <updated>2025-10-08T03:03:39.986Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;指针（Pointer）是一个包含内存地址的变量，这个地址指向存储在内存中的其他数据。Rust 中最常见的指针是引用（reference），用 &lt;code&gt;&amp;amp;&lt;/code&gt; 符号表示，它们只借用数据而不拥有所有权。&lt;/p&gt;
&lt;p&gt;而智能指针（Smart</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Solana —— PDA 与 CPI</title>
    <link href="https://faniyang.github.io/2025/10/08/solana-cpi-pda/"/>
    <id>https://faniyang.github.io/2025/10/08/solana-cpi-pda/</id>
    <published>2025-10-08T13:12:45.000Z</published>
    <updated>2025-10-10T13:23:38.641Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;Program-Derived-Address-PDA&quot;&gt;&lt;a href=&quot;#Program-Derived-Address-PDA&quot; class=&quot;headerlink&quot; title=&quot;Program Derived Address</summary>
        
      
    
    
    
    
    <category term="Solana Basic" scheme="https://faniyang.github.io/tags/Solana-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 迭代器</title>
    <link href="https://faniyang.github.io/2025/10/07/rust-iterators/"/>
    <id>https://faniyang.github.io/2025/10/07/rust-iterators/</id>
    <published>2025-10-07T13:29:44.000Z</published>
    <updated>2025-10-07T02:45:00.333Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;迭代器（Iterator）是 Rust 中用于处理元素序列的强大工具。迭代器模式允许你对一系列项进行某些操作，而无需手动管理索引或循环逻辑。Rust 的迭代器是惰性的（lazy），只在需要时才会执行计算，这使得它们既高效又灵活。&lt;/p&gt;
&lt;h2</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 闭包</title>
    <link href="https://faniyang.github.io/2025/10/06/rust-closures/"/>
    <id>https://faniyang.github.io/2025/10/06/rust-closures/</id>
    <published>2025-10-06T13:29:28.000Z</published>
    <updated>2025-10-07T02:45:03.300Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;闭包（Closure）是 Rust 中一种可以捕获环境变量的匿名函数。与普通函数不同，闭包可以保存在变量中、作为参数传递给其他函数，并且能够捕获定义时所在作用域的变量。闭包是 Rust 函数式编程特性的核心组成部分。&lt;/p&gt;
&lt;h2 id=&quot;1-闭包基础&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Layer2 —— OP Stack 介绍</title>
    <link href="https://faniyang.github.io/2025/10/05/op-stack-intro-part5/"/>
    <id>https://faniyang.github.io/2025/10/05/op-stack-intro-part5/</id>
    <published>2025-10-05T05:19:37.000Z</published>
    <updated>2025-10-07T03:27:16.376Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;OP Stack 是由 Optimism 团队开发的模块化区块链技术栈，让开发者能够像”搭积木”一样构建自己的 Layer2 网络。可以将 OP Stack 想象成一个”区块链建设套件”，里面包含了构建高性能区块链所需的所有核心组件。&lt;/p&gt;
&lt;h2</summary>
        
      
    
    
    
    
    <category term="Layer2" scheme="https://faniyang.github.io/tags/Layer2/"/>
    
    <category term="OPStack" scheme="https://faniyang.github.io/tags/OPStack/"/>
    
  </entry>
  
  <entry>
    <title>Solana —— SPL TOKEN 简单合约</title>
    <link href="https://faniyang.github.io/2025/10/04/solana-spl-token/"/>
    <id>https://faniyang.github.io/2025/10/04/solana-spl-token/</id>
    <published>2025-10-04T05:14:52.000Z</published>
    <updated>2025-10-10T13:23:52.551Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;本节实现了一个 Solana SPL Token 程序，包括链上智能合约和客户端调用代码。主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建新的 SPL Token&lt;/li&gt;
&lt;li&gt;铸造代币到用户账户&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-核心概念&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Solana Basic" scheme="https://faniyang.github.io/tags/Solana-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Solana —— Token 基础</title>
    <link href="https://faniyang.github.io/2025/10/03/solana-token-basic/"/>
    <id>https://faniyang.github.io/2025/10/03/solana-token-basic/</id>
    <published>2025-10-03T04:50:57.000Z</published>
    <updated>2025-10-10T13:24:02.151Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;什么是-Token？&quot;&gt;&lt;a href=&quot;#什么是-Token？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Token？&quot;&gt;&lt;/a&gt;什么是 Token？&lt;/h2&gt;&lt;p&gt;在 Solana 区块链上，&lt;strong&gt;Token&lt;/strong&gt;</summary>
        
      
    
    
    
    
    <category term="Solana Basic" scheme="https://faniyang.github.io/tags/Solana-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Solana —— 账户模型与简单交互</title>
    <link href="https://faniyang.github.io/2025/10/02/solana-account-model/"/>
    <id>https://faniyang.github.io/2025/10/02/solana-account-model/</id>
    <published>2025-10-02T03:18:39.000Z</published>
    <updated>2025-10-10T13:23:31.821Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Solana 中，所有数据都存储在称为”账户”（Accounts）的结构中。可以将 Solana 上的数据视为一个公共数据库，其中有一个名为”Accounts”的表，表中的每一条记录就是一个”账户”。&lt;/p&gt;
&lt;h2 id=&quot;1-核心要点&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Solana Basic" scheme="https://faniyang.github.io/tags/Solana-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Solana —— 环境搭建与基础命令</title>
    <link href="https://faniyang.github.io/2025/10/01/solana-install-and-cli/"/>
    <id>https://faniyang.github.io/2025/10/01/solana-install-and-cli/</id>
    <published>2025-10-01T07:17:14.000Z</published>
    <updated>2025-10-10T13:23:45.388Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-环境安装&quot;&gt;&lt;a href=&quot;#1-环境安装&quot; class=&quot;headerlink&quot; title=&quot;1. 环境安装&quot;&gt;&lt;/a&gt;1. 环境安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
        
      
    
    
    
    
    <category term="Solana Basic" scheme="https://faniyang.github.io/tags/Solana-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 生命周期</title>
    <link href="https://faniyang.github.io/2025/09/30/rust-lifetimes/"/>
    <id>https://faniyang.github.io/2025/09/30/rust-lifetimes/</id>
    <published>2025-09-30T03:29:17.000Z</published>
    <updated>2025-10-03T05:13:21.722Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;生命周期（Lifetime）是 Rust 中确保引用有效性的机制。每个引用都有生命周期，即引用保持有效的作用域。大多数情况下生命周期是隐式推断的，但在某些情况下需要显式标注。&lt;/p&gt;
&lt;h2 id=&quot;1-生命周期的作用&quot;&gt;&lt;a href=&quot;#1-生命周期的作用&quot;</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 特征</title>
    <link href="https://faniyang.github.io/2025/09/29/rust-traits/"/>
    <id>https://faniyang.github.io/2025/09/29/rust-traits/</id>
    <published>2025-09-29T03:28:55.000Z</published>
    <updated>2025-10-03T05:13:21.720Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Trait 定义了类型可以共享的行为。可以使用 trait 以抽象的方式定义共享行为，使用 trait 约束指定泛型类型必须具有特定行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Trait</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 泛型</title>
    <link href="https://faniyang.github.io/2025/09/28/rust-generic-types/"/>
    <id>https://faniyang.github.io/2025/09/28/rust-generic-types/</id>
    <published>2025-09-28T03:28:14.000Z</published>
    <updated>2025-10-03T05:13:21.722Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;泛型允许我们用抽象的类型参数替代具体类型，从而编写可复用的代码。Rust 在编译时会进行&lt;strong&gt;单态化（Monomorphization）&lt;/strong&gt;，将泛型代码转换为具体类型的代码，因此使用泛型不会带来运行时性能损失。&lt;/p&gt;
&lt;h2</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 错误处理</title>
    <link href="https://faniyang.github.io/2025/09/27/rust-error-handling/"/>
    <id>https://faniyang.github.io/2025/09/27/rust-error-handling/</id>
    <published>2025-09-27T03:12:04.000Z</published>
    <updated>2025-10-03T05:13:21.723Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Rust 将错误分为两大类：&lt;strong&gt;可恢复错误&lt;/strong&gt;和&lt;strong&gt;不可恢复错误&lt;/strong&gt;。可恢复错误用 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 处理，不可恢复错误用 &lt;code&gt;panic!&lt;/code&gt;</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 常见集合</title>
    <link href="https://faniyang.github.io/2025/09/26/rust-common-collections/"/>
    <id>https://faniyang.github.io/2025/09/26/rust-common-collections/</id>
    <published>2025-09-26T03:11:49.000Z</published>
    <updated>2025-10-03T05:13:25.042Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Rust</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 枚举和模式匹配</title>
    <link href="https://faniyang.github.io/2025/09/25/rust-enums-and-pattern-matching/"/>
    <id>https://faniyang.github.io/2025/09/25/rust-enums-and-pattern-matching/</id>
    <published>2025-09-25T03:11:26.000Z</published>
    <updated>2025-10-03T05:13:21.723Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;枚举（Enum）允许我们通过列举所有可能的变体来定义一个类型。与结构体类似，枚举也可以包含数据和方法，但更适合表示”多选一”的情况。&lt;/p&gt;
&lt;h2 id=&quot;1-定义和使用枚举&quot;&gt;&lt;a href=&quot;#1-定义和使用枚举&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 结构体</title>
    <link href="https://faniyang.github.io/2025/09/24/rust-structs/"/>
    <id>https://faniyang.github.io/2025/09/24/rust-structs/</id>
    <published>2025-09-24T02:19:13.000Z</published>
    <updated>2025-10-03T05:13:21.721Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;结构体（Struct）和元组类似，都可以包含不同类型的数据。但与元组不同的是，结构体中的每个字段都有命名，因此更加清晰、灵活。我们不需要依赖数据的顺序来访问值，而是通过字段名来访问。&lt;/p&gt;
&lt;h2 id=&quot;1-定义和实例化结构体&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 所有权</title>
    <link href="https://faniyang.github.io/2025/09/23/rust-ownership/"/>
    <id>https://faniyang.github.io/2025/09/23/rust-ownership/</id>
    <published>2025-09-23T05:24:21.000Z</published>
    <updated>2025-10-03T05:13:21.714Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Rust 最独特的特性之一就是 &lt;strong&gt;所有权（Ownership）&lt;/strong&gt;，它让 Rust 在没有垃圾回收器（GC）的情况下仍能保证内存安全。理解所有权的工作原理非常重要。&lt;/p&gt;
&lt;h2 id=&quot;1-所有权的基本概念&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust —— 流程控制</title>
    <link href="https://faniyang.github.io/2025/09/22/rust-control-flows/"/>
    <id>https://faniyang.github.io/2025/09/22/rust-control-flows/</id>
    <published>2025-09-22T05:14:07.000Z</published>
    <updated>2025-10-03T05:13:21.727Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;1-条件分支&quot;&gt;&lt;a href=&quot;#1-条件分支&quot; class=&quot;headerlink&quot; title=&quot;1. 条件分支&quot;&gt;&lt;/a&gt;1. 条件分支&lt;/h2&gt;&lt;h3 id=&quot;if-表达式&quot;&gt;&lt;a href=&quot;#if-表达式&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Rust" scheme="https://faniyang.github.io/tags/Rust/"/>
    
  </entry>
  
</feed>
